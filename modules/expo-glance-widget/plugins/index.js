"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key3 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key3) && key3 !== except)
        __defProp(to, key3, { get: () => from[key3], enumerable: !(desc = __getOwnPropDesc(from, key3)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@expo/config-plugins/build/utils/XML.js
var require_XML = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/XML.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._processAndroidXML = _processAndroidXML;
    exports2.escapeAndroidString = escapeAndroidString;
    exports2.format = format;
    exports2.parseXMLAsync = parseXMLAsync;
    exports2.readXMLAsync = readXMLAsync;
    exports2.unescapeAndroidString = unescapeAndroidString;
    exports2.writeXMLAsync = writeXMLAsync;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _os() {
      const data = require("os");
      _os = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _xml2js() {
      const data = require("xml2js");
      _xml2js = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    async function writeXMLAsync(options) {
      const xml = format(options.xml);
      await _fs().default.promises.mkdir(_path().default.dirname(options.path), {
        recursive: true
      });
      await _fs().default.promises.writeFile(options.path, xml);
    }
    async function readXMLAsync(options) {
      let contents = "";
      try {
        contents = await _fs().default.promises.readFile(options.path, {
          encoding: "utf8",
          flag: "r"
        });
      } catch {
      }
      const parser = new (_xml2js()).Parser();
      const manifest = await parser.parseStringPromise(contents || options.fallback || "");
      return _processAndroidXML(manifest);
    }
    function _processAndroidXML(manifest) {
      if (Array.isArray(manifest?.resources?.string)) {
        for (const string of manifest?.resources?.string) {
          if (string.$.translatable === "false" || string.$.translatable === false) {
            continue;
          }
          if (!("_" in string)) {
            throw new Error(`Empty string resource not supported: ${JSON.stringify(string)}`);
          }
          string._ = unescapeAndroidString(string._);
        }
      }
      return manifest;
    }
    async function parseXMLAsync(contents) {
      const xml = await new (_xml2js()).Parser().parseStringPromise(contents);
      return xml;
    }
    var stringTimesN = (n, char) => Array(n + 1).join(char);
    function format(manifest, {
      indentLevel = 2,
      newline = _os().EOL
    } = {}) {
      let xmlInput;
      if (typeof manifest === "string") {
        xmlInput = manifest;
      } else if (manifest.toString) {
        const builder = new (_xml2js()).Builder({
          headless: true
        });
        if (Array.isArray(manifest?.resources?.string)) {
          for (const string of manifest?.resources?.string) {
            if (string.$.translatable === "false" || string.$.translatable === false) {
              continue;
            }
            string._ = escapeAndroidString(string._);
          }
        }
        xmlInput = builder.buildObject(manifest);
        return xmlInput;
      } else {
        throw new Error(`Invalid XML value passed in: ${manifest}`);
      }
      const indentString = stringTimesN(indentLevel, " ");
      let formatted = "";
      const regex = /(>)(<)(\/*)/g;
      const xml = xmlInput.replace(regex, `$1${newline}$2$3`);
      let pad = 0;
      xml.split(/\r?\n/).map((line2) => line2.trim()).forEach((line2) => {
        let indent = 0;
        if (line2.match(/.+<\/\w[^>]*>$/)) {
          indent = 0;
        } else if (line2.match(/^<\/\w/)) {
          if (pad !== 0) {
            pad -= 1;
          }
        } else if (line2.match(/^<\w([^>]*[^/])?>.*$/)) {
          indent = 1;
        } else {
          indent = 0;
        }
        const padding = stringTimesN(pad, indentString);
        formatted += padding + line2 + newline;
        pad += indent;
      });
      return formatted.trim();
    }
    function escapeAndroidString(value) {
      value = value.replace(/[\n\r\t'"@]/g, (m) => {
        switch (m) {
          case '"':
          case "'":
          case "@":
            return "\\" + m;
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "	":
            return "\\t";
          default:
            throw new Error(`Cannot escape unhandled XML character: ${m}`);
        }
      });
      if (value.match(/(^\s|\s$)/)) {
        value = '"' + value + '"';
      }
      return value;
    }
    function unescapeAndroidString(value) {
      return value.replace(/\\(.)/g, "$1");
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Manifest.js
var require_Manifest = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Manifest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addMetaDataItemToMainApplication = addMetaDataItemToMainApplication;
    exports2.addUsesLibraryItemToMainApplication = addUsesLibraryItemToMainApplication;
    exports2.ensureToolsAvailable = ensureToolsAvailable;
    exports2.findMetaDataItem = findMetaDataItem;
    exports2.findUsesLibraryItem = findUsesLibraryItem;
    exports2.getMainActivity = getMainActivity;
    exports2.getMainActivityOrThrow = getMainActivityOrThrow;
    exports2.getMainApplication = getMainApplication;
    exports2.getMainApplicationMetaDataValue = getMainApplicationMetaDataValue;
    exports2.getMainApplicationOrThrow = getMainApplicationOrThrow;
    exports2.getRunnableActivity = getRunnableActivity;
    exports2.prefixAndroidKeys = prefixAndroidKeys;
    exports2.readAndroidManifestAsync = readAndroidManifestAsync;
    exports2.removeMetaDataItemFromMainApplication = removeMetaDataItemFromMainApplication;
    exports2.removeUsesLibraryItemFromMainApplication = removeUsesLibraryItemFromMainApplication;
    exports2.writeAndroidManifestAsync = writeAndroidManifestAsync;
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function XML() {
      const data = _interopRequireWildcard(require_XML());
      XML = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    async function writeAndroidManifestAsync(manifestPath, androidManifest) {
      const manifestXml = XML().format(androidManifest);
      await _fs().default.promises.mkdir(_path().default.dirname(manifestPath), {
        recursive: true
      });
      await _fs().default.promises.writeFile(manifestPath, manifestXml);
    }
    async function readAndroidManifestAsync(manifestPath) {
      const xml = await XML().readXMLAsync({
        path: manifestPath
      });
      if (!isManifest(xml)) {
        throw new Error("Invalid manifest found at: " + manifestPath);
      }
      return xml;
    }
    function isManifest(xml) {
      return !!xml.manifest;
    }
    function getMainApplication(androidManifest) {
      return androidManifest?.manifest?.application?.filter((e) => e?.$?.["android:name"].endsWith(".MainApplication"))[0] ?? null;
    }
    function getMainApplicationOrThrow(androidManifest) {
      const mainApplication = getMainApplication(androidManifest);
      (0, _assert().default)(mainApplication, "AndroidManifest.xml is missing the required MainApplication element");
      return mainApplication;
    }
    function getMainActivityOrThrow(androidManifest) {
      const mainActivity = getMainActivity(androidManifest);
      (0, _assert().default)(mainActivity, "AndroidManifest.xml is missing the required MainActivity element");
      return mainActivity;
    }
    function getRunnableActivity(androidManifest) {
      const enabledActivities = androidManifest?.manifest?.application?.[0]?.activity?.filter?.((e) => e.$["android:enabled"] !== "false" && e.$["android:enabled"] !== false);
      if (!enabledActivities) {
        return null;
      }
      for (const activity of enabledActivities) {
        if (Array.isArray(activity["intent-filter"])) {
          for (const intentFilter of activity["intent-filter"]) {
            if (intentFilter.action?.find((action) => action.$["android:name"] === "android.intent.action.MAIN") && intentFilter.category?.find((category) => category.$["android:name"] === "android.intent.category.LAUNCHER")) {
              return activity;
            }
          }
        }
      }
      return null;
    }
    function getMainActivity(androidManifest) {
      const mainActivity = androidManifest?.manifest?.application?.[0]?.activity?.filter?.((e) => e.$["android:name"] === ".MainActivity");
      return mainActivity?.[0] ?? null;
    }
    function addMetaDataItemToMainApplication(mainApplication, itemName, itemValue, itemType = "value") {
      let existingMetaDataItem;
      const newItem = {
        $: prefixAndroidKeys({
          name: itemName,
          [itemType]: itemValue
        })
      };
      if (mainApplication["meta-data"]) {
        existingMetaDataItem = mainApplication["meta-data"].filter((e) => e.$["android:name"] === itemName);
        if (existingMetaDataItem.length) {
          existingMetaDataItem[0].$[`android:${itemType}`] = itemValue;
        } else {
          mainApplication["meta-data"].push(newItem);
        }
      } else {
        mainApplication["meta-data"] = [newItem];
      }
      return mainApplication;
    }
    function removeMetaDataItemFromMainApplication(mainApplication, itemName) {
      const index = findMetaDataItem(mainApplication, itemName);
      if (mainApplication?.["meta-data"] && index > -1) {
        mainApplication["meta-data"].splice(index, 1);
      }
      return mainApplication;
    }
    function findApplicationSubItem(mainApplication, category, itemName) {
      const parent = mainApplication[category];
      if (Array.isArray(parent)) {
        const index = parent.findIndex((e) => e.$["android:name"] === itemName);
        return index;
      }
      return -1;
    }
    function findMetaDataItem(mainApplication, itemName) {
      return findApplicationSubItem(mainApplication, "meta-data", itemName);
    }
    function findUsesLibraryItem(mainApplication, itemName) {
      return findApplicationSubItem(mainApplication, "uses-library", itemName);
    }
    function getMainApplicationMetaDataValue(androidManifest, name) {
      const mainApplication = getMainApplication(androidManifest);
      if (mainApplication?.hasOwnProperty("meta-data")) {
        const item = mainApplication?.["meta-data"]?.find((e) => e.$["android:name"] === name);
        return item?.$["android:value"] ?? null;
      }
      return null;
    }
    function addUsesLibraryItemToMainApplication(mainApplication, item) {
      let existingMetaDataItem;
      const newItem = {
        $: prefixAndroidKeys(item)
      };
      if (mainApplication["uses-library"]) {
        existingMetaDataItem = mainApplication["uses-library"].filter((e) => e.$["android:name"] === item.name);
        if (existingMetaDataItem.length) {
          existingMetaDataItem[0].$ = newItem.$;
        } else {
          mainApplication["uses-library"].push(newItem);
        }
      } else {
        mainApplication["uses-library"] = [newItem];
      }
      return mainApplication;
    }
    function removeUsesLibraryItemFromMainApplication(mainApplication, itemName) {
      const index = findUsesLibraryItem(mainApplication, itemName);
      if (mainApplication?.["uses-library"] && index > -1) {
        mainApplication["uses-library"].splice(index, 1);
      }
      return mainApplication;
    }
    function prefixAndroidKeys(head) {
      return Object.entries(head).reduce((prev, [key3, curr]) => ({
        ...prev,
        [`android:${key3}`]: curr
      }), {});
    }
    function ensureToolsAvailable(manifest) {
      return ensureManifestHasNamespace(manifest, {
        namespace: "xmlns:tools",
        url: "http://schemas.android.com/tools"
      });
    }
    function ensureManifestHasNamespace(manifest, {
      namespace,
      url
    }) {
      if (manifest?.manifest?.$?.[namespace]) {
        return manifest;
      }
      manifest.manifest.$[namespace] = url;
      return manifest;
    }
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/ansi-styles/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/ansi-styles/node_modules/color-convert/conversions.js"(exports2, module2) {
    "use strict";
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key3 of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key3]] = key3;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c2) {
        return (v - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c2 = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c2 * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i2 = 0; i2 < 3; i2++) {
        t3 = h + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i2 = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i2;
      if ((i2 & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i2) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c2 = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c2 * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c2 = Math.sqrt(a * a + b * b);
      return [l, c2, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c2 = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c2 * Math.cos(hr);
      const b = c2 * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c2 = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c2 < 1) {
        f = (l - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c2 = s * v;
      let f = 0;
      if (c2 < 1) {
        f = (v - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c2 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c2) * g;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c2 + g * (1 - c2);
      let f = 0;
      if (v > 0) {
        f = c2 / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c2) + 0.5 * c2;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c2 / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c2 / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c2 + g * (1 - c2);
      return [hcg[0], (v - c2) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c2 = v - w;
      let g = 0;
      if (c2 < 1) {
        g = (v - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/ansi-styles/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/ansi-styles/node_modules/color-convert/route.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        graph[models[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
          const adjacent = adjacents[i2];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path11 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path11.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path11;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        const toModel = models[i2];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/ansi-styles/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/ansi-styles/node_modules/color-convert/index.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i2 = 0; i2 < len; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c2) {
      const u = c2[0] === "u";
      const bracket = c2[1] === "{";
      if (u && !bracket && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
        return String.fromCharCode(parseInt(c2.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c2.slice(2, -1), 16));
      }
      return ESCAPES.get(c2) || c2;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i2 = 1; i2 < firstString.length; i2++) {
        parts.push(
          String(arguments_[i2 - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i2])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// node_modules/getenv/index.js
var require_getenv = __commonJS({
  "node_modules/getenv/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var fallbacksDisabled = false;
    var throwError = true;
    function _value(varName, fallback) {
      const value = process.env[varName];
      if (value === void 0) {
        if (fallback === void 0 && !throwError) {
          return value;
        }
        if (fallback === void 0) {
          throw new Error(
            "GetEnv.Nonexistent: " + varName + " does not exist and no fallback value provided."
          );
        }
        if (fallbacksDisabled) {
          throw new Error(
            "GetEnv.DisabledFallbacks: " + varName + " relying on fallback when fallbacks have been disabled"
          );
        }
        return "" + fallback;
      }
      return value;
    }
    var convert = {
      string: function(value) {
        return "" + value;
      },
      int: function(value) {
        const isInt = value.match(/^-?\d+$/);
        if (!isInt) {
          throw new Error("GetEnv.NoInteger: " + value + " is not an integer.");
        }
        return +value;
      },
      float: function(value) {
        const isInfinity = +value === Infinity || +value === -Infinity;
        if (isInfinity) {
          throw new Error("GetEnv.Infinity: " + value + " is set to +/-Infinity.");
        }
        const isFloat = !(isNaN(value) || value === "");
        if (!isFloat) {
          throw new Error("GetEnv.NoFloat: " + value + " is not a number.");
        }
        return +value;
      },
      bool: function(value) {
        const isBool = (value || "").toLowerCase() === "true" || (value || "").toLowerCase() === "false";
        if (!isBool) {
          throw new Error("GetEnv.NoBoolean: " + value + " is not a boolean.");
        }
        return (value || "").toLowerCase() === "true";
      },
      boolish: function(value) {
        try {
          return convert.bool(value);
        } catch (err) {
          const isBool = value === "1" || value === "0";
          if (!isBool) {
            throw new Error("GetEnv.NoBoolean: " + value + " is not a boolean.");
          }
          return value === "1";
        }
      },
      url: url.parse
    };
    function converter(type) {
      return function(varName, fallback) {
        if (typeof varName == "string") {
          const value = _value(varName, fallback);
          return convert[type](value);
        } else {
          return getenv.multi(varName);
        }
      };
    }
    var getenv = converter("string");
    Object.keys(convert).forEach(function(type) {
      getenv[type] = converter(type);
    });
    getenv.array = function array(varName, type, fallback, separator) {
      type = type || "string";
      separator = separator || /\s*,\s*/;
      if (Object.keys(convert).indexOf(type) === -1) {
        throw new Error("GetEnv.ArrayUndefinedType: Unknown array type " + type);
      }
      const value = _value(varName, fallback);
      return value.split(separator).map(convert[type]);
    };
    getenv.multi = function multi(spec) {
      const result = {};
      for (let key3 in spec) {
        const value = spec[key3];
        if (Array.isArray(value)) {
          switch (value.length) {
            case 1:
            // no default value
            case 2:
              result[key3] = getenv(value[0], value[1]);
              break;
            case 3:
              result[key3] = getenv[value[2]](value[0], value[1]);
              break;
            default:
              throw "getenv.multi(): invalid spec";
              break;
          }
        } else {
          result[key3] = getenv(value);
        }
      }
      return result;
    };
    getenv.disableFallbacks = function() {
      fallbacksDisabled = true;
    };
    getenv.enableFallbacks = function() {
      fallbacksDisabled = false;
    };
    getenv.disableErrors = function() {
      throwError = false;
    };
    getenv.enableErrors = function() {
      throwError = true;
    };
    module2.exports = getenv;
  }
});

// node_modules/@expo/config-plugins/build/utils/errors.js
var require_errors = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UnexpectedError = exports2.PluginError = void 0;
    var UnexpectedError = class extends Error {
      name = "UnexpectedError";
      constructor(message) {
        super(`${message}
Report this issue: https://github.com/expo/expo/issues`);
      }
    };
    exports2.UnexpectedError = UnexpectedError;
    var PluginError = class extends Error {
      name = "PluginError";
      isPluginError = true;
      constructor(message, code, cause) {
        super(cause ? `${message}
\u2514\u2500 Cause: ${cause.name}: ${cause.message}` : message);
        this.code = code;
        this.cause = cause;
      }
    };
    exports2.PluginError = PluginError;
  }
});

// node_modules/@expo/config-plugins/build/plugins/withMod.js
var require_withMod = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/withMod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.withBaseMod = withBaseMod;
    exports2.withMod = withMod;
    function _chalk() {
      const data = _interopRequireDefault(require_source());
      _chalk = function() {
        return data;
      };
      return data;
    }
    function _getenv() {
      const data = require_getenv();
      _getenv = function() {
        return data;
      };
      return data;
    }
    function _errors() {
      const data = require_errors();
      _errors = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var EXPO_DEBUG = (0, _getenv().boolish)("EXPO_DEBUG", false);
    function withBaseMod(config, {
      platform,
      mod,
      action,
      skipEmptyMod,
      isProvider,
      isIntrospective,
      saveToInternal
    }) {
      if (!config.mods) {
        config.mods = {};
      }
      if (!config.mods[platform]) {
        config.mods[platform] = {};
      }
      let interceptedMod = config.mods[platform][mod];
      if (!interceptedMod) {
        if (skipEmptyMod) {
          return config;
        }
        const noopMod = (config2) => config2;
        interceptedMod = noopMod;
      }
      let debugTrace = "";
      const isDebug = config._internal?.isDebug ?? EXPO_DEBUG;
      if (isDebug) {
        const stack2 = new Error().stack;
        debugTrace = getDebugPluginStackFromStackTrace(stack2);
        const modStack = _chalk().default.bold(`${platform}.${mod}`);
        debugTrace = `${modStack}: ${debugTrace}`;
      }
      if (interceptedMod.isProvider) {
        if (isProvider) {
          throw new (_errors()).PluginError(`Cannot set provider mod for "${platform}.${mod}" because another is already being used.`, "CONFLICTING_PROVIDER");
        } else {
          throw new (_errors()).PluginError(`Cannot add mod to "${platform}.${mod}" because the provider has already been added. Provider must be the last mod added.`, "INVALID_MOD_ORDER");
        }
      }
      async function interceptingMod({
        modRequest,
        ...config2
      }) {
        if (isDebug) {
          console.log(debugTrace);
        }
        const results = await action({
          ...config2,
          modRequest: {
            ...modRequest,
            nextMod: interceptedMod
          }
        });
        if (saveToInternal) {
          saveToInternalObject(results, platform, mod, results.modResults);
        }
        return results;
      }
      interceptingMod.isProvider = isProvider;
      if (isIntrospective) {
        interceptingMod.isIntrospective = isIntrospective;
      }
      config.mods[platform][mod] = interceptingMod;
      return config;
    }
    function saveToInternalObject(config, platformName, modName, results) {
      if (!config._internal) config._internal = {};
      if (!config._internal.modResults) config._internal.modResults = {};
      if (!config._internal.modResults[platformName]) config._internal.modResults[platformName] = {};
      config._internal.modResults[platformName][modName] = results;
    }
    function getDebugPluginStackFromStackTrace(stacktrace) {
      if (!stacktrace) {
        return "";
      }
      const treeStackLines = [];
      for (const line2 of stacktrace.split("\n")) {
        const [first, second] = line2.trim().split(" ");
        if (first === "at") {
          treeStackLines.push(second);
        }
      }
      const plugins = treeStackLines.map((first) => {
        return first?.match(/^(\bwith[A-Z].*?\b)/)?.[1]?.trim() ?? first?.match(/\.(\bwith[A-Z].*?\b)/)?.[1]?.trim() ?? null;
      }).filter(Boolean).filter((plugin) => {
        return !["withMod", "withBaseMod", "withExtendedMod"].includes(plugin);
      });
      const commonPlugins = ["withPlugins", "withRunOnce", "withStaticPlugin"];
      return plugins.reverse().map((pluginName, index) => {
        if (pluginName.includes("BaseMod")) {
          pluginName = _chalk().default.bold(pluginName);
        }
        if (pluginName.toLowerCase().includes("dangerous")) {
          pluginName = _chalk().default.red(pluginName);
        }
        if (index === 0) {
          return _chalk().default.blue(pluginName);
        } else if (commonPlugins.includes(pluginName)) {
          return _chalk().default.dim(pluginName);
        }
        return pluginName;
      }).join(" \u279C ");
    }
    function withMod(config, {
      platform,
      mod,
      action
    }) {
      return withBaseMod(config, {
        platform,
        mod,
        isProvider: false,
        async action({
          modRequest: {
            nextMod,
            ...modRequest
          },
          modResults,
          ...config2
        }) {
          const results = await action({
            modRequest,
            modResults,
            ...config2
          });
          return nextMod(results);
        }
      });
    }
  }
});

// node_modules/@expo/config-plugins/build/plugins/android-plugins.js
var require_android_plugins = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/android-plugins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createAndroidManifestPlugin = createAndroidManifestPlugin;
    exports2.createStringsXmlPlugin = createStringsXmlPlugin;
    exports2.withStringsXml = exports2.withSettingsGradle = exports2.withProjectBuildGradle = exports2.withMainApplication = exports2.withMainActivity = exports2.withGradleProperties = exports2.withAppBuildGradle = exports2.withAndroidStyles = exports2.withAndroidManifest = exports2.withAndroidColorsNight = exports2.withAndroidColors = void 0;
    function _withMod() {
      const data = require_withMod();
      _withMod = function() {
        return data;
      };
      return data;
    }
    function createAndroidManifestPlugin(action, name) {
      const withUnknown = (config) => withAndroidManifest2(config, async (config2) => {
        config2.modResults = await action(config2, config2.modResults);
        return config2;
      });
      if (name) {
        Object.defineProperty(withUnknown, "name", {
          value: name
        });
      }
      return withUnknown;
    }
    function createStringsXmlPlugin(action, name) {
      const withUnknown = (config) => withStringsXml(config, async (config2) => {
        config2.modResults = await action(config2, config2.modResults);
        return config2;
      });
      if (name) {
        Object.defineProperty(withUnknown, "name", {
          value: name
        });
      }
      return withUnknown;
    }
    var withAndroidManifest2 = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "manifest",
        action
      });
    };
    exports2.withAndroidManifest = withAndroidManifest2;
    var withStringsXml = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "strings",
        action
      });
    };
    exports2.withStringsXml = withStringsXml;
    var withAndroidColors = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "colors",
        action
      });
    };
    exports2.withAndroidColors = withAndroidColors;
    var withAndroidColorsNight = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "colorsNight",
        action
      });
    };
    exports2.withAndroidColorsNight = withAndroidColorsNight;
    var withAndroidStyles = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "styles",
        action
      });
    };
    exports2.withAndroidStyles = withAndroidStyles;
    var withMainActivity = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "mainActivity",
        action
      });
    };
    exports2.withMainActivity = withMainActivity;
    var withMainApplication = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "mainApplication",
        action
      });
    };
    exports2.withMainApplication = withMainApplication;
    var withProjectBuildGradle2 = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "projectBuildGradle",
        action
      });
    };
    exports2.withProjectBuildGradle = withProjectBuildGradle2;
    var withAppBuildGradle2 = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "appBuildGradle",
        action
      });
    };
    exports2.withAppBuildGradle = withAppBuildGradle2;
    var withSettingsGradle = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "settingsGradle",
        action
      });
    };
    exports2.withSettingsGradle = withSettingsGradle;
    var withGradleProperties = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "android",
        mod: "gradleProperties",
        action
      });
    };
    exports2.withGradleProperties = withGradleProperties;
  }
});

// node_modules/@expo/config-plugins/build/android/AllowBackup.js
var require_AllowBackup = __commonJS({
  "node_modules/@expo/config-plugins/build/android/AllowBackup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAllowBackup = getAllowBackup;
    exports2.getAllowBackupFromManifest = getAllowBackupFromManifest;
    exports2.setAllowBackup = setAllowBackup;
    exports2.withAllowBackup = void 0;
    function _Manifest() {
      const data = require_Manifest();
      _Manifest = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    var withAllowBackup = exports2.withAllowBackup = (0, _androidPlugins().createAndroidManifestPlugin)(setAllowBackup, "withAllowBackup");
    function getAllowBackup(config) {
      return config.android?.allowBackup ?? true;
    }
    function setAllowBackup(config, androidManifest) {
      const allowBackup = getAllowBackup(config);
      const mainApplication = (0, _Manifest().getMainApplication)(androidManifest);
      if (mainApplication?.$) {
        mainApplication.$["android:allowBackup"] = String(allowBackup);
      }
      return androidManifest;
    }
    function getAllowBackupFromManifest(androidManifest) {
      const mainApplication = (0, _Manifest().getMainApplication)(androidManifest);
      if (mainApplication?.$) {
        return String(mainApplication.$["android:allowBackup"]) === "true";
      }
      return null;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/BuildProperties.js
var require_BuildProperties = __commonJS({
  "node_modules/@expo/config-plugins/build/android/BuildProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createBuildGradlePropsConfigPlugin = createBuildGradlePropsConfigPlugin;
    exports2.updateAndroidBuildPropertiesFromConfig = updateAndroidBuildPropertiesFromConfig;
    exports2.updateAndroidBuildProperty = updateAndroidBuildProperty;
    exports2.withNewArchEnabledGradleProps = exports2.withJsEngineGradleProps = void 0;
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    function createBuildGradlePropsConfigPlugin(configToPropertyRules, name) {
      const withUnknown = (config, sourceConfig) => (0, _androidPlugins().withGradleProperties)(config, (config2) => {
        config2.modResults = updateAndroidBuildPropertiesFromConfig(sourceConfig ?? config2, config2.modResults, configToPropertyRules);
        return config2;
      });
      if (name) {
        Object.defineProperty(withUnknown, "name", {
          value: name
        });
      }
      return withUnknown;
    }
    var withJsEngineGradleProps = exports2.withJsEngineGradleProps = createBuildGradlePropsConfigPlugin([{
      propName: "hermesEnabled",
      propValueGetter: (config) => ((config.android?.jsEngine ?? config.jsEngine ?? "hermes") === "hermes").toString()
    }], "withJsEngineGradleProps");
    var withNewArchEnabledGradleProps = exports2.withNewArchEnabledGradleProps = createBuildGradlePropsConfigPlugin([{
      propName: "newArchEnabled",
      propValueGetter: (config) => (config.android?.newArchEnabled ?? config.newArchEnabled)?.toString()
    }], "withNewArchEnabledGradleProps");
    function updateAndroidBuildPropertiesFromConfig(config, gradleProperties, configToPropertyRules) {
      for (const configToProperty of configToPropertyRules) {
        const value = configToProperty.propValueGetter(config);
        updateAndroidBuildProperty(gradleProperties, configToProperty.propName, value);
      }
      return gradleProperties;
    }
    function updateAndroidBuildProperty(gradleProperties, name, value, options) {
      const oldPropIndex = gradleProperties.findIndex((prop) => prop.type === "property" && prop.key === name);
      const oldProp = oldPropIndex >= 0 ? gradleProperties[oldPropIndex] : null;
      if (value) {
        const newProp = {
          type: "property",
          key: name,
          value
        };
        if (oldProp && oldProp.type === "property") {
          try {
            const prevValue = JSON.parse(oldProp.value);
            const newValue = JSON.parse(value);
            if (Array.isArray(prevValue) && Array.isArray(newValue)) {
              const prevArrayWithStringifiedValues = prevValue.map((v) => JSON.stringify(v));
              const newArrayWithStringifiedValues = newValue.map((v) => JSON.stringify(v));
              const mergedValues = [.../* @__PURE__ */ new Set([...prevArrayWithStringifiedValues, ...newArrayWithStringifiedValues])].map((v) => JSON.parse(v));
              oldProp.value = JSON.stringify(mergedValues);
              return gradleProperties;
            }
          } catch {
          }
          oldProp.value = value;
          return gradleProperties;
        }
        gradleProperties.push(newProp);
        return gradleProperties;
      }
      if (options?.removePropWhenValueIsNull && oldPropIndex >= 0) {
        gradleProperties.splice(oldPropIndex, 1);
        return gradleProperties;
      }
      return gradleProperties;
    }
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i2 = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
          if (i2 == ai) {
            begs.push(i2);
            ai = str.indexOf(a, i2 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i2 + 1);
          }
          i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    "use strict";
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i2, y) {
      return i2 <= y;
    }
    function gte(i2, y) {
      return i2 >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,(?!,).*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i2 = x; test(i2, y); i2 += incr) {
            var c2;
            if (isAlphaSequence) {
              c2 = String.fromCharCode(i2);
              if (c2 === "\\")
                c2 = "";
            } else {
              c2 = String(i2);
              if (pad) {
                var need = width - c2.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i2 < 0)
                    c2 = "-" + z + c2.slice(1);
                  else
                    c2 = z + c2;
                }
              }
            }
            N.push(c2);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS({
  "node_modules/glob/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertValidPattern = void 0;
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    exports2.assertValidPattern = assertValidPattern;
  }
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS({
  "node_modules/glob/node_modules/minimatch/dist/commonjs/brace-expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseClass = void 0;
    var posixClasses = {
      "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
      "[:alpha:]": ["\\p{L}\\p{Nl}", true],
      "[:ascii:]": ["\\x00-\\x7f", false],
      "[:blank:]": ["\\p{Zs}\\t", true],
      "[:cntrl:]": ["\\p{Cc}", true],
      "[:digit:]": ["\\p{Nd}", true],
      "[:graph:]": ["\\p{Z}\\p{C}", true, true],
      "[:lower:]": ["\\p{Ll}", true],
      "[:print:]": ["\\p{C}", true],
      "[:punct:]": ["\\p{P}", true],
      "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
      "[:upper:]": ["\\p{Lu}", true],
      "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
      "[:xdigit:]": ["A-Fa-f0-9", false]
    };
    var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
    var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var rangesToString = (ranges) => ranges.join("");
    var parseClass = (glob, position) => {
      const pos2 = position;
      if (glob.charAt(pos2) !== "[") {
        throw new Error("not in a brace expression");
      }
      const ranges = [];
      const negs = [];
      let i2 = pos2 + 1;
      let sawStart = false;
      let uflag = false;
      let escaping = false;
      let negate = false;
      let endPos = pos2;
      let rangeStart = "";
      WHILE: while (i2 < glob.length) {
        const c2 = glob.charAt(i2);
        if ((c2 === "!" || c2 === "^") && i2 === pos2 + 1) {
          negate = true;
          i2++;
          continue;
        }
        if (c2 === "]" && sawStart && !escaping) {
          endPos = i2 + 1;
          break;
        }
        sawStart = true;
        if (c2 === "\\") {
          if (!escaping) {
            escaping = true;
            i2++;
            continue;
          }
        }
        if (c2 === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i2)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos2, true];
              }
              i2 += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c2 > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c2));
          } else if (c2 === rangeStart) {
            ranges.push(braceEscape(c2));
          }
          rangeStart = "";
          i2++;
          continue;
        }
        if (glob.startsWith("-]", i2 + 1)) {
          ranges.push(braceEscape(c2 + "-"));
          i2 += 2;
          continue;
        }
        if (glob.startsWith("-", i2 + 1)) {
          rangeStart = c2;
          i2 += 2;
          continue;
        }
        ranges.push(braceEscape(c2));
        i2++;
      }
      if (endPos < i2) {
        return ["", false, 0, false];
      }
      if (!ranges.length && !negs.length) {
        return ["$.", false, glob.length - pos2, true];
      }
      if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos2, false];
      }
      const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
      const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
      const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
      return [comb, uflag, endPos - pos2, true];
    };
    exports2.parseClass = parseClass;
  }
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS({
  "node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = void 0;
    var unescape2 = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
    };
    exports2.unescape = unescape2;
  }
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS({
  "node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AST = void 0;
    var brace_expressions_js_1 = require_brace_expressions();
    var unescape_js_1 = require_unescape();
    var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
    var isExtglobType = (c2) => types.has(c2);
    var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
    var startNoDot = "(?!\\.)";
    var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
    var justDots = /* @__PURE__ */ new Set(["..", "."]);
    var reSpecials = new Set("().*{}+?[]^$\\!");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var qmark = "[^/]";
    var star = qmark + "*?";
    var starNoEmpty = qmark + "+?";
    var AST = class _AST {
      type;
      #root;
      #hasMagic;
      #uflag = false;
      #parts = [];
      #parent;
      #parentIndex;
      #negs;
      #filledNegs = false;
      #options;
      #toString;
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      #emptyExt = false;
      constructor(type, parent, options = {}) {
        this.type = type;
        if (type)
          this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === "!" && !this.#root.#filledNegs)
          this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
      }
      get hasMagic() {
        if (this.#hasMagic !== void 0)
          return this.#hasMagic;
        for (const p of this.#parts) {
          if (typeof p === "string")
            continue;
          if (p.type || p.hasMagic)
            return this.#hasMagic = true;
        }
        return this.#hasMagic;
      }
      // reconstructs the pattern
      toString() {
        if (this.#toString !== void 0)
          return this.#toString;
        if (!this.type) {
          return this.#toString = this.#parts.map((p) => String(p)).join("");
        } else {
          return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
        }
      }
      #fillNegs() {
        if (this !== this.#root)
          throw new Error("should only call on root");
        if (this.#filledNegs)
          return this;
        this.toString();
        this.#filledNegs = true;
        let n;
        while (n = this.#negs.pop()) {
          if (n.type !== "!")
            continue;
          let p = n;
          let pp = p.#parent;
          while (pp) {
            for (let i2 = p.#parentIndex + 1; !pp.type && i2 < pp.#parts.length; i2++) {
              for (const part of n.#parts) {
                if (typeof part === "string") {
                  throw new Error("string part in extglob AST??");
                }
                part.copyIn(pp.#parts[i2]);
              }
            }
            p = pp;
            pp = p.#parent;
          }
        }
        return this;
      }
      push(...parts) {
        for (const p of parts) {
          if (p === "")
            continue;
          if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
            throw new Error("invalid part: " + p);
          }
          this.#parts.push(p);
        }
      }
      toJSON() {
        const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
        if (this.isStart() && !this.type)
          ret.unshift([]);
        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
          ret.push({});
        }
        return ret;
      }
      isStart() {
        if (this.#root === this)
          return true;
        if (!this.#parent?.isStart())
          return false;
        if (this.#parentIndex === 0)
          return true;
        const p = this.#parent;
        for (let i2 = 0; i2 < this.#parentIndex; i2++) {
          const pp = p.#parts[i2];
          if (!(pp instanceof _AST && pp.type === "!")) {
            return false;
          }
        }
        return true;
      }
      isEnd() {
        if (this.#root === this)
          return true;
        if (this.#parent?.type === "!")
          return true;
        if (!this.#parent?.isEnd())
          return false;
        if (!this.type)
          return this.#parent?.isEnd();
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        return this.#parentIndex === pl - 1;
      }
      copyIn(part) {
        if (typeof part === "string")
          this.push(part);
        else
          this.push(part.clone(this));
      }
      clone(parent) {
        const c2 = new _AST(this.type, parent);
        for (const p of this.#parts) {
          c2.copyIn(p);
        }
        return c2;
      }
      static #parseAST(str, ast, pos2, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
          let i3 = pos2;
          let acc2 = "";
          while (i3 < str.length) {
            const c2 = str.charAt(i3++);
            if (escaping || c2 === "\\") {
              escaping = !escaping;
              acc2 += c2;
              continue;
            }
            if (inBrace) {
              if (i3 === braceStart + 1) {
                if (c2 === "^" || c2 === "!") {
                  braceNeg = true;
                }
              } else if (c2 === "]" && !(i3 === braceStart + 2 && braceNeg)) {
                inBrace = false;
              }
              acc2 += c2;
              continue;
            } else if (c2 === "[") {
              inBrace = true;
              braceStart = i3;
              braceNeg = false;
              acc2 += c2;
              continue;
            }
            if (!opt.noext && isExtglobType(c2) && str.charAt(i3) === "(") {
              ast.push(acc2);
              acc2 = "";
              const ext = new _AST(c2, ast);
              i3 = _AST.#parseAST(str, ext, i3, opt);
              ast.push(ext);
              continue;
            }
            acc2 += c2;
          }
          ast.push(acc2);
          return i3;
        }
        let i2 = pos2 + 1;
        let part = new _AST(null, ast);
        const parts = [];
        let acc = "";
        while (i2 < str.length) {
          const c2 = str.charAt(i2++);
          if (escaping || c2 === "\\") {
            escaping = !escaping;
            acc += c2;
            continue;
          }
          if (inBrace) {
            if (i2 === braceStart + 1) {
              if (c2 === "^" || c2 === "!") {
                braceNeg = true;
              }
            } else if (c2 === "]" && !(i2 === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc += c2;
            continue;
          } else if (c2 === "[") {
            inBrace = true;
            braceStart = i2;
            braceNeg = false;
            acc += c2;
            continue;
          }
          if (isExtglobType(c2) && str.charAt(i2) === "(") {
            part.push(acc);
            acc = "";
            const ext = new _AST(c2, part);
            part.push(ext);
            i2 = _AST.#parseAST(str, ext, i2, opt);
            continue;
          }
          if (c2 === "|") {
            part.push(acc);
            acc = "";
            parts.push(part);
            part = new _AST(null, ast);
            continue;
          }
          if (c2 === ")") {
            if (acc === "" && ast.#parts.length === 0) {
              ast.#emptyExt = true;
            }
            part.push(acc);
            acc = "";
            ast.push(...parts, part);
            return i2;
          }
          acc += c2;
        }
        ast.type = null;
        ast.#hasMagic = void 0;
        ast.#parts = [str.substring(pos2 - 1)];
        return i2;
      }
      static fromGlob(pattern, options = {}) {
        const ast = new _AST(null, void 0, options);
        _AST.#parseAST(pattern, ast, 0, options);
        return ast;
      }
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      toMMPattern() {
        if (this !== this.#root)
          return this.#root.toMMPattern();
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
        if (!anyMagic) {
          return body;
        }
        const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re}$`, flags), {
          _src: re,
          _glob: glob
        });
      }
      get options() {
        return this.#options;
      }
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
          this.#fillNegs();
        if (!this.type) {
          const noEmpty = this.isStart() && this.isEnd();
          const src = this.#parts.map((p) => {
            const [re, _, hasMagic, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
            this.#hasMagic = this.#hasMagic || hasMagic;
            this.#uflag = this.#uflag || uflag;
            return re;
          }).join("");
          let start2 = "";
          if (this.isStart()) {
            if (typeof this.#parts[0] === "string") {
              const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
              if (!dotTravAllowed) {
                const aps = addPatternStart;
                const needNoTrav = (
                  // dots are allowed, and the pattern starts with [ or .
                  dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                  src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                  src.startsWith("\\.\\.") && aps.has(src.charAt(4))
                );
                const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
              }
            }
          }
          let end = "";
          if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
            end = "(?:$|\\/)";
          }
          const final2 = start2 + src + end;
          return [
            final2,
            (0, unescape_js_1.unescape)(src),
            this.#hasMagic = !!this.#hasMagic,
            this.#uflag
          ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
          const s = this.toString();
          this.#parts = [s];
          this.type = null;
          this.#hasMagic = void 0;
          return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
          bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
          body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && this.#emptyExt) {
          final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
          const close = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
          final = start + body + close;
        }
        return [
          final,
          (0, unescape_js_1.unescape)(body),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      #partsToRegExp(dot) {
        return this.#parts.map((p) => {
          if (typeof p === "string") {
            throw new Error("string type in extglob ast??");
          }
          const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
          this.#uflag = this.#uflag || uflag;
          return re;
        }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
      }
      static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = "";
        let uflag = false;
        for (let i2 = 0; i2 < glob.length; i2++) {
          const c2 = glob.charAt(i2);
          if (escaping) {
            escaping = false;
            re += (reSpecials.has(c2) ? "\\" : "") + c2;
            continue;
          }
          if (c2 === "\\") {
            if (i2 === glob.length - 1) {
              re += "\\\\";
            } else {
              escaping = true;
            }
            continue;
          }
          if (c2 === "[") {
            const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i2);
            if (consumed) {
              re += src;
              uflag = uflag || needUflag;
              i2 += consumed - 1;
              hasMagic = hasMagic || magic;
              continue;
            }
          }
          if (c2 === "*") {
            if (noEmpty && glob === "*")
              re += starNoEmpty;
            else
              re += star;
            hasMagic = true;
            continue;
          }
          if (c2 === "?") {
            re += qmark;
            hasMagic = true;
            continue;
          }
          re += regExpEscape(c2);
        }
        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
      }
    };
    exports2.AST = AST;
  }
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS({
  "node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escape = void 0;
    var escape2 = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
    };
    exports2.escape = escape2;
  }
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/glob/node_modules/minimatch/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = exports2.escape = exports2.AST = exports2.Minimatch = exports2.match = exports2.makeRe = exports2.braceExpand = exports2.defaults = exports2.filter = exports2.GLOBSTAR = exports2.sep = exports2.minimatch = void 0;
    var brace_expansion_1 = __importDefault(require_brace_expansion());
    var assert_valid_pattern_js_1 = require_assert_valid_pattern();
    var ast_js_1 = require_ast();
    var escape_js_1 = require_escape();
    var unescape_js_1 = require_unescape();
    var minimatch = (p, pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    exports2.minimatch = minimatch;
    var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
    var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
    var starDotExtTestNocase = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
    };
    var starDotExtTestNocaseDot = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => f.toLowerCase().endsWith(ext2);
    };
    var starDotStarRE = /^\*+\.\*+$/;
    var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
    var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
    var dotStarRE = /^\.\*+$/;
    var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
    var starRE = /^\*+$/;
    var starTest = (f) => f.length !== 0 && !f.startsWith(".");
    var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
    var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    var qmarksTestNocase = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTest = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTestNoExt = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && !f.startsWith(".");
    };
    var qmarksTestNoExtDot = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && f !== "." && f !== "..";
    };
    var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    var path11 = {
      win32: { sep: "\\" },
      posix: { sep: "/" }
    };
    exports2.sep = defaultPlatform === "win32" ? path11.win32.sep : path11.posix.sep;
    exports2.minimatch.sep = exports2.sep;
    exports2.GLOBSTAR = Symbol("globstar **");
    exports2.minimatch.GLOBSTAR = exports2.GLOBSTAR;
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var filter = (pattern, options = {}) => (p) => (0, exports2.minimatch)(p, pattern, options);
    exports2.filter = filter;
    exports2.minimatch.filter = exports2.filter;
    var ext = (a, b = {}) => Object.assign({}, a, b);
    var defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return exports2.minimatch;
      }
      const orig = exports2.minimatch;
      const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
      return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
          constructor(pattern, options = {}) {
            super(pattern, ext(def, options));
          }
          static defaults(options) {
            return orig.defaults(ext(def, options)).Minimatch;
          }
        },
        AST: class AST extends orig.AST {
          /* c8 ignore start */
          constructor(type, parent, options = {}) {
            super(type, parent, ext(def, options));
          }
          /* c8 ignore stop */
          static fromGlob(pattern, options = {}) {
            return orig.AST.fromGlob(pattern, ext(def, options));
          }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports2.GLOBSTAR
      });
    };
    exports2.defaults = defaults;
    exports2.minimatch.defaults = exports2.defaults;
    var braceExpand = (pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return (0, brace_expansion_1.default)(pattern);
    };
    exports2.braceExpand = braceExpand;
    exports2.minimatch.braceExpand = exports2.braceExpand;
    var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
    exports2.makeRe = makeRe;
    exports2.minimatch.makeRe = exports2.makeRe;
    var match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    exports2.match = match;
    exports2.minimatch.match = exports2.match;
    var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      options;
      set;
      pattern;
      windowsPathsNoEscape;
      nonegate;
      negate;
      comment;
      empty;
      preserveMultipleSlashes;
      partial;
      globSet;
      globParts;
      nocase;
      isWindows;
      platform;
      windowsNoMagicRoot;
      regexp;
      constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
          return true;
        }
        for (const pattern of this.set) {
          for (const part of pattern) {
            if (typeof part !== "string")
              return true;
          }
        }
        return false;
      }
      debug(..._) {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
          this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set = this.globParts.map((s, _, __) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
            const isDrive = /^[a-z]:/i.test(s[0]);
            if (isUNC) {
              return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
            } else if (isDrive) {
              return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
            }
          }
          return s.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set);
        this.set = set.filter((s) => s.indexOf(false) === -1);
        if (this.isWindows) {
          for (let i2 = 0; i2 < this.set.length; i2++) {
            const p = this.set[i2];
            if (p[0] === "" && p[1] === "" && this.globParts[i2][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
              p[2] = "?";
            }
          }
        }
        this.debug(this.pattern, this.set);
      }
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      preprocess(globParts) {
        if (this.options.noglobstar) {
          for (let i2 = 0; i2 < globParts.length; i2++) {
            for (let j = 0; j < globParts[i2].length; j++) {
              if (globParts[i2][j] === "**") {
                globParts[i2][j] = "*";
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          globParts = this.firstPhasePreProcess(globParts);
          globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
          globParts = this.levelOneOptimize(globParts);
        } else {
          globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
      }
      // just get rid of adjascent ** portions
      adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let i2 = gs;
            while (parts[i2 + 1] === "**") {
              i2++;
            }
            if (i2 !== gs) {
              parts.splice(gs, i2 - gs);
            }
          }
          return parts;
        });
      }
      // get rid of adjascent ** and resolve .. portions
      levelOneOptimize(globParts) {
        return globParts.map((parts) => {
          parts = parts.reduce((set, part) => {
            const prev = set[set.length - 1];
            if (part === "**" && prev === "**") {
              return set;
            }
            if (part === "..") {
              if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                set.pop();
                return set;
              }
            }
            set.push(part);
            return set;
          }, []);
          return parts.length === 0 ? [""] : parts;
        });
      }
      levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
          parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
          didSomething = false;
          if (!this.preserveMultipleSlashes) {
            for (let i2 = 1; i2 < parts.length - 1; i2++) {
              const p = parts[i2];
              if (i2 === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i2, 1);
                i2--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              parts.splice(dd - 1, 2);
              dd -= 2;
            }
          }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
      }
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
          didSomething = false;
          for (let parts of globParts) {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let gss = gs;
              while (parts[gss + 1] === "**") {
                gss++;
              }
              if (gss > gs) {
                parts.splice(gs + 1, gss - gs);
              }
              let next = parts[gs + 1];
              const p = parts[gs + 2];
              const p2 = parts[gs + 3];
              if (next !== "..")
                continue;
              if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
                continue;
              }
              didSomething = true;
              parts.splice(gs, 1);
              const other = parts.slice(0);
              other[gs] = "**";
              globParts.push(other);
              gs--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let i2 = 1; i2 < parts.length - 1; i2++) {
                const p = parts[i2];
                if (i2 === 1 && p === "" && parts[0] === "")
                  continue;
                if (p === "." || p === "") {
                  didSomething = true;
                  parts.splice(i2, 1);
                  i2--;
                }
              }
              if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
              const p = parts[dd - 1];
              if (p && p !== "." && p !== ".." && p !== "**") {
                didSomething = true;
                const needDot = dd === 1 && parts[dd + 1] === "**";
                const splin = needDot ? ["."] : [];
                parts.splice(dd - 1, 2, ...splin);
                if (parts.length === 0)
                  parts.push("");
                dd -= 2;
              }
            }
          }
        } while (didSomething);
        return globParts;
      }
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      secondPhasePreProcess(globParts) {
        for (let i2 = 0; i2 < globParts.length - 1; i2++) {
          for (let j = i2 + 1; j < globParts.length; j++) {
            const matched = this.partsMatch(globParts[i2], globParts[j], !this.preserveMultipleSlashes);
            if (matched) {
              globParts[i2] = [];
              globParts[j] = matched;
              break;
            }
          }
        }
        return globParts.filter((gs) => gs.length);
      }
      partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = "";
        while (ai < a.length && bi < b.length) {
          if (a[ai] === b[bi]) {
            result.push(which === "b" ? b[bi] : a[ai]);
            ai++;
            bi++;
          } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
            result.push(a[ai]);
            ai++;
          } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
            result.push(b[bi]);
            bi++;
          } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
            if (which === "b")
              return false;
            which = "a";
            result.push(a[ai]);
            ai++;
            bi++;
          } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
            if (which === "a")
              return false;
            which = "b";
            result.push(b[bi]);
            ai++;
            bi++;
          } else {
            return false;
          }
        }
        return a.length === b.length && result;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial = false) {
        const options = this.options;
        if (this.isWindows) {
          const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
          const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
          const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
          const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
          const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
          const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi === "number" && typeof pdi === "number") {
            const [fd, pd] = [file[fdi], pattern[pdi]];
            if (fd.toLowerCase() === pd.toLowerCase()) {
              pattern[pdi] = fd;
              if (pdi > fdi) {
                pattern = pattern.slice(pdi);
              } else if (fdi > pdi) {
                file = file.slice(fdi);
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) {
            return false;
          }
          if (p === exports2.GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) {
                return true;
              }
            }
            return false;
          }
          let hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = p.test(f);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        } else {
          throw new Error("wtf?");
        }
      }
      braceExpand() {
        return (0, exports2.braceExpand)(this.pattern, this.options);
      }
      parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        if (pattern === "**")
          return exports2.GLOBSTAR;
        if (pattern === "")
          return "";
        let m;
        let fastTest = null;
        if (m = pattern.match(starRE)) {
          fastTest = options.dot ? starTestDot : starTest;
        } else if (m = pattern.match(starDotExtRE)) {
          fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
        } else if (m = pattern.match(qmarksRE)) {
          fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
        } else if (m = pattern.match(starDotStarRE)) {
          fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m = pattern.match(dotStarRE)) {
          fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === "object") {
          Reflect.defineProperty(re, "test", { value: fastTest });
        }
        return re;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options.nocase ? ["i"] : []);
        let re = set.map((pattern) => {
          const pp = pattern.map((p) => {
            if (p instanceof RegExp) {
              for (const f of p.flags.split(""))
                flags.add(f);
            }
            return typeof p === "string" ? regExpEscape(p) : p === exports2.GLOBSTAR ? exports2.GLOBSTAR : p._src;
          });
          pp.forEach((p, i2) => {
            const next = pp[i2 + 1];
            const prev = pp[i2 - 1];
            if (p !== exports2.GLOBSTAR || prev === exports2.GLOBSTAR) {
              return;
            }
            if (prev === void 0) {
              if (next !== void 0 && next !== exports2.GLOBSTAR) {
                pp[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
              } else {
                pp[i2] = twoStar;
              }
            } else if (next === void 0) {
              pp[i2 - 1] = prev + "(?:\\/|" + twoStar + ")?";
            } else if (next !== exports2.GLOBSTAR) {
              pp[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
              pp[i2 + 1] = exports2.GLOBSTAR;
            }
          });
          return pp.filter((p) => p !== exports2.GLOBSTAR).join("/");
        }).join("|");
        const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
        re = "^" + open + re + close + "$";
        if (this.negate)
          re = "^(?!" + re + ").+$";
        try {
          this.regexp = new RegExp(re, [...flags].join(""));
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(p) {
        if (this.preserveMultipleSlashes) {
          return p.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
          return ["", ...p.split(/\/+/)];
        } else {
          return p.split(/\/+/);
        }
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) {
          return false;
        }
        if (this.empty) {
          return f === "";
        }
        if (f === "/" && partial) {
          return true;
        }
        const options = this.options;
        if (this.isWindows) {
          f = f.split("\\").join("/");
        }
        const ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename = ff[ff.length - 1];
        if (!filename) {
          for (let i2 = ff.length - 2; !filename && i2 >= 0; i2--) {
            filename = ff[i2];
          }
        }
        for (let i2 = 0; i2 < set.length; i2++) {
          const pattern = set[i2];
          let file = ff;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) {
              return true;
            }
            return !this.negate;
          }
        }
        if (options.flipNegate) {
          return false;
        }
        return this.negate;
      }
      static defaults(def) {
        return exports2.minimatch.defaults(def).Minimatch;
      }
    };
    exports2.Minimatch = Minimatch;
    var ast_js_2 = require_ast();
    Object.defineProperty(exports2, "AST", { enumerable: true, get: function() {
      return ast_js_2.AST;
    } });
    var escape_js_2 = require_escape();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    var unescape_js_2 = require_unescape();
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return unescape_js_2.unescape;
    } });
    exports2.minimatch.AST = ast_js_1.AST;
    exports2.minimatch.Minimatch = Minimatch;
    exports2.minimatch.escape = escape_js_1.escape;
    exports2.minimatch.unescape = unescape_js_1.unescape;
  }
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "node_modules/lru-cache/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      // options that cannot be changed without disaster
      #max;
      #maxSize;
      #dispose;
      #disposeAfter;
      #fetchMethod;
      #memoMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c2) {
        return {
          // properties
          starts: c2.#starts,
          ttls: c2.#ttls,
          sizes: c2.#sizes,
          keyMap: c2.#keyMap,
          keyList: c2.#keyList,
          valList: c2.#valList,
          next: c2.#next,
          prev: c2.#prev,
          get head() {
            return c2.#head;
          },
          get tail() {
            return c2.#tail;
          },
          free: c2.#free,
          // methods
          isBackgroundFetch: (p) => c2.#isBackgroundFetch(p),
          backgroundFetch: (k, index, options, context) => c2.#backgroundFetch(k, index, options, context),
          moveToTail: (index) => c2.#moveToTail(index),
          indexes: (options) => c2.#indexes(options),
          rindexes: (options) => c2.#rindexes(options),
          isStale: (index) => c2.#isStale(index)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      get memoMethod() {
        return this.#memoMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key3) {
        return this.#keyMap.has(key3) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
          starts[index] = ttl !== 0 ? start : 0;
          ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index)) {
                this.#delete(this.#keyList[index], "expire");
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index) => {
          starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
          if (ttls[index]) {
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start)
              return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            const age = status.now - start;
            status.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key3) => {
          const index = this.#keyMap.get(key3);
          if (index === void 0) {
            return 0;
          }
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index) => {
          const s = starts[index];
          const t = ttls[index];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index) => {
          this.#calculatedSize -= sizes[index];
          sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index, size, status) => {
          sizes[index] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i2 = this.#tail; true; ) {
            if (!this.#isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.#isStale(i2)) {
              yield i2;
            }
            if (i2 === this.#head) {
              break;
            } else {
              i2 = this.#prev[i2];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i2 = this.#head; true; ) {
            if (!this.#isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.#isStale(i2)) {
              yield i2;
            }
            if (i2 === this.#tail) {
              break;
            } else {
              i2 = this.#next[i2];
            }
          }
        }
      }
      #isValidIndex(index) {
        return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i2 of this.#indexes()) {
          if (this.#valList[i2] !== void 0 && this.#keyList[i2] !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
            yield [this.#keyList[i2], this.#valList[i2]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i2 of this.#rindexes()) {
          if (this.#valList[i2] !== void 0 && this.#keyList[i2] !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
            yield [this.#keyList[i2], this.#valList[i2]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i2 of this.#indexes()) {
          const k = this.#keyList[i2];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i2 of this.#rindexes()) {
          const k = this.#keyList[i2];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i2 of this.#indexes()) {
          const v = this.#valList[i2];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
            yield this.#valList[i2];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i2 of this.#rindexes()) {
          const v = this.#valList[i2];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
            yield this.#valList[i2];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i2 of this.#indexes()) {
          const v = this.#valList[i2];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, this.#keyList[i2], this)) {
            return this.get(this.#keyList[i2], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i2 of this.#indexes()) {
          const v = this.#valList[i2];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i2], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i2 of this.#rindexes()) {
          const v = this.#valList[i2];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i2], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i2 of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i2)) {
            this.#delete(this.#keyList[i2], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key3) {
        const i2 = this.#keyMap.get(key3);
        if (i2 === void 0)
          return void 0;
        const v = this.#valList[i2];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i2];
          const start = this.#starts[i2];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i2];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRLUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i2 of this.#indexes({ allowStale: true })) {
          const key3 = this.#keyList[i2];
          const v = this.#valList[i2];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key3 === void 0)
            continue;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            entry.ttl = this.#ttls[i2];
            const age = perf.now() - this.#starts[i2];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i2];
          }
          arr.unshift([key3, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key3, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key3, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.#delete(k, "set");
          return this;
        }
        let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index === void 0) {
          index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index] = k;
          this.#valList[index] = v;
          this.#keyMap.set(k, index);
          this.#next[this.#tail] = index;
          this.#prev[index] = this.#tail;
          this.#tail = index;
          this.#size++;
          this.#addItemSize(index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          this.#moveToTail(index);
          const oldVal = this.#valList[index];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index);
            this.#addItemSize(index, size, status);
            this.#valList[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index, ttl, start);
          }
          if (status)
            this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index);
            }
            if (status) {
              status.has = "hit";
              this.#statusTTL(status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            this.#statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === void 0 || !allowStale && this.#isStale(index)) {
          return;
        }
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          if (this.#valList[index] === p) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index] = bf2.__staleWhileFetching;
              } else {
                this.#delete(k, "fetch");
              }
            } else {
              if (options.status)
                options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.#delete(k, "fetch");
            } else if (!allowStaleAborted) {
              this.#valList[index] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && bf2.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res(void 0);
              if (options.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options.status)
          options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index = this.#keyMap.get(k);
        } else {
          this.#valList[index] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.#keyMap.get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = this.#backgroundFetch(k, index, options, context);
          return p.__returned = p;
        } else {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            if (status)
              this.#statusTTL(status, index);
            return v;
          }
          const p = this.#backgroundFetch(k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const value = this.#valList[index];
          const fetching = this.#isBackgroundFetch(value);
          if (status)
            this.#statusTTL(status, index);
          if (this.#isStale(index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.#delete(k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index) {
        if (index !== this.#tail) {
          if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#connect(this.#prev[index], this.#next[index]);
          }
          this.#connect(this.#tail, index);
          this.#tail = index;
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return this.#delete(k, "delete");
      }
      #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
          const index = this.#keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.#clear(reason);
            } else {
              this.#removeItemSize(index);
              const v = this.#valList[index];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, reason]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index] = void 0;
              this.#valList[index] = void 0;
              if (index === this.#tail) {
                this.#tail = this.#prev[index];
              } else if (index === this.#head) {
                this.#head = this.#next[index];
              } else {
                const pi = this.#prev[index];
                this.#next[pi] = this.#next[index];
                const ni = this.#next[index];
                this.#prev[ni] = this.#prev[index];
              }
              this.#size--;
              this.#free.push(index);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return this.#clear("delete");
      }
      #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs3 = __commonJS({
  "node_modules/minipass/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Minipass = exports2.isWritable = exports2.isReadable = exports2.isStream = void 0;
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var node_events_1 = require("events");
    var node_stream_1 = __importDefault(require("stream"));
    var node_string_decoder_1 = require("string_decoder");
    var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports2.isReadable)(s) || (0, exports2.isWritable)(s));
    exports2.isStream = isStream;
    var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
    s.pipe !== node_stream_1.default.Writable.prototype.pipe;
    exports2.isReadable = isReadable;
    var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
    exports2.isWritable = isWritable;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var DATALISTENERS = Symbol("dataListeners");
    var DISCARDED = Symbol("discarded");
    var defer = (fn) => Promise.resolve().then(fn);
    var nodefer = (fn) => fn();
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      src;
      dest;
      opts;
      ondrain;
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // only here for the prototype
      /* c8 ignore start */
      proxyErrors(_er) {
      }
      /* c8 ignore stop */
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var isObjectModeOptions = (o) => !!o.objectMode;
    var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
    var Minipass = class extends node_events_1.EventEmitter {
      [FLOWING] = false;
      [PAUSED] = false;
      [PIPES] = [];
      [BUFFER] = [];
      [OBJECTMODE];
      [ENCODING];
      [ASYNC];
      [DECODER];
      [EOF] = false;
      [EMITTED_END] = false;
      [EMITTING_END] = false;
      [CLOSED] = false;
      [EMITTED_ERROR] = null;
      [BUFFERLENGTH] = 0;
      [DESTROYED] = false;
      [SIGNAL];
      [ABORTED] = false;
      [DATALISTENERS] = 0;
      [DISCARDED] = false;
      /**
       * true if the stream can be written
       */
      writable = true;
      /**
       * true if the stream can be read
       */
      readable = true;
      /**
       * If `RType` is Buffer, then options do not need to be provided.
       * Otherwise, an options object must be provided to specify either
       * {@link Minipass.SharedOptions.objectMode} or
       * {@link Minipass.SharedOptions.encoding}, as appropriate.
       */
      constructor(...args) {
        const options = args[0] || {};
        super();
        if (options.objectMode && typeof options.encoding === "string") {
          throw new TypeError("Encoding and objectMode may not be used together");
        }
        if (isObjectModeOptions(options)) {
          this[OBJECTMODE] = true;
          this[ENCODING] = null;
        } else if (isEncodingOptions(options)) {
          this[ENCODING] = options.encoding;
          this[OBJECTMODE] = false;
        } else {
          this[OBJECTMODE] = false;
          this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
        if (options && options.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options && options.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
          this[SIGNAL] = signal;
          if (signal.aborted) {
            this[ABORT]();
          } else {
            signal.addEventListener("abort", () => this[ABORT]());
          }
        }
      }
      /**
       * The amount of data stored in the buffer waiting to be read.
       *
       * For Buffer strings, this will be the total byte length.
       * For string encoding streams, this will be the string character length,
       * according to JavaScript's `string.length` logic.
       * For objectMode streams, this is a count of the items waiting to be
       * emitted.
       */
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      /**
       * The `BufferEncoding` currently in use, or `null`
       */
      get encoding() {
        return this[ENCODING];
      }
      /**
       * @deprecated - This is a read only property
       */
      set encoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * @deprecated - Encoding may only be set at instantiation time
       */
      setEncoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * True if this is an objectMode stream
       */
      get objectMode() {
        return this[OBJECTMODE];
      }
      /**
       * @deprecated - This is a read-only property
       */
      set objectMode(_om) {
        throw new Error("objectMode must be set at instantiation time");
      }
      /**
       * true if this is an async stream
       */
      get ["async"]() {
        return this[ASYNC];
      }
      /**
       * Set to true to make this stream async.
       *
       * Once set, it cannot be unset, as this would potentially cause incorrect
       * behavior.  Ie, a sync stream can be made async, but an async stream
       * cannot be safely made sync.
       */
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
      }
      /**
       * True if the stream has been aborted.
       */
      get aborted() {
        return this[ABORTED];
      }
      /**
       * No-op setter. Stream aborted status is set via the AbortSignal provided
       * in the constructor options.
       */
      set aborted(_) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : nodefer;
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk)) {
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          } else if (isArrayBufferLike(chunk)) {
            chunk = Buffer.from(chunk);
          } else if (typeof chunk !== "string") {
            throw new Error("Non-contiguous data written to non-objectMode stream");
          }
        }
        if (this[OBJECTMODE]) {
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this[FLOWING])
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
          chunk = this[DECODER].write(chunk);
        }
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      /**
       * Low-level explicit read method.
       *
       * In objectMode, the argument is ignored, and one item is returned if
       * available.
       *
       * `n` is the number of bytes (or in the case of encoding streams,
       * characters) to consume. If `n` is not provided, then the entire buffer
       * is returned, or `null` is returned if no data is available.
       *
       * If `n` is greater that the amount of data in the internal buffer,
       * then `null` is returned.
       */
      read(n) {
        if (this[DESTROYED])
          return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          this[BUFFER] = [
            this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
          ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (this[OBJECTMODE])
          this[BUFFERSHIFT]();
        else {
          const c2 = chunk;
          if (n === c2.length || n === null)
            this[BUFFERSHIFT]();
          else if (typeof c2 === "string") {
            this[BUFFER][0] = c2.slice(n);
            chunk = c2.slice(0, n);
            this[BUFFERLENGTH] -= n;
          } else {
            this[BUFFER][0] = c2.subarray(n);
            chunk = c2.subarray(0, n);
            this[BUFFERLENGTH] -= n;
          }
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = void 0;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (chunk !== void 0)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this[FLOWING] || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
          this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      /**
       * Resume the stream if it is currently in a paused state
       *
       * If called when there are no pipe destinations or `data` event listeners,
       * this will place the stream in a "discarded" state, where all data will
       * be thrown away. The discarded state is removed if a pipe destination or
       * data handler is added, if pause() is called, or if any synchronous or
       * asynchronous iteration is started.
       */
      resume() {
        return this[RESUME]();
      }
      /**
       * Pause the stream
       */
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
      }
      /**
       * true if the stream has been forcibly destroyed
       */
      get destroyed() {
        return this[DESTROYED];
      }
      /**
       * true if the stream is currently in a flowing state, meaning that
       * any writes will be immediately emitted.
       */
      get flowing() {
        return this[FLOWING];
      }
      /**
       * true if the stream is currently in a paused state
       */
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain = false) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this[FLOWING];
      }
      /**
       * Pipe all data emitted by this stream into the destination provided.
       *
       * Triggers the flow of data.
       */
      pipe(dest, opts) {
        if (this[DESTROYED])
          return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      /**
       * Fully unhook a piped destination stream.
       *
       * If the destination stream was the only consumer of this stream (ie,
       * there are no other piped destinations or `'data'` event listeners)
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          if (this[PIPES].length === 1) {
            if (this[FLOWING] && this[DATALISTENERS] === 0) {
              this[FLOWING] = false;
            }
            this[PIPES] = [];
          } else
            this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      /**
       * Alias for {@link Minipass#on}
       */
      addListener(ev, handler) {
        return this.on(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.on`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * - Adding a 'data' event handler will trigger the flow of data
       *
       * - Adding a 'readable' event handler when there is data waiting to be read
       *   will cause 'readable' to be emitted immediately.
       *
       * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
       *   already passed will cause the event to be emitted immediately and all
       *   handlers removed.
       *
       * - Adding an 'error' event handler after an error has been emitted will
       *   cause the event to be re-emitted immediately with the error previously
       *   raised.
       */
      on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === "data") {
          this[DISCARDED] = false;
          this[DATALISTENERS]++;
          if (!this[PIPES].length && !this[FLOWING]) {
            this[RESUME]();
          }
        } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
          super.emit("readable");
        } else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          const h = handler;
          if (this[ASYNC])
            defer(() => h.call(this, this[EMITTED_ERROR]));
          else
            h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      /**
       * Alias for {@link Minipass#off}
       */
      removeListener(ev, handler) {
        return this.off(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.off`
       *
       * If a 'data' event handler is removed, and it was the last consumer
       * (ie, there are no pipe destinations or other 'data' event listeners),
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      off(ev, handler) {
        const ret = super.off(ev, handler);
        if (ev === "data") {
          this[DATALISTENERS] = this.listeners("data").length;
          if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * Mostly identical to `EventEmitter.removeAllListeners`
       *
       * If all 'data' event handlers are removed, and they were the last consumer
       * (ie, there are no pipe destinations), then the flow of data will stop
       * until there is another consumer or {@link Minipass#resume} is explicitly
       * called.
       */
      removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === "data" || ev === void 0) {
          this[DATALISTENERS] = 0;
          if (!this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * true if the 'end' event has been emitted
       */
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      /**
       * Mostly identical to `EventEmitter.emit`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * If the stream has been destroyed, and the event is something other
       * than 'close' or 'error', then `false` is returned and no handlers
       * are called.
       *
       * If the event is 'end', and has already been emitted, then the event
       * is ignored. If the stream is in a paused or non-flowing state, then
       * the event will be deferred until data flow resumes. If the stream is
       * async, then handlers will be called on the next tick rather than
       * immediately.
       *
       * If the event is 'close', and 'end' has not yet been emitted, then
       * the event will be deferred until after 'end' is emitted.
       *
       * If the event is 'error', and an AbortSignal was provided for the stream,
       * and there are no listeners, then the event is ignored, matching the
       * behavior of node core streams in the presense of an AbortSignal.
       *
       * If the event is 'finish' or 'prefinish', then all listeners will be
       * removed after emitting the event, to prevent double-firing.
       */
      emit(ev, ...args) {
        const data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
          return false;
        } else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return false;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            if (!this[DISCARDED])
              super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      /**
       * Return a Promise that resolves to an array of all emitted data once
       * the stream ends.
       */
      async collect() {
        const buf = Object.assign([], {
          dataLength: 0
        });
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c2) => {
          buf.push(c2);
          if (!this[OBJECTMODE])
            buf.dataLength += c2.length;
        });
        await p;
        return buf;
      }
      /**
       * Return a Promise that resolves to the concatenation of all emitted data
       * once the stream ends.
       *
       * Not allowed on objectMode streams.
       */
      async concat() {
        if (this[OBJECTMODE]) {
          throw new Error("cannot concat in objectMode");
        }
        const buf = await this.collect();
        return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
      }
      /**
       * Return a void Promise that resolves once the stream ends.
       */
      async promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      /**
       * Asynchronous `for await of` iteration.
       *
       * This will continue emitting all chunks until the stream terminates.
       */
      [Symbol.asyncIterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
          this.pause();
          stopped = true;
          return { value: void 0, done: true };
        };
        const next = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve;
          let reject;
          const onerr = (er) => {
            this.off("data", ondata);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value) => {
            this.off("error", onerr);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.off("error", onerr);
            this.off("data", ondata);
            this.off(DESTROYED, ondestroy);
            stop();
            resolve({ done: true, value: void 0 });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Synchronous `for of` iteration.
       *
       * The iteration will terminate when the internal buffer runs out, even
       * if the stream has not yet terminated.
       */
      [Symbol.iterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
          this.pause();
          this.off(ERROR, stop);
          this.off(DESTROYED, stop);
          this.off("end", stop);
          stopped = true;
          return { done: true, value: void 0 };
        };
        const next = () => {
          if (stopped)
            return stop();
          const value = this.read();
          return value === null ? stop() : { done: false, value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.iterator]() {
            return this;
          }
        };
      }
      /**
       * Destroy a stream, preventing it from being used for any further purpose.
       *
       * If the stream has a `close()` method, then it will be called on
       * destruction.
       *
       * After destruction, any attempt to write data, read data, or emit most
       * events will be ignored.
       *
       * If an error argument is provided, then it will be emitted in an
       * 'error' event.
       */
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === "function" && !this[CLOSED])
          wc.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      /**
       * Alias for {@link isStream}
       *
       * Former export location, maintained for backwards compatibility.
       *
       * @deprecated
       */
      static get isStream() {
        return exports2.isStream;
      }
    };
    exports2.Minipass = Minipass;
  }
});

// node_modules/path-scurry/dist/commonjs/index.js
var require_commonjs4 = __commonJS({
  "node_modules/path-scurry/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathScurry = exports2.Path = exports2.PathScurryDarwin = exports2.PathScurryPosix = exports2.PathScurryWin32 = exports2.PathScurryBase = exports2.PathPosix = exports2.PathWin32 = exports2.PathBase = exports2.ChildrenCache = exports2.ResolveCache = void 0;
    var lru_cache_1 = require_commonjs2();
    var node_path_1 = require("path");
    var node_url_1 = require("url");
    var fs_1 = require("fs");
    var actualFS = __importStar(require("fs"));
    var realpathSync = fs_1.realpathSync.native;
    var promises_1 = require("fs/promises");
    var minipass_1 = require_commonjs3();
    var defaultFS = {
      lstatSync: fs_1.lstatSync,
      readdir: fs_1.readdir,
      readdirSync: fs_1.readdirSync,
      readlinkSync: fs_1.readlinkSync,
      realpathSync,
      promises: {
        lstat: promises_1.lstat,
        readdir: promises_1.readdir,
        readlink: promises_1.readlink,
        realpath: promises_1.realpath
      }
    };
    var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
      ...defaultFS,
      ...fsOption,
      promises: {
        ...defaultFS.promises,
        ...fsOption.promises || {}
      }
    };
    var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
    var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    var eitherSep = /[\\\/]/;
    var UNKNOWN = 0;
    var IFIFO = 1;
    var IFCHR = 2;
    var IFDIR = 4;
    var IFBLK = 6;
    var IFREG = 8;
    var IFLNK = 10;
    var IFSOCK = 12;
    var IFMT = 15;
    var IFMT_UNKNOWN = ~IFMT;
    var READDIR_CALLED = 16;
    var LSTAT_CALLED = 32;
    var ENOTDIR = 64;
    var ENOENT = 128;
    var ENOREADLINK = 256;
    var ENOREALPATH = 512;
    var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
    var TYPEMASK = 1023;
    var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
    var normalizeCache = /* @__PURE__ */ new Map();
    var normalize = (s) => {
      const c2 = normalizeCache.get(s);
      if (c2)
        return c2;
      const n = s.normalize("NFKD");
      normalizeCache.set(s, n);
      return n;
    };
    var normalizeNocaseCache = /* @__PURE__ */ new Map();
    var normalizeNocase = (s) => {
      const c2 = normalizeNocaseCache.get(s);
      if (c2)
        return c2;
      const n = normalize(s.toLowerCase());
      normalizeNocaseCache.set(s, n);
      return n;
    };
    var ResolveCache = class extends lru_cache_1.LRUCache {
      constructor() {
        super({ max: 256 });
      }
    };
    exports2.ResolveCache = ResolveCache;
    var ChildrenCache = class extends lru_cache_1.LRUCache {
      constructor(maxSize = 16 * 1024) {
        super({
          maxSize,
          // parent + children
          sizeCalculation: (a) => a.length + 1
        });
      }
    };
    exports2.ChildrenCache = ChildrenCache;
    var setAsCwd = Symbol("PathScurry setAsCwd");
    var PathBase = class {
      /**
       * the basename of this path
       *
       * **Important**: *always* test the path name against any test string
       * usingthe {@link isNamed} method, and not by directly comparing this
       * string. Otherwise, unicode path strings that the system sees as identical
       * will not be properly treated as the same path, leading to incorrect
       * behavior and possible security issues.
       */
      name;
      /**
       * the Path entry corresponding to the path root.
       *
       * @internal
       */
      root;
      /**
       * All roots found within the current PathScurry family
       *
       * @internal
       */
      roots;
      /**
       * a reference to the parent path, or undefined in the case of root entries
       *
       * @internal
       */
      parent;
      /**
       * boolean indicating whether paths are compared case-insensitively
       * @internal
       */
      nocase;
      /**
       * boolean indicating that this path is the current working directory
       * of the PathScurry collection that contains it.
       */
      isCWD = false;
      // potential default fs override
      #fs;
      // Stats fields
      #dev;
      get dev() {
        return this.#dev;
      }
      #mode;
      get mode() {
        return this.#mode;
      }
      #nlink;
      get nlink() {
        return this.#nlink;
      }
      #uid;
      get uid() {
        return this.#uid;
      }
      #gid;
      get gid() {
        return this.#gid;
      }
      #rdev;
      get rdev() {
        return this.#rdev;
      }
      #blksize;
      get blksize() {
        return this.#blksize;
      }
      #ino;
      get ino() {
        return this.#ino;
      }
      #size;
      get size() {
        return this.#size;
      }
      #blocks;
      get blocks() {
        return this.#blocks;
      }
      #atimeMs;
      get atimeMs() {
        return this.#atimeMs;
      }
      #mtimeMs;
      get mtimeMs() {
        return this.#mtimeMs;
      }
      #ctimeMs;
      get ctimeMs() {
        return this.#ctimeMs;
      }
      #birthtimeMs;
      get birthtimeMs() {
        return this.#birthtimeMs;
      }
      #atime;
      get atime() {
        return this.#atime;
      }
      #mtime;
      get mtime() {
        return this.#mtime;
      }
      #ctime;
      get ctime() {
        return this.#ctime;
      }
      #birthtime;
      get birthtime() {
        return this.#birthtime;
      }
      #matchName;
      #depth;
      #fullpath;
      #fullpathPosix;
      #relative;
      #relativePosix;
      #type;
      #children;
      #linkTarget;
      #realpath;
      /**
       * This property is for compatibility with the Dirent class as of
       * Node v20, where Dirent['parentPath'] refers to the path of the
       * directory that was passed to readdir. For root entries, it's the path
       * to the entry itself.
       */
      get parentPath() {
        return (this.parent || this).fullpath();
      }
      /**
       * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
       * this property refers to the *parent* path, not the path object itself.
       */
      get path() {
        return this.parentPath;
      }
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root2, roots, nocase, children2, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root2 || this;
        this.#children = children2;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
          this.#fs = this.parent.#fs;
        } else {
          this.#fs = fsFromOption(opts.fs);
        }
      }
      /**
       * Returns the depth of the Path object from its root.
       *
       * For example, a path at `/foo/bar` would have a depth of 2.
       */
      depth() {
        if (this.#depth !== void 0)
          return this.#depth;
        if (!this.parent)
          return this.#depth = 0;
        return this.#depth = this.parent.depth() + 1;
      }
      /**
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Get the Path object referenced by the string path, resolved from this Path
       */
      resolve(path11) {
        if (!path11) {
          return this;
        }
        const rootPath = this.getRootString(path11);
        const dir = path11.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
        return result;
      }
      #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
          p = p.child(part);
        }
        return p;
      }
      /**
       * Returns the cached children Path objects, if still available.  If they
       * have fallen out of the cache, then returns an empty array, and resets the
       * READDIR_CALLED bit, so that future calls to readdir() will require an fs
       * lookup.
       *
       * @internal
       */
      children() {
        const cached = this.#children.get(this);
        if (cached) {
          return cached;
        }
        const children2 = Object.assign([], { provisional: 0 });
        this.#children.set(this, children2);
        this.#type &= ~READDIR_CALLED;
        return children2;
      }
      /**
       * Resolves a path portion and returns or creates the child Path.
       *
       * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
       * `'..'`.
       *
       * This should not be called directly.  If `pathPart` contains any path
       * separators, it will lead to unsafe undefined behavior.
       *
       * Use `Path.resolve()` instead.
       *
       * @internal
       */
      child(pathPart, opts) {
        if (pathPart === "" || pathPart === ".") {
          return this;
        }
        if (pathPart === "..") {
          return this.parent || this;
        }
        const children2 = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children2) {
          if (p.#matchName === name) {
            return p;
          }
        }
        const s = this.parent ? this.sep : "";
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
        const pchild = this.newChild(pathPart, UNKNOWN, {
          ...opts,
          parent: this,
          fullpath
        });
        if (!this.canReaddir()) {
          pchild.#type |= ENOENT;
        }
        children2.push(pchild);
        return pchild;
      }
      /**
       * The relative path from the cwd. If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpath()
       */
      relative() {
        if (this.isCWD)
          return "";
        if (this.#relative !== void 0) {
          return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relative = this.name;
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? "" : this.sep) + name;
      }
      /**
       * The relative path from the cwd, using / as the path separator.
       * If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpathPosix()
       * On posix systems, this is identical to relative().
       */
      relativePosix() {
        if (this.sep === "/")
          return this.relative();
        if (this.isCWD)
          return "";
        if (this.#relativePosix !== void 0)
          return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relativePosix = this.fullpathPosix();
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? "" : "/") + name;
      }
      /**
       * The fully resolved path string for this Path entry
       */
      fullpath() {
        if (this.#fullpath !== void 0) {
          return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#fullpath = this.name;
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? "" : this.sep) + name;
        return this.#fullpath = fp;
      }
      /**
       * On platforms other than windows, this is identical to fullpath.
       *
       * On windows, this is overridden to return the forward-slash form of the
       * full UNC path.
       */
      fullpathPosix() {
        if (this.#fullpathPosix !== void 0)
          return this.#fullpathPosix;
        if (this.sep === "/")
          return this.#fullpathPosix = this.fullpath();
        if (!this.parent) {
          const p2 = this.fullpath().replace(/\\/g, "/");
          if (/^[a-z]:\//i.test(p2)) {
            return this.#fullpathPosix = `//?/${p2}`;
          } else {
            return this.#fullpathPosix = p2;
          }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
        return this.#fullpathPosix = fpp;
      }
      /**
       * Is the Path of an unknown type?
       *
       * Note that we might know *something* about it if there has been a previous
       * filesystem operation, for example that it does not exist, or is not a
       * link, or whether it has child entries.
       */
      isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
      }
      isType(type) {
        return this[`is${type}`]();
      }
      getType() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
          /* c8 ignore start */
          this.isSocket() ? "Socket" : "Unknown"
        );
      }
      /**
       * Is the Path a regular file?
       */
      isFile() {
        return (this.#type & IFMT) === IFREG;
      }
      /**
       * Is the Path a directory?
       */
      isDirectory() {
        return (this.#type & IFMT) === IFDIR;
      }
      /**
       * Is the path a character device?
       */
      isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
      }
      /**
       * Is the path a block device?
       */
      isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
      }
      /**
       * Is the path a FIFO pipe?
       */
      isFIFO() {
        return (this.#type & IFMT) === IFIFO;
      }
      /**
       * Is the path a socket?
       */
      isSocket() {
        return (this.#type & IFMT) === IFSOCK;
      }
      /**
       * Is the path a symbolic link?
       */
      isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
      }
      /**
       * Return the entry if it has been subject of a successful lstat, or
       * undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* simply
       * mean that we haven't called lstat on it.
       */
      lstatCached() {
        return this.#type & LSTAT_CALLED ? this : void 0;
      }
      /**
       * Return the cached link target if the entry has been the subject of a
       * successful readlink, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readlink() has been called at some point.
       */
      readlinkCached() {
        return this.#linkTarget;
      }
      /**
       * Returns the cached realpath target if the entry has been the subject
       * of a successful realpath, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * realpath() has been called at some point.
       */
      realpathCached() {
        return this.#realpath;
      }
      /**
       * Returns the cached child Path entries array if the entry has been the
       * subject of a successful readdir(), or [] otherwise.
       *
       * Does not read the filesystem, so an empty array *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readdir() has been called recently enough to still be valid.
       */
      readdirCached() {
        const children2 = this.children();
        return children2.slice(0, children2.provisional);
      }
      /**
       * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
       * any indication that readlink will definitely fail.
       *
       * Returns false if the path is known to not be a symlink, if a previous
       * readlink failed, or if the entry does not exist.
       */
      canReadlink() {
        if (this.#linkTarget)
          return true;
        if (!this.parent)
          return false;
        const ifmt = this.#type & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
      }
      /**
       * Return true if readdir has previously been successfully called on this
       * path, indicating that cachedReaddir() is likely valid.
       */
      calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
      }
      /**
       * Returns true if the path is known to not exist. That is, a previous lstat
       * or readdir failed to verify its existence when that would have been
       * expected, or a parent entry was marked either enoent or enotdir.
       */
      isENOENT() {
        return !!(this.#type & ENOENT);
      }
      /**
       * Return true if the path is a match for the given path name.  This handles
       * case sensitivity and unicode normalization.
       *
       * Note: even on case-sensitive systems, it is **not** safe to test the
       * equality of the `.name` property to determine whether a given pathname
       * matches, due to unicode normalization mismatches.
       *
       * Always use this method instead of testing the `path.name` property
       * directly.
       */
      isNamed(n) {
        return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
      }
      /**
       * Return the Path object corresponding to the target of a symbolic link.
       *
       * If the Path is not a symbolic link, or if the readlink call fails for any
       * reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       */
      async readlink() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read2 = await this.#fs.promises.readlink(this.fullpath());
          const linkTarget = (await this.parent.realpath())?.resolve(read2);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      /**
       * Synchronous {@link PathBase.readlink}
       */
      readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read2 = this.#fs.readlinkSync(this.fullpath());
          const linkTarget = this.parent.realpathSync()?.resolve(read2);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      #readdirSuccess(children2) {
        this.#type |= READDIR_CALLED;
        for (let p = children2.provisional; p < children2.length; p++) {
          const c2 = children2[p];
          if (c2)
            c2.#markENOENT();
        }
      }
      #markENOENT() {
        if (this.#type & ENOENT)
          return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
      }
      #markChildrenENOENT() {
        const children2 = this.children();
        children2.provisional = 0;
        for (const p of children2) {
          p.#markENOENT();
        }
      }
      #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
      }
      // save the information when we know the entry is not a dir
      #markENOTDIR() {
        if (this.#type & ENOTDIR)
          return;
        let t = this.#type;
        if ((t & IFMT) === IFDIR)
          t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
      }
      #readdirFail(code = "") {
        if (code === "ENOTDIR" || code === "EPERM") {
          this.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        } else {
          this.children().provisional = 0;
        }
      }
      #lstatFail(code = "") {
        if (code === "ENOTDIR") {
          const p = this.parent;
          p.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        }
      }
      #readlinkFail(code = "") {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === "ENOENT")
          ter |= ENOENT;
        if (code === "EINVAL" || code === "UNKNOWN") {
          ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        if (code === "ENOTDIR" && this.parent) {
          this.parent.#markENOTDIR();
        }
      }
      #readdirAddChild(e, c2) {
        return this.#readdirMaybePromoteChild(e, c2) || this.#readdirAddNewChild(e, c2);
      }
      #readdirAddNewChild(e, c2) {
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
          child.#type |= ENOTDIR;
        }
        c2.unshift(child);
        c2.provisional++;
        return child;
      }
      #readdirMaybePromoteChild(e, c2) {
        for (let p = c2.provisional; p < c2.length; p++) {
          const pchild = c2[p];
          const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
          if (name !== pchild.#matchName) {
            continue;
          }
          return this.#readdirPromoteChild(e, pchild, p, c2);
        }
      }
      #readdirPromoteChild(e, p, index, c2) {
        const v = p.name;
        p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
        if (v !== e.name)
          p.name = e.name;
        if (index !== c2.provisional) {
          if (index === c2.length - 1)
            c2.pop();
          else
            c2.splice(index, 1);
          c2.unshift(p);
        }
        c2.provisional++;
        return p;
      }
      /**
       * Call lstat() on this Path, and update all known information that can be
       * determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      /**
       * synchronous {@link PathBase.lstat}
       */
      lstatSync() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(this.#fs.lstatSync(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
          this.#type |= ENOTDIR;
        }
      }
      #onReaddirCB = [];
      #readdirCBInFlight = false;
      #callOnReaddirCB(children2) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach((cb) => cb(null, children2));
      }
      /**
       * Standard node-style callback interface to get list of directory entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       *
       * @param cb The callback called with (er, entries).  Note that the `er`
       * param is somewhat extraneous, as all readdir() errors are handled and
       * simply result in an empty set of entries being returned.
       * @param allowZalgo Boolean indicating that immediately known results should
       * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
       * zalgo at your peril, the dark pony lord is devious and unforgiving.
       */
      readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
          if (allowZalgo)
            cb(null, []);
          else
            queueMicrotask(() => cb(null, []));
          return;
        }
        const children2 = this.children();
        if (this.calledReaddir()) {
          const c2 = children2.slice(0, children2.provisional);
          if (allowZalgo)
            cb(null, c2);
          else
            queueMicrotask(() => cb(null, c2));
          return;
        }
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
          return;
        }
        this.#readdirCBInFlight = true;
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
          if (er) {
            this.#readdirFail(er.code);
            children2.provisional = 0;
          } else {
            for (const e of entries) {
              this.#readdirAddChild(e, children2);
            }
            this.#readdirSuccess(children2);
          }
          this.#callOnReaddirCB(children2.slice(0, children2.provisional));
          return;
        });
      }
      #asyncReaddirInFlight;
      /**
       * Return an array of known child entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async readdir() {
        if (!this.canReaddir()) {
          return [];
        }
        const children2 = this.children();
        if (this.calledReaddir()) {
          return children2.slice(0, children2.provisional);
        }
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
          await this.#asyncReaddirInFlight;
        } else {
          let resolve = () => {
          };
          this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
          try {
            for (const e of await this.#fs.promises.readdir(fullpath, {
              withFileTypes: true
            })) {
              this.#readdirAddChild(e, children2);
            }
            this.#readdirSuccess(children2);
          } catch (er) {
            this.#readdirFail(er.code);
            children2.provisional = 0;
          }
          this.#asyncReaddirInFlight = void 0;
          resolve();
        }
        return children2.slice(0, children2.provisional);
      }
      /**
       * synchronous {@link PathBase.readdir}
       */
      readdirSync() {
        if (!this.canReaddir()) {
          return [];
        }
        const children2 = this.children();
        if (this.calledReaddir()) {
          return children2.slice(0, children2.provisional);
        }
        const fullpath = this.fullpath();
        try {
          for (const e of this.#fs.readdirSync(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children2);
          }
          this.#readdirSuccess(children2);
        } catch (er) {
          this.#readdirFail(er.code);
          children2.provisional = 0;
        }
        return children2.slice(0, children2.provisional);
      }
      canReaddir() {
        if (this.#type & ENOCHILD)
          return false;
        const ifmt = IFMT & this.#type;
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
          return false;
        }
        return true;
      }
      shouldWalk(dirs, walkFilter) {
        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
      }
      /**
       * Return the Path object corresponding to path as resolved
       * by realpath(3).
       *
       * If the realpath call fails for any reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       * On success, returns a Path object.
       */
      async realpath() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = await this.#fs.promises.realpath(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Synchronous {@link realpath}
       */
      realpathSync() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = this.#fs.realpathSync(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Internal method to mark this Path object as the scurry cwd,
       * called by {@link PathScurry#chdir}
       *
       * @internal
       */
      [setAsCwd](oldCwd) {
        if (oldCwd === this)
          return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = /* @__PURE__ */ new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
          changed.add(p);
          p.#relative = rp.join(this.sep);
          p.#relativePosix = rp.join("/");
          p = p.parent;
          rp.push("..");
        }
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
          p.#relative = void 0;
          p.#relativePosix = void 0;
          p = p.parent;
        }
      }
    };
    exports2.PathBase = PathBase;
    var PathWin32 = class _PathWin32 extends PathBase {
      /**
       * Separator for generating path strings.
       */
      sep = "\\";
      /**
       * Separator for parsing path strings.
       */
      splitSep = eitherSep;
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root2, roots, nocase, children2, opts) {
        super(name, type, root2, roots, nocase, children2, opts);
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
      /**
       * @internal
       */
      getRootString(path11) {
        return node_path_1.win32.parse(path11).root;
      }
      /**
       * @internal
       */
      getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
          return this.root;
        }
        for (const [compare, root2] of Object.entries(this.roots)) {
          if (this.sameRoot(rootPath, compare)) {
            return this.roots[rootPath] = root2;
          }
        }
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
      }
      /**
       * @internal
       */
      sameRoot(rootPath, compare = this.root.name) {
        rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
        return rootPath === compare;
      }
    };
    exports2.PathWin32 = PathWin32;
    var PathPosix = class _PathPosix extends PathBase {
      /**
       * separator for parsing path strings
       */
      splitSep = "/";
      /**
       * separator for generating path strings
       */
      sep = "/";
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root2, roots, nocase, children2, opts) {
        super(name, type, root2, roots, nocase, children2, opts);
      }
      /**
       * @internal
       */
      getRootString(path11) {
        return path11.startsWith("/") ? "/" : "";
      }
      /**
       * @internal
       */
      getRoot(_rootPath) {
        return this.root;
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    };
    exports2.PathPosix = PathPosix;
    var PathScurryBase = class {
      /**
       * The root Path entry for the current working directory of this Scurry
       */
      root;
      /**
       * The string path for the root of this Scurry's current working directory
       */
      rootPath;
      /**
       * A collection of all roots encountered, referenced by rootPath
       */
      roots;
      /**
       * The Path entry corresponding to this PathScurry's current working directory.
       */
      cwd;
      #resolveCache;
      #resolvePosixCache;
      #children;
      /**
       * Perform path comparisons case-insensitively.
       *
       * Defaults true on Darwin and Windows systems, false elsewhere.
       */
      nocase;
      #fs;
      /**
       * This class should not be instantiated directly.
       *
       * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
       *
       * @internal
       */
      constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs: fs7 = defaultFS } = {}) {
        this.#fs = fsFromOption(fs7);
        if (cwd instanceof URL || cwd.startsWith("file://")) {
          cwd = (0, node_url_1.fileURLToPath)(cwd);
        }
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = /* @__PURE__ */ Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        if (split.length === 1 && !split[0]) {
          split.pop();
        }
        if (nocase === void 0) {
          throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        }
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
          const l = len--;
          prev = prev.child(part, {
            relative: new Array(l).fill("..").join(joinSep),
            relativePosix: new Array(l).fill("..").join("/"),
            fullpath: abs += (sawFirst ? "" : joinSep) + part
          });
          sawFirst = true;
        }
        this.cwd = prev;
      }
      /**
       * Get the depth of a provided path, string, or the cwd
       */
      depth(path11 = this.cwd) {
        if (typeof path11 === "string") {
          path11 = this.cwd.resolve(path11);
        }
        return path11.depth();
      }
      /**
       * Return the cache of child entries.  Exposed so subclasses can create
       * child Path objects in a platform-specific way.
       *
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Resolve one or more path strings to a resolved string
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolve(...paths) {
        let r = "";
        for (let i2 = paths.length - 1; i2 >= 0; i2--) {
          const p = paths[i2];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
      }
      /**
       * Resolve one or more path strings to a resolved string, returning
       * the posix path.  Identical to .resolve() on posix systems, but on
       * windows will return a forward-slash separated UNC path.
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolvePosix(...paths) {
        let r = "";
        for (let i2 = paths.length - 1; i2 >= 0; i2--) {
          const p = paths[i2];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
      }
      /**
       * find the relative path from the cwd to the supplied path string or entry
       */
      relative(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relative();
      }
      /**
       * find the relative path from the cwd to the supplied path string or
       * entry, using / as the path delimiter, even on Windows.
       */
      relativePosix(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
      }
      /**
       * Return the basename for the provided string or Path object
       */
      basename(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.name;
      }
      /**
       * Return the dirname for the provided string or Path object
       */
      dirname(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
      }
      async readdir(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else {
          const p = await entry.readdir();
          return withFileTypes ? p : p.map((e) => e.name);
        }
      }
      readdirSync(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else if (withFileTypes) {
          return entry.readdirSync();
        } else {
          return entry.readdirSync().map((e) => e.name);
        }
      }
      /**
       * Call lstat() on the string or Path object, and update all known
       * information that can be determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
      }
      /**
       * synchronous {@link PathScurryBase.lstat}
       */
      lstatSync(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
      }
      async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
      }
      readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
      }
      realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const walk = (dir, cb) => {
          dirs.add(dir);
          dir.readdirCB((er, entries) => {
            if (er) {
              return cb(er);
            }
            let len = entries.length;
            if (!len)
              return cb();
            const next = () => {
              if (--len === 0) {
                cb();
              }
            };
            for (const e of entries) {
              if (!filter || filter(e)) {
                results.push(withFileTypes ? e : e.fullpath());
              }
              if (follow && e.isSymbolicLink()) {
                e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
              } else {
                if (e.shouldWalk(dirs, walkFilter)) {
                  walk(e, next);
                } else {
                  next();
                }
              }
            }
          }, true);
        };
        const start = entry;
        return new Promise((res, rej) => {
          walk(start, (er) => {
            if (er)
              return rej(er);
            res(results);
          });
        });
      }
      walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
        return results;
      }
      /**
       * Support for `for await`
       *
       * Alias for {@link PathScurryBase.iterate}
       *
       * Note: As of Node 19, this is very slow, compared to other methods of
       * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
       * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
       */
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      iterate(entry = this.cwd, options = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          options = entry;
          entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
      }
      /**
       * Iterating over a PathScurry performs a synchronous walk.
       *
       * Alias for {@link PathScurryBase.iterateSync}
       */
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        if (!filter || filter(entry)) {
          yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              yield withFileTypes ? e : e.fullpath();
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
      }
      stream(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const onReaddir = (er, entries, didRealpaths = false) => {
              if (er)
                return results.emit("error", er);
              if (follow && !didRealpaths) {
                const promises = [];
                for (const e of entries) {
                  if (e.isSymbolicLink()) {
                    promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                  }
                }
                if (promises.length) {
                  Promise.all(promises).then(() => onReaddir(null, entries, true));
                  return;
                }
              }
              for (const e of entries) {
                if (e && (!filter || filter(e))) {
                  if (!results.write(withFileTypes ? e : e.fullpath())) {
                    paused = true;
                  }
                }
              }
              processing--;
              for (const e of entries) {
                const r = e.realpathCached() || e;
                if (r.shouldWalk(dirs, walkFilter)) {
                  queue.push(r);
                }
              }
              if (paused && !results.flowing) {
                results.once("drain", process2);
              } else if (!sync) {
                process2();
              }
            };
            let sync = true;
            dir.readdirCB(onReaddir, true);
            sync = false;
          }
        };
        process2();
        return results;
      }
      streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        const dirs = /* @__PURE__ */ new Set();
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const entries = dir.readdirSync();
            for (const e of entries) {
              if (!filter || filter(e)) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              let r = e;
              if (e.isSymbolicLink()) {
                if (!(follow && (r = e.realpathSync())))
                  continue;
                if (r.isUnknown())
                  r.lstatSync();
              }
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
          }
          if (paused && !results.flowing)
            results.once("drain", process2);
        };
        process2();
        return results;
      }
      chdir(path11 = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path11 === "string" ? this.cwd.resolve(path11) : path11;
        this.cwd[setAsCwd](oldCwd);
      }
    };
    exports2.PathScurryBase = PathScurryBase;
    var PathScurryWin32 = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "\\";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, node_path_1.win32, "\\", { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
          p.nocase = this.nocase;
        }
      }
      /**
       * @internal
       */
      parseRootPath(dir) {
        return node_path_1.win32.parse(dir).root.toUpperCase();
      }
      /**
       * @internal
       */
      newRoot(fs7) {
        return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs7 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
      }
    };
    exports2.PathScurryWin32 = PathScurryWin32;
    var PathScurryPosix = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "/";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, node_path_1.posix, "/", { ...opts, nocase });
        this.nocase = nocase;
      }
      /**
       * @internal
       */
      parseRootPath(_dir) {
        return "/";
      }
      /**
       * @internal
       */
      newRoot(fs7) {
        return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs7 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/");
      }
    };
    exports2.PathScurryPosix = PathScurryPosix;
    var PathScurryDarwin = class extends PathScurryPosix {
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
      }
    };
    exports2.PathScurryDarwin = PathScurryDarwin;
    exports2.Path = process.platform === "win32" ? PathWin32 : PathPosix;
    exports2.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
  }
});

// node_modules/glob/dist/commonjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/glob/dist/commonjs/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pattern = void 0;
    var minimatch_1 = require_commonjs();
    var isPatternList = (pl) => pl.length >= 1;
    var isGlobList = (gl) => gl.length >= 1;
    var Pattern = class _Pattern {
      #patternList;
      #globList;
      #index;
      length;
      #platform;
      #rest;
      #globString;
      #isDrive;
      #isUNC;
      #isAbsolute;
      #followGlobstar = true;
      constructor(patternList, globList, index, platform) {
        if (!isPatternList(patternList)) {
          throw new TypeError("empty pattern list");
        }
        if (!isGlobList(globList)) {
          throw new TypeError("empty glob list");
        }
        if (globList.length !== patternList.length) {
          throw new TypeError("mismatched pattern list and glob list lengths");
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
          throw new TypeError("index out of range");
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        if (this.#index === 0) {
          if (this.isUNC()) {
            const [p0, p1, p2, p3, ...prest] = this.#patternList;
            const [g0, g1, g2, g3, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = [p0, p1, p2, p3, ""].join("/");
            const g = [g0, g1, g2, g3, ""].join("/");
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          } else if (this.isDrive() || this.isAbsolute()) {
            const [p1, ...prest] = this.#patternList;
            const [g1, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = p1 + "/";
            const g = g1 + "/";
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          }
        }
      }
      /**
       * The first entry in the parsed list of patterns
       */
      pattern() {
        return this.#patternList[this.#index];
      }
      /**
       * true of if pattern() returns a string
       */
      isString() {
        return typeof this.#patternList[this.#index] === "string";
      }
      /**
       * true of if pattern() returns GLOBSTAR
       */
      isGlobstar() {
        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
      }
      /**
       * true if pattern() returns a regexp
       */
      isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
      }
      /**
       * The /-joined set of glob parts that make up this pattern
       */
      globString() {
        return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
      }
      /**
       * true if there are more pattern parts after this one
       */
      hasMore() {
        return this.length > this.#index + 1;
      }
      /**
       * The rest of the pattern after this part, or null if this is the end
       */
      rest() {
        if (this.#rest !== void 0)
          return this.#rest;
        if (!this.hasMore())
          return this.#rest = null;
        this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
      }
      /**
       * true if the pattern represents a //unc/path/ on windows
       */
      isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
      }
      // pattern like C:/...
      // split = ['C:', ...]
      // XXX: would be nice to handle patterns like `c:*` to test the cwd
      // in c: for *, but I don't know of a way to even figure out what that
      // cwd is without actually chdir'ing into it?
      /**
       * True if the pattern starts with a drive letter on Windows
       */
      isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
      }
      // pattern = '/' or '/...' or '/x/...'
      // split = ['', ''] or ['', ...] or ['', 'x', ...]
      // Drive and UNC both considered absolute on windows
      /**
       * True if the pattern is rooted on an absolute path
       */
      isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
      }
      /**
       * consume the root of the pattern, and return it
       */
      root() {
        const p = this.#patternList[0];
        return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
      }
      /**
       * Check to see if the current globstar pattern is allowed to follow
       * a symbolic link.
       */
      checkFollowGlobstar() {
        return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
      }
      /**
       * Mark that the current globstar pattern is following a symbolic link
       */
      markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
          return false;
        this.#followGlobstar = false;
        return true;
      }
    };
    exports2.Pattern = Pattern;
  }
});

// node_modules/glob/dist/commonjs/ignore.js
var require_ignore = __commonJS({
  "node_modules/glob/dist/commonjs/ignore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Ignore = void 0;
    var minimatch_1 = require_commonjs();
    var pattern_js_1 = require_pattern();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Ignore = class {
      relative;
      relativeChildren;
      absolute;
      absoluteChildren;
      platform;
      mmopts;
      constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
          dot: true,
          nobrace,
          nocase,
          noext,
          noglobstar,
          optimizationLevel: 2,
          platform,
          nocomment: true,
          nonegate: true
        };
        for (const ign of ignored)
          this.add(ign);
      }
      add(ign) {
        const mm = new minimatch_1.Minimatch(ign, this.mmopts);
        for (let i2 = 0; i2 < mm.set.length; i2++) {
          const parsed = mm.set[i2];
          const globParts = mm.globParts[i2];
          if (!parsed || !globParts) {
            throw new Error("invalid pattern object");
          }
          while (parsed[0] === "." && globParts[0] === ".") {
            parsed.shift();
            globParts.shift();
          }
          const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
          const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
          const children2 = globParts[globParts.length - 1] === "**";
          const absolute = p.isAbsolute();
          if (absolute)
            this.absolute.push(m);
          else
            this.relative.push(m);
          if (children2) {
            if (absolute)
              this.absoluteChildren.push(m);
            else
              this.relativeChildren.push(m);
          }
        }
      }
      ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || ".";
        const relatives = `${relative}/`;
        for (const m of this.relative) {
          if (m.match(relative) || m.match(relatives))
            return true;
        }
        for (const m of this.absolute) {
          if (m.match(fullpath) || m.match(fullpaths))
            return true;
        }
        return false;
      }
      childrenIgnored(p) {
        const fullpath = p.fullpath() + "/";
        const relative = (p.relative() || ".") + "/";
        for (const m of this.relativeChildren) {
          if (m.match(relative))
            return true;
        }
        for (const m of this.absoluteChildren) {
          if (m.match(fullpath))
            return true;
        }
        return false;
      }
    };
    exports2.Ignore = Ignore;
  }
});

// node_modules/glob/dist/commonjs/processor.js
var require_processor = __commonJS({
  "node_modules/glob/dist/commonjs/processor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Processor = exports2.SubWalks = exports2.MatchRecord = exports2.HasWalkedCache = void 0;
    var minimatch_1 = require_commonjs();
    var HasWalkedCache = class _HasWalkedCache {
      store;
      constructor(store = /* @__PURE__ */ new Map()) {
        this.store = store;
      }
      copy() {
        return new _HasWalkedCache(new Map(this.store));
      }
      hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
      }
      storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
          cached.add(pattern.globString());
        else
          this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
      }
    };
    exports2.HasWalkedCache = HasWalkedCache;
    var MatchRecord = class {
      store = /* @__PURE__ */ new Map();
      add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === void 0 ? n : n & current);
      }
      // match, absolute, ifdir
      entries() {
        return [...this.store.entries()].map(([path11, n]) => [
          path11,
          !!(n & 2),
          !!(n & 1)
        ]);
      }
    };
    exports2.MatchRecord = MatchRecord;
    var SubWalks = class {
      store = /* @__PURE__ */ new Map();
      add(target, pattern) {
        if (!target.canReaddir()) {
          return;
        }
        const subs = this.store.get(target);
        if (subs) {
          if (!subs.find((p) => p.globString() === pattern.globString())) {
            subs.push(pattern);
          }
        } else
          this.store.set(target, [pattern]);
      }
      get(target) {
        const subs = this.store.get(target);
        if (!subs) {
          throw new Error("attempting to walk unknown path");
        }
        return subs;
      }
      entries() {
        return this.keys().map((k) => [k, this.store.get(k)]);
      }
      keys() {
        return [...this.store.keys()].filter((t) => t.canReaddir());
      }
    };
    exports2.SubWalks = SubWalks;
    var Processor = class _Processor {
      hasWalkedCache;
      matches = new MatchRecord();
      subwalks = new SubWalks();
      patterns;
      follow;
      dot;
      opts;
      constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
      }
      processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map((p) => [target, p]);
        for (let [t, pattern] of processingSet) {
          this.hasWalkedCache.storeWalked(t, pattern);
          const root2 = pattern.root();
          const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
          if (root2) {
            t = t.resolve(root2 === "/" && this.opts.root !== void 0 ? this.opts.root : root2);
            const rest2 = pattern.rest();
            if (!rest2) {
              this.matches.add(t, true, false);
              continue;
            } else {
              pattern = rest2;
            }
          }
          if (t.isENOENT())
            continue;
          let p;
          let rest;
          let changed = false;
          while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
            const c2 = t.resolve(p);
            t = c2;
            pattern = rest;
            changed = true;
          }
          p = pattern.pattern();
          rest = pattern.rest();
          if (changed) {
            if (this.hasWalkedCache.hasWalked(t, pattern))
              continue;
            this.hasWalkedCache.storeWalked(t, pattern);
          }
          if (typeof p === "string") {
            const ifDir = p === ".." || p === "" || p === ".";
            this.matches.add(t.resolve(p), absolute, ifDir);
            continue;
          } else if (p === minimatch_1.GLOBSTAR) {
            if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
              this.subwalks.add(t, pattern);
            }
            const rp = rest?.pattern();
            const rrest = rest?.rest();
            if (!rest || (rp === "" || rp === ".") && !rrest) {
              this.matches.add(t, absolute, rp === "" || rp === ".");
            } else {
              if (rp === "..") {
                const tp = t.parent || t;
                if (!rrest)
                  this.matches.add(tp, absolute, true);
                else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                  this.subwalks.add(tp, rrest);
                }
              }
            }
          } else if (p instanceof RegExp) {
            this.subwalks.add(t, pattern);
          }
        }
        return this;
      }
      subwalkTargets() {
        return this.subwalks.keys();
      }
      child() {
        return new _Processor(this.opts, this.hasWalkedCache);
      }
      // return a new Processor containing the subwalks for each
      // child entry, and a set of matches, and
      // a hasWalkedCache that's a copy of this one
      // then we're going to call
      filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        const results = this.child();
        for (const e of entries) {
          for (const pattern of patterns) {
            const absolute = pattern.isAbsolute();
            const p = pattern.pattern();
            const rest = pattern.rest();
            if (p === minimatch_1.GLOBSTAR) {
              results.testGlobstar(e, pattern, rest, absolute);
            } else if (p instanceof RegExp) {
              results.testRegExp(e, p, rest, absolute);
            } else {
              results.testString(e, p, rest, absolute);
            }
          }
        }
        return results;
      }
      testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith(".")) {
          if (!pattern.hasMore()) {
            this.matches.add(e, absolute, false);
          }
          if (e.canReaddir()) {
            if (this.follow || !e.isSymbolicLink()) {
              this.subwalks.add(e, pattern);
            } else if (e.isSymbolicLink()) {
              if (rest && pattern.checkFollowGlobstar()) {
                this.subwalks.add(e, rest);
              } else if (pattern.markFollowGlobstar()) {
                this.subwalks.add(e, pattern);
              }
            }
          }
        }
        if (rest) {
          const rp = rest.pattern();
          if (typeof rp === "string" && // dots and empty were handled already
          rp !== ".." && rp !== "" && rp !== ".") {
            this.testString(e, rp, rest.rest(), absolute);
          } else if (rp === "..") {
            const ep = e.parent || e;
            this.subwalks.add(ep, rest);
          } else if (rp instanceof RegExp) {
            this.testRegExp(e, rp, rest.rest(), absolute);
          }
        }
      }
      testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
      testString(e, p, rest, absolute) {
        if (!e.isNamed(p))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
    };
    exports2.Processor = Processor;
  }
});

// node_modules/glob/dist/commonjs/walker.js
var require_walker = __commonJS({
  "node_modules/glob/dist/commonjs/walker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GlobStream = exports2.GlobWalker = exports2.GlobUtil = void 0;
    var minipass_1 = require_commonjs3();
    var ignore_js_1 = require_ignore();
    var processor_js_1 = require_processor();
    var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;
    var GlobUtil = class {
      path;
      patterns;
      opts;
      seen = /* @__PURE__ */ new Set();
      paused = false;
      aborted = false;
      #onResume = [];
      #ignore;
      #sep;
      signal;
      maxDepth;
      includeChildMatches;
      constructor(patterns, path11, opts) {
        this.patterns = patterns;
        this.path = path11;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
          this.#ignore = makeIgnore(opts.ignore ?? [], opts);
          if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
            const m = "cannot ignore child matches, ignore lacks add() method.";
            throw new Error(m);
          }
        }
        this.maxDepth = opts.maxDepth || Infinity;
        if (opts.signal) {
          this.signal = opts.signal;
          this.signal.addEventListener("abort", () => {
            this.#onResume.length = 0;
          });
        }
      }
      #ignored(path11) {
        return this.seen.has(path11) || !!this.#ignore?.ignored?.(path11);
      }
      #childrenIgnored(path11) {
        return !!this.#ignore?.childrenIgnored?.(path11);
      }
      // backpressure mechanism
      pause() {
        this.paused = true;
      }
      resume() {
        if (this.signal?.aborted)
          return;
        this.paused = false;
        let fn = void 0;
        while (!this.paused && (fn = this.#onResume.shift())) {
          fn();
        }
      }
      onResume(fn) {
        if (this.signal?.aborted)
          return;
        if (!this.paused) {
          fn();
        } else {
          this.#onResume.push(fn);
        }
      }
      // do the requisite realpath/stat checking, and return the path
      // to add or undefined to filter it out.
      async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || await e.realpath();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = await s.realpath();
          if (target && (target.isUnknown() || this.opts.stat)) {
            await target.lstat();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchCheckTest(e, ifDir) {
        return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
      }
      matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || e.realpathSync();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = s.realpathSync();
          if (target && (target?.isUnknown() || this.opts.stat)) {
            target.lstatSync();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchFinish(e, absolute) {
        if (this.#ignored(e))
          return;
        if (!this.includeChildMatches && this.#ignore?.add) {
          const ign = `${e.relativePosix()}/**`;
          this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
        if (this.opts.withFileTypes) {
          this.matchEmit(e);
        } else if (abs) {
          const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
          this.matchEmit(abs2 + mark);
        } else {
          const rel = this.opts.posix ? e.relativePosix() : e.relative();
          const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
          this.matchEmit(!rel ? "." + mark : pre + rel + mark);
        }
      }
      async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      walkCB(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const childrenCached = t.readdirCached();
          if (t.calledReaddir())
            this.walkCB3(t, childrenCached, processor, next);
          else {
            t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
          }
        }
        next();
      }
      walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2(target2, patterns, processor.child(), next);
        }
        next();
      }
      walkCBSync(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const children2 = t.readdirSync();
          this.walkCB3Sync(t, children2, processor, next);
        }
        next();
      }
      walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2Sync(target2, patterns, processor.child(), next);
        }
        next();
      }
    };
    exports2.GlobUtil = GlobUtil;
    var GlobWalker = class extends GlobUtil {
      matches = /* @__PURE__ */ new Set();
      constructor(patterns, path11, opts) {
        super(patterns, path11, opts);
      }
      matchEmit(e) {
        this.matches.add(e);
      }
      async walk() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          await this.path.lstat();
        }
        await new Promise((res, rej) => {
          this.walkCB(this.path, this.patterns, () => {
            if (this.signal?.aborted) {
              rej(this.signal.reason);
            } else {
              res(this.matches);
            }
          });
        });
        return this.matches;
      }
      walkSync() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            throw this.signal.reason;
        });
        return this.matches;
      }
    };
    exports2.GlobWalker = GlobWalker;
    var GlobStream = class extends GlobUtil {
      results;
      constructor(patterns, path11, opts) {
        super(patterns, path11, opts);
        this.results = new minipass_1.Minipass({
          signal: this.signal,
          objectMode: true
        });
        this.results.on("drain", () => this.resume());
        this.results.on("resume", () => this.resume());
      }
      matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
          this.pause();
      }
      stream() {
        const target = this.path;
        if (target.isUnknown()) {
          target.lstat().then(() => {
            this.walkCB(target, this.patterns, () => this.results.end());
          });
        } else {
          this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
      }
      streamSync() {
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
      }
    };
    exports2.GlobStream = GlobStream;
  }
});

// node_modules/glob/dist/commonjs/glob.js
var require_glob = __commonJS({
  "node_modules/glob/dist/commonjs/glob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Glob = void 0;
    var minimatch_1 = require_commonjs();
    var node_url_1 = require("url");
    var path_scurry_1 = require_commonjs4();
    var pattern_js_1 = require_pattern();
    var walker_js_1 = require_walker();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Glob = class {
      absolute;
      cwd;
      root;
      dot;
      dotRelative;
      follow;
      ignore;
      magicalBraces;
      mark;
      matchBase;
      maxDepth;
      nobrace;
      nocase;
      nodir;
      noext;
      noglobstar;
      pattern;
      platform;
      realpath;
      scurry;
      stat;
      signal;
      windowsPathsNoEscape;
      withFileTypes;
      includeChildMatches;
      /**
       * The options provided to the constructor.
       */
      opts;
      /**
       * An array of parsed immutable {@link Pattern} objects.
       */
      patterns;
      /**
       * All options are stored as properties on the `Glob` object.
       *
       * See {@link GlobOptions} for full options descriptions.
       *
       * Note that a previous `Glob` object can be passed as the
       * `GlobOptions` to another `Glob` instantiation to re-use settings
       * and caches with a new pattern.
       *
       * Traversal functions can be called multiple times to run the walk
       * again.
       */
      constructor(pattern, opts) {
        if (!opts)
          throw new TypeError("glob options required");
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
          this.cwd = "";
        } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
          opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
        }
        this.cwd = opts.cwd || "";
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== void 0) {
          throw new Error("cannot set absolute and withFileTypes:true");
        }
        if (typeof pattern === "string") {
          pattern = [pattern];
        }
        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          pattern = pattern.map((p) => p.replace(/\\/g, "/"));
        }
        if (this.matchBase) {
          if (opts.noglobstar) {
            throw new TypeError("base matching requires globstar");
          }
          pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
          this.scurry = opts.scurry;
          if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
            throw new Error("nocase option contradicts provided scurry option");
          }
        } else {
          const Scurry = opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;
          this.scurry = new Scurry(this.cwd, {
            nocase: opts.nocase,
            fs: opts.fs
          });
        }
        this.nocase = this.scurry.nocase;
        const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
        const mmo = {
          // default nocase based on platform
          ...opts,
          dot: this.dot,
          matchBase: this.matchBase,
          nobrace: this.nobrace,
          nocase: this.nocase,
          nocaseMagicOnly,
          nocomment: true,
          noext: this.noext,
          nonegate: true,
          optimizationLevel: 2,
          platform: this.platform,
          windowsPathsNoEscape: this.windowsPathsNoEscape,
          debug: !!this.opts.debug
        };
        const mms = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
          set[0].push(...m.set);
          set[1].push(...m.globParts);
          return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i2) => {
          const g = globParts[i2];
          if (!g)
            throw new Error("invalid pattern object");
          return new pattern_js_1.Pattern(set, g, 0, this.platform);
        });
      }
      async walk() {
        return [
          ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walk()
        ];
      }
      walkSync() {
        return [
          ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walkSync()
        ];
      }
      stream() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).stream();
      }
      streamSync() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).streamSync();
      }
      /**
       * Default sync iteration function. Returns a Generator that
       * iterates over the results.
       */
      iterateSync() {
        return this.streamSync()[Symbol.iterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      /**
       * Default async iteration function. Returns an AsyncGenerator that
       * iterates over the results.
       */
      iterate() {
        return this.stream()[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };
    exports2.Glob = Glob;
  }
});

// node_modules/glob/dist/commonjs/has-magic.js
var require_has_magic = __commonJS({
  "node_modules/glob/dist/commonjs/has-magic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMagic = void 0;
    var minimatch_1 = require_commonjs();
    var hasMagic = (pattern, options = {}) => {
      if (!Array.isArray(pattern)) {
        pattern = [pattern];
      }
      for (const p of pattern) {
        if (new minimatch_1.Minimatch(p, options).hasMagic())
          return true;
      }
      return false;
    };
    exports2.hasMagic = hasMagic;
  }
});

// node_modules/glob/dist/commonjs/index.js
var require_commonjs5 = __commonJS({
  "node_modules/glob/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.glob = exports2.sync = exports2.iterate = exports2.iterateSync = exports2.stream = exports2.streamSync = exports2.Ignore = exports2.hasMagic = exports2.Glob = exports2.unescape = exports2.escape = void 0;
    exports2.globStreamSync = globStreamSync;
    exports2.globStream = globStream;
    exports2.globSync = globSync;
    exports2.globIterateSync = globIterateSync;
    exports2.globIterate = globIterate;
    var minimatch_1 = require_commonjs();
    var glob_js_1 = require_glob();
    var has_magic_js_1 = require_has_magic();
    var minimatch_2 = require_commonjs();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return minimatch_2.escape;
    } });
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return minimatch_2.unescape;
    } });
    var glob_js_2 = require_glob();
    Object.defineProperty(exports2, "Glob", { enumerable: true, get: function() {
      return glob_js_2.Glob;
    } });
    var has_magic_js_2 = require_has_magic();
    Object.defineProperty(exports2, "hasMagic", { enumerable: true, get: function() {
      return has_magic_js_2.hasMagic;
    } });
    var ignore_js_1 = require_ignore();
    Object.defineProperty(exports2, "Ignore", { enumerable: true, get: function() {
      return ignore_js_1.Ignore;
    } });
    function globStreamSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).streamSync();
    }
    function globStream(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).stream();
    }
    function globSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walkSync();
    }
    async function glob_(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walk();
    }
    function globIterateSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterateSync();
    }
    function globIterate(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterate();
    }
    exports2.streamSync = globStreamSync;
    exports2.stream = Object.assign(globStream, { sync: globStreamSync });
    exports2.iterateSync = globIterateSync;
    exports2.iterate = Object.assign(globIterate, {
      sync: globIterateSync
    });
    exports2.sync = Object.assign(globSync, {
      stream: globStreamSync,
      iterate: globIterateSync
    });
    exports2.glob = Object.assign(glob_, {
      glob: glob_,
      globSync,
      sync: exports2.sync,
      globStream,
      stream: exports2.stream,
      globStreamSync,
      streamSync: exports2.streamSync,
      globIterate,
      iterate: exports2.iterate,
      globIterateSync,
      iterateSync: exports2.iterateSync,
      Glob: glob_js_1.Glob,
      hasMagic: has_magic_js_1.hasMagic,
      escape: minimatch_1.escape,
      unescape: minimatch_1.unescape
    });
    exports2.glob.glob = exports2.glob;
  }
});

// node_modules/@expo/config-plugins/build/utils/modules.js
var require_modules = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/modules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.directoryExistsAsync = directoryExistsAsync;
    exports2.fileExists = fileExists;
    exports2.fileExistsAsync = fileExistsAsync;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    async function statAsync(file) {
      try {
        return await _fs().default.promises.stat(file);
      } catch {
        return null;
      }
    }
    async function fileExistsAsync(file) {
      return (await statAsync(file))?.isFile() ?? false;
    }
    async function directoryExistsAsync(file) {
      return (await statAsync(file))?.isDirectory() ?? false;
    }
    function fileExists(file) {
      try {
        return _fs().default.statSync(file).isFile();
      } catch {
        return false;
      }
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Paths.js
var require_Paths = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Paths.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAndroidManifestAsync = getAndroidManifestAsync;
    exports2.getAppBuildGradleAsync = getAppBuildGradleAsync;
    exports2.getAppBuildGradleFilePath = getAppBuildGradleFilePath;
    exports2.getFileInfo = getFileInfo;
    exports2.getGradleFilePath = getGradleFilePath;
    exports2.getMainActivityAsync = getMainActivityAsync;
    exports2.getMainApplicationAsync = getMainApplicationAsync;
    exports2.getProjectBuildGradleAsync = getProjectBuildGradleAsync;
    exports2.getProjectBuildGradleFilePath = getProjectBuildGradleFilePath;
    exports2.getProjectFilePath = getProjectFilePath;
    exports2.getProjectPathOrThrowAsync = getProjectPathOrThrowAsync;
    exports2.getResourceFolderAsync = getResourceFolderAsync;
    exports2.getResourceXMLPathAsync = getResourceXMLPathAsync;
    exports2.getSettingsGradleAsync = getSettingsGradleAsync;
    exports2.getSettingsGradleFilePath = getSettingsGradleFilePath;
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _glob() {
      const data = require_commonjs5();
      _glob = function() {
        return data;
      };
      return data;
    }
    function path11() {
      const data = _interopRequireWildcard(require("path"));
      path11 = function() {
        return data;
      };
      return data;
    }
    function _errors() {
      const data = require_errors();
      _errors = function() {
        return data;
      };
      return data;
    }
    function _modules() {
      const data = require_modules();
      _modules = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function getProjectFilePath(projectRoot, name) {
      const filePath = (0, _glob().globSync)(`android/app/src/main/java/**/${name}.@(java|kt)`, {
        cwd: projectRoot,
        absolute: true
      })[0];
      (0, _assert().default)(filePath, `Project file "${name}" does not exist in android project for root "${projectRoot}"`);
      return filePath;
    }
    function getLanguage(filePath) {
      const extension = path11().extname(filePath);
      switch (extension) {
        case ".java":
          return "java";
        case ".kts":
        case ".kt":
          return "kt";
        case ".groovy":
        case ".gradle":
          return "groovy";
        default:
          throw new (_errors()).UnexpectedError(`Unexpected Android file extension: ${extension}`);
      }
    }
    function getFileInfo(filePath) {
      return {
        path: path11().normalize(filePath),
        contents: _fs().default.readFileSync(filePath, "utf8"),
        language: getLanguage(filePath)
      };
    }
    async function getMainApplicationAsync(projectRoot) {
      const filePath = getProjectFilePath(projectRoot, "MainApplication");
      return getFileInfo(filePath);
    }
    async function getMainActivityAsync(projectRoot) {
      const filePath = getProjectFilePath(projectRoot, "MainActivity");
      return getFileInfo(filePath);
    }
    function getGradleFilePath(projectRoot, gradleName) {
      const groovyPath = path11().resolve(projectRoot, `${gradleName}.gradle`);
      const ktPath = path11().resolve(projectRoot, `${gradleName}.gradle.kts`);
      const isGroovy = _fs().default.existsSync(groovyPath);
      const isKotlin = !isGroovy && _fs().default.existsSync(ktPath);
      if (!isGroovy && !isKotlin) {
        throw new Error(`Failed to find '${gradleName}.gradle' file for project: ${projectRoot}.`);
      }
      const filePath = isGroovy ? groovyPath : ktPath;
      return filePath;
    }
    function getProjectBuildGradleFilePath(projectRoot) {
      return getGradleFilePath(path11().join(projectRoot, "android"), "build");
    }
    async function getProjectBuildGradleAsync(projectRoot) {
      return getFileInfo(getProjectBuildGradleFilePath(projectRoot));
    }
    function getSettingsGradleFilePath(projectRoot) {
      return getGradleFilePath(path11().join(projectRoot, "android"), "settings");
    }
    async function getSettingsGradleAsync(projectRoot) {
      return getFileInfo(getSettingsGradleFilePath(projectRoot));
    }
    function getAppBuildGradleFilePath(projectRoot) {
      return getGradleFilePath(path11().join(projectRoot, "android", "app"), "build");
    }
    async function getAppBuildGradleAsync(projectRoot) {
      return getFileInfo(getAppBuildGradleFilePath(projectRoot));
    }
    async function getProjectPathOrThrowAsync(projectRoot) {
      const projectPath = path11().join(projectRoot, "android");
      if (await (0, _modules().directoryExistsAsync)(projectPath)) {
        return projectPath;
      }
      throw new Error(`Android project folder is missing in project: ${projectRoot}`);
    }
    async function getAndroidManifestAsync(projectRoot) {
      const projectPath = await getProjectPathOrThrowAsync(projectRoot);
      const filePath = path11().join(projectPath, "app/src/main/AndroidManifest.xml");
      return filePath;
    }
    async function getResourceFolderAsync(projectRoot) {
      const projectPath = await getProjectPathOrThrowAsync(projectRoot);
      return path11().join(projectPath, `app/src/main/res`);
    }
    async function getResourceXMLPathAsync(projectRoot, {
      kind = "values",
      name
    }) {
      const resourcePath = await getResourceFolderAsync(projectRoot);
      const filePath = path11().join(resourcePath, `${kind}/${name}.xml`);
      return filePath;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Resources.js
var require_Resources = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Resources.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildResourceGroup = buildResourceGroup;
    exports2.buildResourceItem = buildResourceItem;
    exports2.ensureDefaultResourceXML = ensureDefaultResourceXML;
    exports2.findResourceGroup = findResourceGroup;
    exports2.getObjectAsResourceGroup = getObjectAsResourceGroup;
    exports2.getObjectAsResourceItems = getObjectAsResourceItems;
    exports2.getResourceItemsAsObject = getResourceItemsAsObject;
    exports2.readResourcesXMLAsync = readResourcesXMLAsync;
    function _XML() {
      const data = require_XML();
      _XML = function() {
        return data;
      };
      return data;
    }
    var fallbackResourceString = `<?xml version="1.0" encoding="utf-8"?><resources></resources>`;
    async function readResourcesXMLAsync({
      path: path11,
      fallback = fallbackResourceString
    }) {
      const xml = await (0, _XML().readXMLAsync)({
        path: path11,
        fallback
      });
      if (!xml.resources) {
        xml.resources = {};
      }
      return xml;
    }
    function ensureDefaultResourceXML(xml) {
      if (!xml) {
        xml = {
          resources: {}
        };
      }
      if (!xml.resources) {
        xml.resources = {};
      }
      return xml;
    }
    function buildResourceItem({
      name,
      value,
      targetApi,
      translatable
    }) {
      const item = {
        $: {
          name
        },
        _: value
      };
      if (targetApi) {
        item.$["tools:targetApi"] = targetApi;
      }
      if (translatable !== void 0) {
        item.$["translatable"] = String(translatable);
      }
      return item;
    }
    function buildResourceGroup(parent) {
      return {
        $: {
          name: parent.name,
          parent: parent.parent
        },
        item: parent.items ?? []
      };
    }
    function findResourceGroup(xml, group) {
      const app = xml?.filter?.(({
        $: head
      }) => {
        let matches = head.name === group.name;
        if (group.parent != null && matches) {
          matches = head.parent === group.parent;
        }
        return matches;
      })?.[0];
      return app ?? null;
    }
    function getResourceItemsAsObject(xml) {
      return xml.reduce((prev, curr) => ({
        ...prev,
        [curr.$.name]: curr._
      }), {});
    }
    function getObjectAsResourceItems(obj) {
      return Object.entries(obj).map(([name, value]) => ({
        $: {
          name
        },
        _: value
      }));
    }
    function getObjectAsResourceGroup(group) {
      return {
        $: {
          name: group.name,
          parent: group.parent
        },
        item: getObjectAsResourceItems(group.item)
      };
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Colors.js
var require_Colors = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Colors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assignColorValue = assignColorValue;
    exports2.getColorsAsObject = getColorsAsObject;
    exports2.getObjectAsColorsXml = getObjectAsColorsXml;
    exports2.getProjectColorsXMLPathAsync = getProjectColorsXMLPathAsync;
    exports2.removeColorItem = removeColorItem;
    exports2.setColorItem = setColorItem;
    function _Paths() {
      const data = require_Paths();
      _Paths = function() {
        return data;
      };
      return data;
    }
    function _Resources() {
      const data = require_Resources();
      _Resources = function() {
        return data;
      };
      return data;
    }
    function getProjectColorsXMLPathAsync(projectRoot, {
      kind
    } = {}) {
      return (0, _Paths().getResourceXMLPathAsync)(projectRoot, {
        kind,
        name: "colors"
      });
    }
    function setColorItem(itemToAdd, colorFileContentsJSON) {
      if (colorFileContentsJSON.resources?.color) {
        const colorNameExists = colorFileContentsJSON.resources.color.filter((e) => e.$.name === itemToAdd.$.name)[0];
        if (colorNameExists) {
          colorNameExists._ = itemToAdd._;
        } else {
          colorFileContentsJSON.resources.color.push(itemToAdd);
        }
      } else {
        if (!colorFileContentsJSON.resources || typeof colorFileContentsJSON.resources === "string") {
          colorFileContentsJSON.resources = {};
        }
        colorFileContentsJSON.resources.color = [itemToAdd];
      }
      return colorFileContentsJSON;
    }
    function removeColorItem(named, contents) {
      if (contents.resources?.color) {
        const index = contents.resources.color.findIndex((e) => e.$.name === named);
        if (index > -1) {
          contents.resources.color.splice(index, 1);
        }
      }
      return contents;
    }
    function assignColorValue(xml, {
      value,
      name
    }) {
      if (value) {
        return setColorItem((0, _Resources().buildResourceItem)({
          name,
          value
        }), xml);
      }
      return removeColorItem(name, xml);
    }
    function getColorsAsObject(xml) {
      if (!xml?.resources?.color) {
        return null;
      }
      return (0, _Resources().getResourceItemsAsObject)(xml.resources.color);
    }
    function getObjectAsColorsXml(obj) {
      return {
        resources: {
          color: (0, _Resources().getObjectAsResourceItems)(obj)
        }
      };
    }
  }
});

// node_modules/@expo/config-plugins/build/android/EasBuildGradleScript.js
var require_EasBuildGradleScript = __commonJS({
  "node_modules/@expo/config-plugins/build/android/EasBuildGradleScript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = exports2.default = `// Build integration with EAS

import java.nio.file.Paths

android {
  signingConfigs {
    release {
      // This is necessary to avoid needing the user to define a release signing config manually
      // If no release config is defined, and this is not present, build for assembleRelease will crash
    }
  }

  buildTypes {
    release {
      // This is necessary to avoid needing the user to define a release build type manually
    }
  }
}

def isEasBuildConfigured = false

tasks.whenTaskAdded {
  def debug = gradle.startParameter.taskNames.any { it.toLowerCase().contains('debug') }

  if (debug) {
    return
  }

  // We only need to configure EAS build once
  if (isEasBuildConfigured) {
    return
  }

  isEasBuildConfigured = true;

  android.signingConfigs.release {
    def credentialsJson = rootProject.file("../credentials.json");

    if (credentialsJson.exists()) {
      if (storeFile && !System.getenv("EAS_BUILD")) {
        println("Path to release keystore file is already set, ignoring 'credentials.json'")
      } else {
        try {
          def credentials = new groovy.json.JsonSlurper().parse(credentialsJson)
          def keystorePath = Paths.get(credentials.android.keystore.keystorePath);
          def storeFilePath = keystorePath.isAbsolute()
            ? keystorePath
            : rootProject.file("..").toPath().resolve(keystorePath);

          storeFile storeFilePath.toFile()
          storePassword credentials.android.keystore.keystorePassword
          keyAlias credentials.android.keystore.keyAlias
          if (credentials.android.keystore.containsKey("keyPassword")) {
            keyPassword credentials.android.keystore.keyPassword
          } else {
            // key password is required by Gradle, but PKCS keystores don't have one
            // using the keystore password seems to satisfy the requirement
            keyPassword credentials.android.keystore.keystorePassword
          }
        } catch (Exception e) {
          println("An error occurred while parsing 'credentials.json': " + e.message)
        }
      }
    } else {
      if (storeFile == null) {
        println("Couldn't find a 'credentials.json' file, skipping release keystore configuration")
      }
    }
  }

  android.buildTypes.release {
    signingConfig android.signingConfigs.release
  }
}
`;
  }
});

// node_modules/@expo/config-plugins/build/android/EasBuild.js
var require_EasBuild = __commonJS({
  "node_modules/@expo/config-plugins/build/android/EasBuild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.configureEasBuildAsync = configureEasBuildAsync;
    exports2.getEasBuildGradlePath = getEasBuildGradlePath;
    exports2.isEasBuildGradleConfiguredAsync = isEasBuildGradleConfiguredAsync;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _EasBuildGradleScript() {
      const data = _interopRequireDefault(require_EasBuildGradleScript());
      _EasBuildGradleScript = function() {
        return data;
      };
      return data;
    }
    function Paths() {
      const data = _interopRequireWildcard(require_Paths());
      Paths = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var APPLY_EAS_GRADLE = 'apply from: "./eas-build.gradle"';
    function hasApplyLine(content, applyLine) {
      return content.replace(/\r\n/g, "\n").split("\n").some((line2) => line2 === applyLine || line2 === applyLine.replace(/"/g, "'"));
    }
    function getEasBuildGradlePath(projectRoot) {
      return _path().default.join(projectRoot, "android", "app", "eas-build.gradle");
    }
    async function configureEasBuildAsync(projectRoot) {
      const buildGradlePath = Paths().getAppBuildGradleFilePath(projectRoot);
      const easGradlePath = getEasBuildGradlePath(projectRoot);
      await _fs().default.promises.writeFile(easGradlePath, _EasBuildGradleScript().default);
      const buildGradleContent = await _fs().default.promises.readFile(_path().default.join(buildGradlePath), "utf8");
      const hasEasGradleApply = hasApplyLine(buildGradleContent, APPLY_EAS_GRADLE);
      if (!hasEasGradleApply) {
        await _fs().default.promises.writeFile(buildGradlePath, `${buildGradleContent.trim()}
${APPLY_EAS_GRADLE}
`);
      }
    }
    async function isEasBuildGradleConfiguredAsync(projectRoot) {
      const buildGradlePath = Paths().getAppBuildGradleFilePath(projectRoot);
      const easGradlePath = getEasBuildGradlePath(projectRoot);
      const hasEasGradleFile = await _fs().default.existsSync(easGradlePath);
      const buildGradleContent = await _fs().default.promises.readFile(_path().default.join(buildGradlePath), "utf8");
      const hasEasGradleApply = hasApplyLine(buildGradleContent, APPLY_EAS_GRADLE);
      return hasEasGradleApply && hasEasGradleFile;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/GoogleMapsApiKey.js
var require_GoogleMapsApiKey = __commonJS({
  "node_modules/@expo/config-plugins/build/android/GoogleMapsApiKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getGoogleMapsApiKey = getGoogleMapsApiKey;
    exports2.setGoogleMapsApiKey = setGoogleMapsApiKey;
    exports2.withGoogleMapsApiKey = void 0;
    function _Manifest() {
      const data = require_Manifest();
      _Manifest = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    var META_API_KEY = "com.google.android.geo.API_KEY";
    var LIB_HTTP = "org.apache.http.legacy";
    var withGoogleMapsApiKey = exports2.withGoogleMapsApiKey = (0, _androidPlugins().createAndroidManifestPlugin)(setGoogleMapsApiKey, "withGoogleMapsApiKey");
    function getGoogleMapsApiKey(config) {
      return config.android?.config?.googleMaps?.apiKey ?? null;
    }
    function setGoogleMapsApiKey(config, androidManifest) {
      const apiKey = getGoogleMapsApiKey(config);
      const mainApplication = (0, _Manifest().getMainApplicationOrThrow)(androidManifest);
      if (apiKey) {
        (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, META_API_KEY, apiKey);
        (0, _Manifest().addUsesLibraryItemToMainApplication)(mainApplication, {
          name: LIB_HTTP,
          required: false
        });
      } else {
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, META_API_KEY);
        (0, _Manifest().removeUsesLibraryItemFromMainApplication)(mainApplication, LIB_HTTP);
      }
      return androidManifest;
    }
  }
});

// node_modules/@expo/config-plugins/build/plugins/withDangerousMod.js
var require_withDangerousMod = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/withDangerousMod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.withDangerousMod = void 0;
    function _withMod() {
      const data = require_withMod();
      _withMod = function() {
        return data;
      };
      return data;
    }
    var withDangerousMod5 = (config, [platform, action]) => {
      return (0, _withMod().withMod)(config, {
        platform,
        mod: "dangerous",
        action
      });
    };
    exports2.withDangerousMod = withDangerousMod5;
  }
});

// node_modules/@expo/config-plugins/build/utils/fs.js
var require_fs = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.copyFilePathToPathAsync = copyFilePathToPathAsync;
    exports2.removeFile = removeFile;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    async function copyFilePathToPathAsync(src, dest) {
      const srcFile = await _fs().default.promises.readFile(src);
      await _fs().default.promises.mkdir(_path().default.dirname(dest), {
        recursive: true
      });
      await _fs().default.promises.writeFile(dest, srcFile);
    }
    function removeFile(filePath) {
      try {
        _fs().default.unlinkSync(filePath);
        return true;
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
  }
});

// node_modules/@expo/config-plugins/build/utils/warnings.js
var require_warnings = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/warnings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addWarningAndroid = addWarningAndroid;
    exports2.addWarningForPlatform = addWarningForPlatform;
    exports2.addWarningIOS = addWarningIOS;
    function _chalk() {
      const data = _interopRequireDefault(require_source());
      _chalk = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function addWarningAndroid(property, text, link) {
      console.warn(formatWarning("android", property, text, link));
    }
    function addWarningIOS(property, text, link) {
      console.warn(formatWarning("ios", property, text, link));
    }
    function addWarningForPlatform(platform, property, text, link) {
      console.warn(formatWarning(platform, property, text, link));
    }
    function formatWarning(platform, property, warning, link) {
      return _chalk().default.yellow`${"\xBB " + _chalk().default.bold(platform)}: ${property}: ${warning}${link ? _chalk().default.gray(" " + link) : ""}`;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/GoogleServices.js
var require_GoogleServices = __commonJS({
  "node_modules/@expo/config-plugins/build/android/GoogleServices.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.applyPlugin = applyPlugin;
    exports2.getGoogleServicesFilePath = getGoogleServicesFilePath;
    exports2.setClassPath = setClassPath;
    exports2.setGoogleServicesFile = setGoogleServicesFile;
    exports2.withGoogleServicesFile = exports2.withClassPath = exports2.withApplyPlugin = void 0;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    function _withDangerousMod() {
      const data = require_withDangerousMod();
      _withDangerousMod = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = require_fs();
      _fs = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var DEFAULT_TARGET_PATH = "./android/app/google-services.json";
    var googleServicesClassPath = "com.google.gms:google-services";
    var googleServicesPlugin = "com.google.gms.google-services";
    var googleServicesVersion = "4.4.1";
    var withClassPath = (config) => {
      return (0, _androidPlugins().withProjectBuildGradle)(config, (config2) => {
        if (config2.modResults.language === "groovy") {
          config2.modResults.contents = setClassPath(config2, config2.modResults.contents);
        } else {
          (0, _warnings().addWarningAndroid)("android.googleServicesFile", `Cannot automatically configure project build.gradle if it's not groovy`);
        }
        return config2;
      });
    };
    exports2.withClassPath = withClassPath;
    var withApplyPlugin = (config) => {
      return (0, _androidPlugins().withAppBuildGradle)(config, (config2) => {
        if (config2.modResults.language === "groovy") {
          config2.modResults.contents = applyPlugin(config2, config2.modResults.contents);
        } else {
          (0, _warnings().addWarningAndroid)("android.googleServicesFile", `Cannot automatically configure app build.gradle if it's not groovy`);
        }
        return config2;
      });
    };
    exports2.withApplyPlugin = withApplyPlugin;
    var withGoogleServicesFile = (config) => {
      return (0, _withDangerousMod().withDangerousMod)(config, ["android", async (config2) => {
        await setGoogleServicesFile(config2, config2.modRequest.projectRoot);
        return config2;
      }]);
    };
    exports2.withGoogleServicesFile = withGoogleServicesFile;
    function getGoogleServicesFilePath(config) {
      return config.android?.googleServicesFile ?? null;
    }
    async function setGoogleServicesFile(config, projectRoot, targetPath = DEFAULT_TARGET_PATH) {
      const partialSourcePath = getGoogleServicesFilePath(config);
      if (!partialSourcePath) {
        return false;
      }
      const completeSourcePath = _path().default.resolve(projectRoot, partialSourcePath);
      const destinationPath = _path().default.resolve(projectRoot, targetPath);
      try {
        await (0, _fs().copyFilePathToPathAsync)(completeSourcePath, destinationPath);
      } catch (e) {
        console.log(e);
        throw new Error(`Cannot copy google-services.json from ${completeSourcePath} to ${destinationPath}. Ensure the source and destination paths exist.`);
      }
      return true;
    }
    function setClassPath(config, buildGradle) {
      const googleServicesFile = getGoogleServicesFilePath(config);
      if (!googleServicesFile) {
        return buildGradle;
      }
      if (buildGradle.includes(googleServicesClassPath)) {
        return buildGradle;
      }
      return buildGradle.replace(/dependencies\s?{/, `dependencies {
        classpath '${googleServicesClassPath}:${googleServicesVersion}'`);
    }
    function applyPlugin(config, appBuildGradle) {
      const googleServicesFile = getGoogleServicesFilePath(config);
      if (!googleServicesFile) {
        return appBuildGradle;
      }
      const pattern = new RegExp(`apply\\s+plugin:\\s+['"]${googleServicesPlugin}['"]`);
      if (appBuildGradle.match(pattern)) {
        return appBuildGradle;
      }
      return appBuildGradle + `
apply plugin: '${googleServicesPlugin}'`;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/IntentFilters.js
var require_IntentFilters = __commonJS({
  "node_modules/@expo/config-plugins/build/android/IntentFilters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = renderIntentFilters;
    exports2.getIntentFilters = getIntentFilters;
    exports2.setAndroidIntentFilters = setAndroidIntentFilters;
    exports2.withAndroidIntentFilters = void 0;
    function _Manifest() {
      const data = require_Manifest();
      _Manifest = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    var GENERATED_TAG = "data-generated";
    var withAndroidIntentFilters = exports2.withAndroidIntentFilters = (0, _androidPlugins().createAndroidManifestPlugin)(setAndroidIntentFilters, "withAndroidIntentFilters");
    function getIntentFilters(config) {
      return config.android?.intentFilters ?? [];
    }
    function setAndroidIntentFilters(config, androidManifest) {
      const mainActivity = (0, _Manifest().getMainActivityOrThrow)(androidManifest);
      if (mainActivity["intent-filter"]?.length) {
        mainActivity["intent-filter"] = mainActivity["intent-filter"].filter((value) => value.$?.[GENERATED_TAG] !== "true");
      }
      const intentFilters = getIntentFilters(config);
      if (!intentFilters.length) {
        return androidManifest;
      }
      mainActivity["intent-filter"] = mainActivity["intent-filter"]?.concat(renderIntentFilters(intentFilters));
      return androidManifest;
    }
    function renderIntentFilters(intentFilters) {
      return intentFilters.map((intentFilter) => {
        return {
          $: {
            "android:autoVerify": intentFilter.autoVerify ? "true" : void 0,
            // Add a custom "generated" tag that we can query later to remove.
            [GENERATED_TAG]: "true"
          },
          action: [
            // <action android:name="android.intent.action.VIEW"/>
            {
              $: {
                "android:name": `android.intent.action.${intentFilter.action}`
              }
            }
          ],
          data: renderIntentFilterData(intentFilter.data),
          category: renderIntentFilterCategory(intentFilter.category)
        };
      });
    }
    function renderIntentFilterData(data) {
      return (Array.isArray(data) ? data : [data]).filter(Boolean).map((datum) => ({
        $: Object.entries(datum ?? {}).reduce((prev, [key3, value]) => ({
          ...prev,
          [`android:${key3}`]: value
        }), {})
      }));
    }
    function renderIntentFilterCategory(category) {
      return (Array.isArray(category) ? category : [category]).filter(Boolean).map((cat) => ({
        $: {
          "android:name": `android.intent.category.${cat}`
        }
      }));
    }
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match) {
      var token2 = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1]) token2.type = "string", token2.closed = !!(match[3] || match[4]);
      else if (match[5]) token2.type = "comment";
      else if (match[6]) token2.type = "comment", token2.closed = !!match[7];
      else if (match[8]) token2.type = "regex";
      else if (match[9]) token2.type = "number";
      else if (match[10]) token2.type = "name";
      else if (match[11]) token2.type = "punctuator";
      else if (match[12]) token2.type = "whitespace";
      return token2;
    };
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos2 = 65536;
      for (let i2 = 0, length = set.length; i2 < length; i2 += 2) {
        pos2 += set[i2];
        if (pos2 > code) return false;
        pos2 += set[i2 + 1];
        if (pos2 >= code) return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65) return code === 36;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48) return code === 36;
      if (code < 58) return true;
      if (code < 65) return false;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i2 = 0; i2 < name.length; i2++) {
        let cp = name.charCodeAt(i2);
        if ((cp & 64512) === 55296 && i2 + 1 < name.length) {
          const trail = name.charCodeAt(++i2);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isKeyword = isKeyword;
    exports2.isReservedWord = isReservedWord;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/picocolors/picocolors.js"(exports2, module2) {
    "use strict";
    var p = process || {};
    var argv = p.argv || [];
    var env = p.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/color-convert/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color-convert/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    "use strict";
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key3 in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key3)) {
        reverseKeywords[cssKeywords[key3]] = key3;
      }
    }
    var key3;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c2) {
        return (v - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c2;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c2 = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c2 * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i2 = 0; i2 < 3; i2++) {
        t3 = h + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i2;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i2 = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i2;
      if ((i2 & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i2) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c2 = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c2 * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c2;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c2 = Math.sqrt(a * a + b * b);
      return [l, c2, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c2 = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c2 * Math.cos(hr);
      b = c2 * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c2 = 1;
      var f = 0;
      if (l < 0.5) {
        c2 = 2 * s * l;
      } else {
        c2 = 2 * s * (1 - l);
      }
      if (c2 < 1) {
        f = (l - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c2 = s * v;
      var f = 0;
      if (c2 < 1) {
        f = (v - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c2 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c2) * g;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c2 + g * (1 - c2);
      var f = 0;
      if (v > 0) {
        f = c2 / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c2) + 0.5 * c2;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c2 / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c2 / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c2 + g * (1 - c2);
      return [hcg[0], (v - c2) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c2 = v - w;
      var g = 0;
      if (c2 < 1) {
        g = (v - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions2();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i2 = 0; i2 < len; i2++) {
        graph[models[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i2 = 0; i2 < len; i2++) {
          var adjacent = adjacents[i2];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path11 = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path11.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path11;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i2 = 0; i2 < len; i2++) {
        var toModel = models[i2];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i2 = 0; i2 < len; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var colorConvert = require_color_convert2();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key3 of Object.keys(colorConvert)) {
        if (typeof colorConvert[key3] !== "object") {
          continue;
        }
        const suite = colorConvert[key3];
        if (key3 === "ansi16") {
          key3 = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key3] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key3] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key3] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key3] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key3] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key3] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/@babel/highlight/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos2 = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos2 !== -1 && (terminatorPos === -1 ? true : pos2 < terminatorPos);
    };
  }
});

// node_modules/@babel/highlight/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag2();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/templates.js
var require_templates2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c2) {
      if (c2[0] === "u" && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
        return String.fromCharCode(parseInt(c2.slice(1), 16));
      }
      return ESCAPES.get(c2) || c2;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, chr) => escape2 ? unescape2(escape2) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape2(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles2();
    var stdoutColor = require_supports_color2().stdout;
    var template = require_templates2();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key3 of Object.keys(ansiStyles)) {
      ansiStyles[key3].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key3].close), "g");
      styles[key3] = {
        get() {
          const codes = ansiStyles[key3];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key3);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key3) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self.level;
        },
        set(level) {
          self.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self.enabled;
        },
        set(enabled) {
          self.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key3 === "gray" || key3 === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i2 = 1; i2 < strings.length; i2++) {
        parts.push(String(args[i2 - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i2]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/highlight/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/highlight/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = highlight;
    exports2.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib();
    var _picocolors = _interopRequireWildcard(require_picocolors(), true);
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    var colors = typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, _picocolors.createColors)(false) : _picocolors.default;
    var compose = (f, g) => (v) => f(g(v));
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(colors2) {
      return {
        keyword: colors2.cyan,
        capitalized: colors2.yellow,
        jsxIdentifier: colors2.yellow,
        punctuator: colors2.yellow,
        number: colors2.magenta,
        string: colors2.green,
        regex: colors2.magenta,
        comment: colors2.gray,
        invalid: compose(compose(colors2.white, colors2.bgRed), colors2.bold)
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token2, offset, text) {
        if (token2.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token2.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token2.value, true) || sometimesKeywords.has(token2.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token2.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
            return "jsxIdentifier";
          }
          if (token2.value[0] !== token2.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token2.type === "punctuator" && BRACKET.test(token2.value)) {
          return "bracket";
        }
        if (token2.type === "invalid" && (token2.value === "@" || token2.value === "#")) {
          return "punctuator";
        }
        return token2.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = _jsTokens.default.exec(text)) {
          const token2 = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token2, match.index, text),
            value: token2.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        const colorize = defs[type];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return colors.isColorSupported || options.forceColor;
    }
    var pcWithForcedColor = void 0;
    function getColors(forceColor) {
      if (forceColor) {
        var _pcWithForcedColor;
        (_pcWithForcedColor = pcWithForcedColor) != null ? _pcWithForcedColor : pcWithForcedColor = (0, _picocolors.createColors)(true);
        return pcWithForcedColor;
      }
      return colors;
    }
    function highlight(code, options = {}) {
      if (code !== "" && shouldHighlight(options)) {
        const defs = getDefs(getColors(options.forceColor));
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
    {
      let chalk, chalkWithForcedColor;
      exports2.getChalk = ({
        forceColor
      }) => {
        var _chalk;
        (_chalk = chalk) != null ? _chalk : chalk = require_chalk();
        if (forceColor) {
          var _chalkWithForcedColor;
          (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new chalk.constructor({
            enabled: true,
            level: 1
          });
          return chalkWithForcedColor;
        }
        return chalk;
      };
    }
  }
});

// node_modules/@expo/json-file/node_modules/@babel/code-frame/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@expo/json-file/node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.codeFrameColumns = codeFrameColumns;
    exports2.default = _default;
    var _highlight = _interopRequireWildcard(require_lib2());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key3 in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key3)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key3) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key3, desc);
          } else {
            newObj[key3] = obj[key3];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var deprecationWarningShown = false;
    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source2, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source2.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source2.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i2 = 0; i2 <= lineDiff; i2++) {
          const lineNumber = i2 + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i2 === 0) {
            const sourceLength = source2[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i2 === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source2[lineNumber - i2].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk = (0, _highlight.getChalk)(opts);
      const defs = getDefs(chalk);
      const maybeHighlight = (chalkFn, string) => {
        return highlighted ? chalkFn(string) : string;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE).slice(start, end).map((line2, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} | `;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line2.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line2, markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line2}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});

// node_modules/json5/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  default: () => dist_default
});
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        const key3 = String(i2);
        const replacement = internalize(value, key3, reviver);
        if (replacement === void 0) {
          delete value[key3];
        } else {
          Object.defineProperty(value, key3, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    } else {
      for (const key3 in value) {
        const replacement = internalize(value, key3, reviver);
        if (replacement === void 0) {
          delete value[key3];
        } else {
          Object.defineProperty(value, key3, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    }
  }
  return reviver.call(holder, name, value);
}
function lex() {
  lexState = "default";
  buffer = "";
  doubleQuote = false;
  sign = 1;
  for (; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2) {
      return token2;
    }
  }
}
function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}
function read() {
  const c2 = peek();
  if (c2 === "\n") {
    line++;
    column = 0;
  } else if (c2) {
    column += c2.length;
  } else {
    column++;
  }
  if (c2) {
    pos += c2.length;
  }
  return c2;
}
function newToken(type, value) {
  return {
    type,
    value,
    line,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    const p = peek();
    if (p !== c2) {
      throw invalidChar(read());
    }
    read();
  }
}
function escape() {
  const c2 = peek();
  switch (c2) {
    case "b":
      read();
      return "\b";
    case "f":
      read();
      return "\f";
    case "n":
      read();
      return "\n";
    case "r":
      read();
      return "\r";
    case "t":
      read();
      return "	";
    case "v":
      read();
      return "\v";
    case "0":
      read();
      if (util.isDigit(peek())) {
        throw invalidChar(read());
      }
      return "\0";
    case "x":
      read();
      return hexEscape();
    case "u":
      read();
      return unicodeEscape();
    case "\n":
    case "\u2028":
    case "\u2029":
      read();
      return "";
    case "\r":
      read();
      if (peek() === "\n") {
        read();
      }
      return "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "";
  let c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "";
  let count = 4;
  while (count-- > 0) {
    const c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0) {
    root = value;
  } else {
    const parent = stack[stack.length - 1];
    if (Array.isArray(parent)) {
      parent.push(value);
    } else {
      Object.defineProperty(parent, key2, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  if (value !== null && typeof value === "object") {
    stack.push(value);
    if (Array.isArray(value)) {
      parseState = "beforeArrayValue";
    } else {
      parseState = "beforePropertyName";
    }
  } else {
    const current = stack[stack.length - 1];
    if (current == null) {
      parseState = "end";
    } else if (Array.isArray(current)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  if (current == null) {
    parseState = "end";
  } else if (Array.isArray(current)) {
    parseState = "afterArrayValue";
  } else {
    parseState = "afterPropertyValue";
  }
}
function invalidChar(c2) {
  if (c2 === void 0) {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  }
  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  column -= 5;
  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2]) {
    return replacements[c2];
  }
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}
var Space_Separator, ID_Start, ID_Continue, unicode, util, source, parseState, stack, pos, line, column, token, key2, root, parse, lexState, buffer, doubleQuote, sign, c, lexStates, parseStates, stringify, JSON5, lib, dist_default;
var init_dist = __esm({
  "node_modules/json5/dist/index.mjs"() {
    "use strict";
    Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
    unicode = {
      Space_Separator,
      ID_Start,
      ID_Continue
    };
    util = {
      isSpaceSeparator(c2) {
        return typeof c2 === "string" && unicode.Space_Separator.test(c2);
      },
      isIdStartChar(c2) {
        return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
      },
      isIdContinueChar(c2) {
        return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
      },
      isDigit(c2) {
        return typeof c2 === "string" && /[0-9]/.test(c2);
      },
      isHexDigit(c2) {
        return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
      }
    };
    parse = function parse2(text, reviver) {
      source = String(text);
      parseState = "start";
      stack = [];
      pos = 0;
      line = 1;
      column = 0;
      token = void 0;
      key2 = void 0;
      root = void 0;
      do {
        token = lex();
        parseStates[parseState]();
      } while (token.type !== "eof");
      if (typeof reviver === "function") {
        return internalize({ "": root }, "", reviver);
      }
      return root;
    };
    lexStates = {
      default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read();
            lexState = "comment";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        if (util.isSpaceSeparator(c)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineComment";
            return;
          case "/":
            read();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read();
            return;
          case "/":
            read();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
        lexState = "multiLineComment";
      },
      singleLineComment() {
        switch (c) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            lexState = "default";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        read();
      },
      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            read();
            literal("ull");
            return newToken("null", null);
          case "t":
            read();
            literal("rue");
            return newToken("boolean", true);
          case "f":
            read();
            literal("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read() === "-") {
              sign = -1;
            }
            lexState = "sign";
            return;
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read();
            lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      sign() {
        switch (c) {
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", sign * Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read();
            lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger() {
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal() {
        if (util.isHexDigit(c)) {
          buffer += read();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger() {
        if (util.isHexDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string() {
        switch (c) {
          case "\\":
            read();
            buffer += escape();
            return;
          case '"':
            if (doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "'":
            if (!doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read();
            lexState = "identifierName";
            return;
          case "\\":
            read();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"';
            lexState = "string";
            return;
        }
        if (util.isIdStartChar(c)) {
          buffer += read();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName() {
        if (c === ":") {
          return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue() {
        if (c === "]") {
          return newToken("punctuator", read());
        }
        lexState = "value";
      },
      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end() {
        throw invalidChar(read());
      }
    };
    parseStates = {
      start() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key2 = token.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        parseState = "beforePropertyValue";
      },
      beforePropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforeArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push();
      },
      afterPropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end() {
      }
    };
    stringify = function stringify2(value, replacer, space) {
      const stack2 = [];
      let indent = "";
      let propertyList;
      let replacerFunc;
      let gap = "";
      let quote;
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
      }
      if (typeof replacer === "function") {
        replacerFunc = replacer;
      } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer) {
          let item;
          if (typeof v === "string") {
            item = v;
          } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
            item = String(v);
          }
          if (item !== void 0 && propertyList.indexOf(item) < 0) {
            propertyList.push(item);
          }
        }
      }
      if (space instanceof Number) {
        space = Number(space);
      } else if (space instanceof String) {
        space = String(space);
      }
      if (typeof space === "number") {
        if (space > 0) {
          space = Math.min(10, Math.floor(space));
          gap = "          ".substr(0, space);
        }
      } else if (typeof space === "string") {
        gap = space.substr(0, 10);
      }
      return serializeProperty("", { "": value });
      function serializeProperty(key3, holder) {
        let value2 = holder[key3];
        if (value2 != null) {
          if (typeof value2.toJSON5 === "function") {
            value2 = value2.toJSON5(key3);
          } else if (typeof value2.toJSON === "function") {
            value2 = value2.toJSON(key3);
          }
        }
        if (replacerFunc) {
          value2 = replacerFunc.call(holder, key3, value2);
        }
        if (value2 instanceof Number) {
          value2 = Number(value2);
        } else if (value2 instanceof String) {
          value2 = String(value2);
        } else if (value2 instanceof Boolean) {
          value2 = value2.valueOf();
        }
        switch (value2) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof value2 === "string") {
          return quoteString(value2, false);
        }
        if (typeof value2 === "number") {
          return String(value2);
        }
        if (typeof value2 === "object") {
          return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
        }
        return void 0;
      }
      function quoteString(value2) {
        const quotes = {
          "'": 0.1,
          '"': 0.2
        };
        const replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        let product = "";
        for (let i2 = 0; i2 < value2.length; i2++) {
          const c2 = value2[i2];
          switch (c2) {
            case "'":
            case '"':
              quotes[c2]++;
              product += c2;
              continue;
            case "\0":
              if (util.isDigit(value2[i2 + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[c2]) {
            product += replacements[c2];
            continue;
          }
          if (c2 < " ") {
            let hexString = c2.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c2;
        }
        const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
      }
      function serializeObject(value2) {
        if (stack2.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack2.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let keys = propertyList || Object.keys(value2);
        let partial = [];
        for (const key3 of keys) {
          const propertyString = serializeProperty(key3, value2);
          if (propertyString !== void 0) {
            let member = serializeKey(key3) + ":";
            if (gap !== "") {
              member += " ";
            }
            member += propertyString;
            partial.push(member);
          }
        }
        let final;
        if (partial.length === 0) {
          final = "{}";
        } else {
          let properties;
          if (gap === "") {
            properties = partial.join(",");
            final = "{" + properties + "}";
          } else {
            let separator = ",\n" + indent;
            properties = partial.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }
        stack2.pop();
        indent = stepback;
        return final;
      }
      function serializeKey(key3) {
        if (key3.length === 0) {
          return quoteString(key3, true);
        }
        const firstChar = String.fromCodePoint(key3.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
          return quoteString(key3, true);
        }
        for (let i2 = firstChar.length; i2 < key3.length; i2++) {
          if (!util.isIdContinueChar(String.fromCodePoint(key3.codePointAt(i2)))) {
            return quoteString(key3, true);
          }
        }
        return key3;
      }
      function serializeArray(value2) {
        if (stack2.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack2.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let partial = [];
        for (let i2 = 0; i2 < value2.length; i2++) {
          const propertyString = serializeProperty(String(i2), value2);
          partial.push(propertyString !== void 0 ? propertyString : "null");
        }
        let final;
        if (partial.length === 0) {
          final = "[]";
        } else {
          if (gap === "") {
            let properties = partial.join(",");
            final = "[" + properties + "]";
          } else {
            let separator = ",\n" + indent;
            let properties = partial.join(separator);
            final = "[\n" + indent + properties + ",\n" + stepback + "]";
          }
        }
        stack2.pop();
        indent = stepback;
        return final;
      }
    };
    JSON5 = {
      parse,
      stringify
    };
    lib = JSON5;
    dist_default = lib;
  }
});

// node_modules/@expo/json-file/build/JsonFileError.js
var require_JsonFileError = __commonJS({
  "node_modules/@expo/json-file/build/JsonFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmptyJsonFileError = void 0;
    var JsonFileError = class extends Error {
      cause;
      code;
      fileName;
      isJsonFileError;
      constructor(message, cause, code, fileName) {
        let fullMessage = message;
        if (fileName) {
          fullMessage += `
${cause ? "\u251C" : "\u2514"}\u2500 File: ${fileName}`;
        }
        if (cause) {
          fullMessage += `
\u2514\u2500 Cause: ${cause.name}: ${cause.message}`;
        }
        super(fullMessage);
        this.name = this.constructor.name;
        this.cause = cause;
        this.code = code;
        this.fileName = fileName;
        this.isJsonFileError = true;
      }
    };
    exports2.default = JsonFileError;
    var EmptyJsonFileError = class extends JsonFileError {
      constructor(fileName) {
        super(`Cannot parse an empty JSON string`, void 0, "EJSONEMPTY", fileName);
      }
    };
    exports2.EmptyJsonFileError = EmptyJsonFileError;
  }
});

// node_modules/@expo/json-file/build/writeAtomic.js
var require_writeAtomic = __commonJS({
  "node_modules/@expo/json-file/build/writeAtomic.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.writeFileAtomicSync = writeFileAtomicSync;
    exports2.writeFileAtomic = writeFileAtomic;
    var node_crypto_1 = require("crypto");
    var fs7 = __importStar(require("fs"));
    function getTarget(filename, data) {
      const hash = (0, node_crypto_1.createHash)("sha256").update(data).digest("base64url");
      return `${filename}.${hash}`;
    }
    function writeFileAtomicSync(filename, data) {
      const tmpfile = getTarget(filename, data);
      fs7.writeFileSync(tmpfile, data);
      fs7.renameSync(tmpfile, filename);
    }
    async function writeFileAtomic(filename, data) {
      const tmpfile = getTarget(filename, data);
      await fs7.promises.writeFile(tmpfile, data);
      await fs7.promises.rename(tmpfile, filename);
    }
  }
});

// node_modules/@expo/json-file/build/JsonFile.js
var require_JsonFile = __commonJS({
  "node_modules/@expo/json-file/build/JsonFile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_frame_1 = require_lib3();
    var json5_1 = __importDefault((init_dist(), __toCommonJS(dist_exports)));
    var node_fs_1 = __importDefault(require("fs"));
    var node_path_1 = __importDefault(require("path"));
    var JsonFileError_1 = __importStar(require_JsonFileError());
    var writeAtomic_1 = require_writeAtomic();
    var DEFAULT_OPTIONS2 = {
      badJsonDefault: void 0,
      jsonParseErrorDefault: void 0,
      cantReadFileDefault: void 0,
      ensureDir: false,
      default: void 0,
      json5: false,
      space: 2,
      addNewLineAtEOF: true
    };
    var JsonFile = class {
      file;
      options;
      static read = read2;
      static readAsync = readAsync;
      static parseJsonString = parseJsonString;
      static write = write;
      static writeAsync = writeAsync;
      static get = getSync;
      static getAsync = getAsync;
      static set = setSync;
      static setAsync = setAsync;
      static merge = merge;
      static mergeAsync = mergeAsync;
      static deleteKey = deleteKey;
      static deleteKeyAsync = deleteKeyAsync;
      static deleteKeys = deleteKeys;
      static deleteKeysAsync = deleteKeysAsync;
      static rewrite = rewrite;
      static rewriteAsync = rewriteAsync;
      constructor(file, options = {}) {
        this.file = file;
        this.options = options;
      }
      read(options) {
        return read2(this.file, this._getOptions(options));
      }
      async readAsync(options) {
        return readAsync(this.file, this._getOptions(options));
      }
      write(object, options) {
        return write(this.file, object, this._getOptions(options));
      }
      async writeAsync(object, options) {
        return writeAsync(this.file, object, this._getOptions(options));
      }
      parseJsonString(json, options) {
        return parseJsonString(json, options);
      }
      get(key3, defaultValue, options) {
        return getSync(this.file, key3, defaultValue, this._getOptions(options));
      }
      async getAsync(key3, defaultValue, options) {
        return getAsync(this.file, key3, defaultValue, this._getOptions(options));
      }
      set(key3, value, options) {
        return setSync(this.file, key3, value, this._getOptions(options));
      }
      async setAsync(key3, value, options) {
        return setAsync(this.file, key3, value, this._getOptions(options));
      }
      async merge(sources, options) {
        return merge(this.file, sources, this._getOptions(options));
      }
      async mergeAsync(sources, options) {
        return mergeAsync(this.file, sources, this._getOptions(options));
      }
      deleteKey(key3, options) {
        return deleteKey(this.file, key3, this._getOptions(options));
      }
      async deleteKeyAsync(key3, options) {
        return deleteKeyAsync(this.file, key3, this._getOptions(options));
      }
      deleteKeys(keys, options) {
        return deleteKeys(this.file, keys, this._getOptions(options));
      }
      async deleteKeysAsync(keys, options) {
        return deleteKeysAsync(this.file, keys, this._getOptions(options));
      }
      rewrite(options) {
        return rewrite(this.file, this._getOptions(options));
      }
      async rewriteAsync(options) {
        return rewriteAsync(this.file, this._getOptions(options));
      }
      _getOptions(options) {
        return {
          ...this.options,
          ...options
        };
      }
    };
    exports2.default = JsonFile;
    function read2(file, options) {
      let json;
      try {
        json = node_fs_1.default.readFileSync(file, "utf8");
      } catch (error) {
        assertEmptyJsonString(json, file);
        const defaultValue = cantReadFileDefault(options);
        if (defaultValue === void 0) {
          throw new JsonFileError_1.default(`Can't read JSON file: ${file}`, error, error.code, file);
        } else {
          return defaultValue;
        }
      }
      return parseJsonString(json, options, file);
    }
    async function readAsync(file, options) {
      let json;
      try {
        json = await node_fs_1.default.promises.readFile(file, "utf8");
      } catch (error) {
        assertEmptyJsonString(json, file);
        const defaultValue = cantReadFileDefault(options);
        if (defaultValue === void 0) {
          throw new JsonFileError_1.default(`Can't read JSON file: ${file}`, error, error.code);
        } else {
          return defaultValue;
        }
      }
      return parseJsonString(json, options);
    }
    function parseJsonString(json, options, fileName) {
      assertEmptyJsonString(json, fileName);
      try {
        if (_getOption(options, "json5")) {
          return json5_1.default.parse(json);
        } else {
          return JSON.parse(json);
        }
      } catch (e) {
        const defaultValue = jsonParseErrorDefault(options);
        if (defaultValue === void 0) {
          const location = locationFromSyntaxError(e, json);
          if (location) {
            const codeFrame = (0, code_frame_1.codeFrameColumns)(json, { start: location });
            e.codeFrame = codeFrame;
            e.message += `
${codeFrame}`;
          }
          throw new JsonFileError_1.default(`Error parsing JSON: ${json}`, e, "EJSONPARSE", fileName);
        } else {
          return defaultValue;
        }
      }
    }
    function getSync(file, key3, defaultValue, options) {
      const object = read2(file, options);
      if (key3 in object) {
        return object[key3];
      }
      if (defaultValue === void 0) {
        throw new JsonFileError_1.default(`No value at key path "${String(key3)}" in JSON object from: ${file}`);
      }
      return defaultValue;
    }
    async function getAsync(file, key3, defaultValue, options) {
      const object = await readAsync(file, options);
      if (key3 in object) {
        return object[key3];
      }
      if (defaultValue === void 0) {
        throw new JsonFileError_1.default(`No value at key path "${String(key3)}" in JSON object from: ${file}`);
      }
      return defaultValue;
    }
    function write(file, object, options) {
      if (options?.ensureDir) {
        node_fs_1.default.mkdirSync(node_path_1.default.dirname(file), { recursive: true });
      }
      const space = _getOption(options, "space");
      const json5 = _getOption(options, "json5");
      const addNewLineAtEOF = _getOption(options, "addNewLineAtEOF");
      let json;
      try {
        if (json5) {
          json = json5_1.default.stringify(object, null, space);
        } else {
          json = JSON.stringify(object, null, space);
        }
      } catch (e) {
        throw new JsonFileError_1.default(`Couldn't JSON.stringify object for file: ${file}`, e);
      }
      const data = addNewLineAtEOF ? `${json}
` : json;
      (0, writeAtomic_1.writeFileAtomicSync)(file, data);
      return object;
    }
    async function writeAsync(file, object, options) {
      if (options?.ensureDir) {
        await node_fs_1.default.promises.mkdir(node_path_1.default.dirname(file), { recursive: true });
      }
      const space = _getOption(options, "space");
      const json5 = _getOption(options, "json5");
      const addNewLineAtEOF = _getOption(options, "addNewLineAtEOF");
      let json;
      try {
        if (json5) {
          json = json5_1.default.stringify(object, null, space);
        } else {
          json = JSON.stringify(object, null, space);
        }
      } catch (e) {
        throw new JsonFileError_1.default(`Couldn't JSON.stringify object for file: ${file}`, e);
      }
      const data = addNewLineAtEOF ? `${json}
` : json;
      await (0, writeAtomic_1.writeFileAtomic)(file, data);
      return object;
    }
    function setSync(file, key3, value, options) {
      const object = read2(file, options);
      return write(file, { ...object, [key3]: value }, options);
    }
    async function setAsync(file, key3, value, options) {
      const object = await readAsync(file, options);
      return writeAsync(file, { ...object, [key3]: value }, options);
    }
    async function mergeAsync(file, sources, options) {
      const object = await readAsync(file, options);
      if (Array.isArray(sources)) {
        Object.assign(object, ...sources);
      } else {
        Object.assign(object, sources);
      }
      return writeAsync(file, object, options);
    }
    function merge(file, sources, options) {
      const object = read2(file, options);
      if (Array.isArray(sources)) {
        Object.assign(object, ...sources);
      } else {
        Object.assign(object, sources);
      }
      return write(file, object, options);
    }
    async function deleteKeyAsync(file, key3, options) {
      return deleteKeysAsync(file, [key3], options);
    }
    function deleteKey(file, key3, options) {
      return deleteKeys(file, [key3], options);
    }
    async function deleteKeysAsync(file, keys, options) {
      const object = await readAsync(file, options);
      let didDelete = false;
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key3 = keys[i2];
        if (object.hasOwnProperty(key3)) {
          delete object[key3];
          didDelete = true;
        }
      }
      if (didDelete) {
        return writeAsync(file, object, options);
      }
      return object;
    }
    function deleteKeys(file, keys, options) {
      const object = read2(file, options);
      let didDelete = false;
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key3 = keys[i2];
        if (object.hasOwnProperty(key3)) {
          delete object[key3];
          didDelete = true;
        }
      }
      if (didDelete) {
        return write(file, object, options);
      }
      return object;
    }
    async function rewriteAsync(file, options) {
      const object = await readAsync(file, options);
      return writeAsync(file, object, options);
    }
    function rewrite(file, options) {
      return write(file, read2(file, options), options);
    }
    function jsonParseErrorDefault(options = {}) {
      if (options.jsonParseErrorDefault === void 0) {
        return options.default;
      } else {
        return options.jsonParseErrorDefault;
      }
    }
    function cantReadFileDefault(options = {}) {
      if (options.cantReadFileDefault === void 0) {
        return options.default;
      } else {
        return options.cantReadFileDefault;
      }
    }
    function _getOption(options, field) {
      if (options) {
        if (options[field] !== void 0) {
          return options[field];
        }
      }
      return DEFAULT_OPTIONS2[field];
    }
    function locationFromSyntaxError(error, sourceString) {
      if ("lineNumber" in error && "columnNumber" in error) {
        return { line: error.lineNumber, column: error.columnNumber };
      }
      const match = /at position (\d+)/.exec(error.message);
      if (match) {
        const index = parseInt(match[1], 10);
        const lines = sourceString.slice(0, index + 1).split("\n");
        return { line: lines.length, column: lines[lines.length - 1].length };
      }
      return null;
    }
    function assertEmptyJsonString(json, file) {
      if (json?.trim() === "") {
        throw new JsonFileError_1.EmptyJsonFileError(file);
      }
    }
  }
});

// node_modules/@expo/config-plugins/build/utils/locales.js
var require_locales = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/locales.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getResolvedLocalesAsync = getResolvedLocalesAsync;
    function _jsonFile() {
      const data = _interopRequireDefault(require_JsonFile());
      _jsonFile = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    async function getResolvedLocalesAsync(projectRoot, input, forPlatform) {
      const locales = {};
      for (const [lang, localeJsonPath] of Object.entries(input)) {
        let locale = null;
        if (typeof localeJsonPath === "string") {
          try {
            locale = await _jsonFile().default.readAsync(_path().default.join(projectRoot, localeJsonPath));
          } catch {
            (0, _warnings().addWarningForPlatform)(forPlatform, `locales.${lang}`, `Failed to parse JSON of locale file for language: ${lang}`, "https://docs.expo.dev/guides/localization/#translating-app-metadata");
          }
        } else {
          locale = localeJsonPath;
        }
        if (locale) {
          const {
            android,
            ios,
            ...rest
          } = {
            android: {},
            ios: {},
            ...locale
          };
          if (forPlatform === "ios") {
            locales[lang] = {
              ...rest,
              ...ios
            };
          } else {
            locales[lang] = {
              ...rest,
              ...android
            };
          }
        }
      }
      return locales;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Locales.js
var require_Locales = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Locales.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getLocales = getLocales;
    exports2.setLocalesAsync = setLocalesAsync;
    exports2.withLocales = void 0;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _() {
      const data = require_build4();
      _ = function() {
        return data;
      };
      return data;
    }
    function _XML() {
      const data = require_XML();
      _XML = function() {
        return data;
      };
      return data;
    }
    function _locales() {
      const data = require_locales();
      _locales = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var withLocales = (config) => {
      return (0, _().withDangerousMod)(config, ["android", async (config2) => {
        config2.modResults = await setLocalesAsync(config2, {
          projectRoot: config2.modRequest.projectRoot
        });
        return config2;
      }]);
    };
    exports2.withLocales = withLocales;
    function getLocales(config) {
      return config.locales ?? null;
    }
    async function setLocalesAsync(config, {
      projectRoot
    }) {
      const locales = getLocales(config);
      if (!locales) {
        return config;
      }
      const localesMap = await (0, _locales().getResolvedLocalesAsync)(projectRoot, locales, "android");
      for (const [lang, localizationObj] of Object.entries(localesMap)) {
        const stringsFilePath = _path().default.join(await _().AndroidConfig.Paths.getResourceFolderAsync(projectRoot), `values-b+${lang.replaceAll("-", "+")}`, "strings.xml");
        (0, _XML().writeXMLAsync)({
          path: stringsFilePath,
          xml: {
            resources: Object.entries(localizationObj).map(([k, v]) => ({
              string: {
                $: {
                  name: k
                },
                _: `"${v}"`
              }
            }))
          }
        });
      }
      return config;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Strings.js
var require_Strings = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Strings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getProjectStringsXMLPathAsync = getProjectStringsXMLPathAsync;
    exports2.removeStringItem = removeStringItem;
    exports2.setStringItem = setStringItem;
    function _Paths() {
      const data = require_Paths();
      _Paths = function() {
        return data;
      };
      return data;
    }
    async function getProjectStringsXMLPathAsync(projectRoot, {
      kind
    } = {}) {
      return (0, _Paths().getResourceXMLPathAsync)(projectRoot, {
        kind,
        name: "strings"
      });
    }
    function setStringItem(itemToAdd, stringFileContentsJSON) {
      if (!stringFileContentsJSON?.resources?.string) {
        if (!stringFileContentsJSON.resources || typeof stringFileContentsJSON.resources === "string") {
          stringFileContentsJSON.resources = {};
        }
        stringFileContentsJSON.resources.string = itemToAdd;
        return stringFileContentsJSON;
      }
      for (const newItem of itemToAdd) {
        const stringNameExists = stringFileContentsJSON.resources.string.findIndex((e) => e.$.name === newItem.$.name);
        if (stringNameExists > -1) {
          stringFileContentsJSON.resources.string[stringNameExists] = newItem;
        } else {
          stringFileContentsJSON.resources.string = stringFileContentsJSON.resources.string.concat(newItem);
        }
      }
      return stringFileContentsJSON;
    }
    function removeStringItem(named, stringFileContentsJSON) {
      if (stringFileContentsJSON?.resources?.string) {
        const stringNameExists = stringFileContentsJSON.resources.string.findIndex((e) => e.$.name === named);
        if (stringNameExists > -1) {
          stringFileContentsJSON.resources.string.splice(stringNameExists, 1);
        }
      }
      return stringFileContentsJSON;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Name.js
var require_Name = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Name.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.applyNameSettingsGradle = applyNameSettingsGradle;
    exports2.getName = getName;
    exports2.sanitizeNameForGradle = sanitizeNameForGradle;
    exports2.withNameSettingsGradle = exports2.withName = void 0;
    function _Resources() {
      const data = require_Resources();
      _Resources = function() {
        return data;
      };
      return data;
    }
    function _Strings() {
      const data = require_Strings();
      _Strings = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    function sanitizeNameForGradle(name) {
      name = name.replace(/[\n\r\t]/g, "");
      return name.replace(/(\/|\\|:|<|>|"|\?|\*|\|)/g, "");
    }
    var withName = exports2.withName = (0, _androidPlugins().createStringsXmlPlugin)(applyNameFromConfig, "withName");
    var withNameSettingsGradle = (config) => {
      return (0, _androidPlugins().withSettingsGradle)(config, (config2) => {
        if (config2.modResults.language === "groovy") {
          config2.modResults.contents = applyNameSettingsGradle(config2, config2.modResults.contents);
        } else {
          (0, _warnings().addWarningAndroid)("name", `Cannot automatically configure settings.gradle if it's not groovy`);
        }
        return config2;
      });
    };
    exports2.withNameSettingsGradle = withNameSettingsGradle;
    function getName(config) {
      return typeof config.name === "string" ? config.name : null;
    }
    function applyNameFromConfig(config, stringsJSON) {
      const name = getName(config);
      if (name) {
        return (0, _Strings().setStringItem)([(0, _Resources().buildResourceItem)({
          name: "app_name",
          value: name
        })], stringsJSON);
      }
      return (0, _Strings().removeStringItem)("app_name", stringsJSON);
    }
    function applyNameSettingsGradle(config, settingsGradle) {
      const name = sanitizeNameForGradle(getName(config) ?? "");
      return settingsGradle.replace(/rootProject.name\s?=\s?(["'])(?:(?=(\\?))\2.)*?\1/g, `rootProject.name = '${name.replace(/'/g, "\\'")}'`);
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Orientation.js
var require_Orientation = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Orientation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SCREEN_ORIENTATION_ATTRIBUTE = void 0;
    exports2.getOrientation = getOrientation;
    exports2.setAndroidOrientation = setAndroidOrientation;
    exports2.withOrientation = void 0;
    function _Manifest() {
      const data = require_Manifest();
      _Manifest = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    var SCREEN_ORIENTATION_ATTRIBUTE = exports2.SCREEN_ORIENTATION_ATTRIBUTE = "android:screenOrientation";
    var withOrientation = exports2.withOrientation = (0, _androidPlugins().createAndroidManifestPlugin)(setAndroidOrientation, "withOrientation");
    function getOrientation(config) {
      return typeof config.orientation === "string" ? config.orientation : null;
    }
    function setAndroidOrientation(config, androidManifest) {
      const orientation = getOrientation(config);
      if (!orientation) {
        return androidManifest;
      }
      const mainActivity = (0, _Manifest().getMainActivityOrThrow)(androidManifest);
      mainActivity.$[SCREEN_ORIENTATION_ATTRIBUTE] = orientation !== "default" ? orientation : "unspecified";
      return androidManifest;
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key3) => {
        createDebug[key3] = env[key3];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key3) => {
      return /^debug_/i.test(key3);
    }).reduce((obj, key3) => {
      const prop = key3.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key3];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Package.js
var require_Package = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Package.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getApplicationIdAsync = getApplicationIdAsync;
    exports2.getPackage = getPackage;
    exports2.kotlinSanitized = kotlinSanitized;
    exports2.renameJniOnDiskForType = renameJniOnDiskForType;
    exports2.renamePackageOnDisk = renamePackageOnDisk;
    exports2.renamePackageOnDiskForType = renamePackageOnDiskForType;
    exports2.setPackageInBuildGradle = setPackageInBuildGradle;
    exports2.withPackageRefactor = exports2.withPackageGradle = void 0;
    function _debug() {
      const data = _interopRequireDefault(require_src());
      _debug = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _glob() {
      const data = require_commonjs5();
      _glob = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _Paths() {
      const data = require_Paths();
      _Paths = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    function _withDangerousMod() {
      const data = require_withDangerousMod();
      _withDangerousMod = function() {
        return data;
      };
      return data;
    }
    function _modules() {
      const data = require_modules();
      _modules = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var debug = (0, _debug().default)("expo:config-plugins:android:package");
    var withPackageGradle = (config) => {
      return (0, _androidPlugins().withAppBuildGradle)(config, (config2) => {
        if (config2.modResults.language === "groovy") {
          config2.modResults.contents = setPackageInBuildGradle(config2, config2.modResults.contents);
        } else {
          (0, _warnings().addWarningAndroid)("android.package", `Cannot automatically configure app build.gradle if it's not groovy`);
        }
        return config2;
      });
    };
    exports2.withPackageGradle = withPackageGradle;
    var withPackageRefactor = (config) => {
      return (0, _withDangerousMod().withDangerousMod)(config, ["android", async (config2) => {
        await renamePackageOnDisk(config2, config2.modRequest.projectRoot);
        return config2;
      }]);
    };
    exports2.withPackageRefactor = withPackageRefactor;
    function getPackage(config) {
      return config.android?.package ?? null;
    }
    function getPackageRoot(projectRoot, type) {
      return _path().default.join(projectRoot, "android", "app", "src", type, "java");
    }
    function getCurrentPackageName(projectRoot, packageRoot) {
      const mainApplication = (0, _Paths().getProjectFilePath)(projectRoot, "MainApplication");
      const packagePath = _path().default.dirname(mainApplication);
      const packagePathParts = _path().default.relative(packageRoot, packagePath).split(_path().default.sep).filter(Boolean);
      return packagePathParts.join(".");
    }
    function getCurrentPackageForProjectFile(projectRoot, packageRoot, fileName, type) {
      const filePath = (0, _glob().globSync)(_path().default.join(projectRoot, `android/app/src/${type}/java/**/${fileName}.@(java|kt)`))[0];
      if (!filePath) {
        return null;
      }
      const packagePath = _path().default.dirname(filePath);
      const packagePathParts = _path().default.relative(packageRoot, packagePath).split(_path().default.sep).filter(Boolean);
      return packagePathParts.join(".");
    }
    function getCurrentPackageNameForType(projectRoot, type) {
      const packageRoot = getPackageRoot(projectRoot, type);
      if (type === "main") {
        return getCurrentPackageName(projectRoot, packageRoot);
      }
      return getCurrentPackageForProjectFile(projectRoot, packageRoot, "*", type);
    }
    async function renamePackageOnDisk(config, projectRoot) {
      const newPackageName = getPackage(config);
      if (newPackageName === null) {
        return;
      }
      for (const type of ["debug", "main", "release"]) {
        await renameJniOnDiskForType({
          projectRoot,
          type,
          packageName: newPackageName
        });
        await renamePackageOnDiskForType({
          projectRoot,
          type,
          packageName: newPackageName
        });
      }
    }
    async function renameJniOnDiskForType({
      projectRoot,
      type,
      packageName
    }) {
      if (!packageName) {
        return;
      }
      const currentPackageName = getCurrentPackageNameForType(projectRoot, type);
      if (!currentPackageName || !packageName || currentPackageName === packageName) {
        return;
      }
      const jniRoot = _path().default.join(projectRoot, "android", "app", "src", type, "jni");
      const filesToUpdate = [...(0, _glob().globSync)("**/*", {
        cwd: jniRoot,
        absolute: true
      })];
      filesToUpdate.forEach((filepath) => {
        try {
          if (_fs().default.lstatSync(filepath).isFile() && [".h", ".cpp"].includes(_path().default.extname(filepath))) {
            let contents = _fs().default.readFileSync(filepath).toString();
            contents = contents.replace(new RegExp(transformJavaClassDescriptor(currentPackageName).replace(/\//g, "\\/"), "g"), transformJavaClassDescriptor(packageName));
            _fs().default.writeFileSync(filepath, contents);
          }
        } catch {
          debug(`Error updating "${filepath}" for type "${type}"`);
        }
      });
    }
    async function renamePackageOnDiskForType({
      projectRoot,
      type,
      packageName
    }) {
      if (!packageName) {
        return;
      }
      const currentPackageName = getCurrentPackageNameForType(projectRoot, type);
      debug(`Found package "${currentPackageName}" for type "${type}"`);
      if (!currentPackageName || currentPackageName === packageName) {
        return;
      }
      debug(`Refactor "${currentPackageName}" to "${packageName}" for type "${type}"`);
      const packageRoot = getPackageRoot(projectRoot, type);
      if (!await (0, _modules().directoryExistsAsync)(packageRoot)) {
        debug(`- skipping refactor of missing directory: ${packageRoot}`);
        return;
      }
      const currentPackagePath = _path().default.join(packageRoot, ...currentPackageName.split("."));
      const newPackagePath = _path().default.join(packageRoot, ...packageName.split("."));
      _fs().default.mkdirSync(newPackagePath, {
        recursive: true
      });
      (0, _glob().globSync)("**/*", {
        cwd: currentPackagePath
      }).forEach((relativePath) => {
        const filepath = _path().default.join(currentPackagePath, relativePath);
        if (_fs().default.lstatSync(filepath).isFile()) {
          moveFileSync(filepath, _path().default.join(newPackagePath, relativePath));
        } else {
          _fs().default.mkdirSync(filepath, {
            recursive: true
          });
        }
      });
      const oldPathParts = currentPackageName.split(".");
      while (oldPathParts.length) {
        const pathToCheck = _path().default.join(packageRoot, ...oldPathParts);
        try {
          const files = _fs().default.readdirSync(pathToCheck);
          if (files.length === 0) {
            _fs().default.rmdirSync(pathToCheck);
          }
        } finally {
          oldPathParts.pop();
        }
      }
      const filesToUpdate = [...(0, _glob().globSync)("**/*", {
        cwd: newPackagePath,
        absolute: true
      })];
      if (type === "main") {
        filesToUpdate.push(_path().default.join(projectRoot, "android", "app", "BUCK"));
      }
      const kotlinSanitizedPackageName = kotlinSanitized(packageName);
      filesToUpdate.forEach((filepath) => {
        try {
          if (_fs().default.lstatSync(filepath).isFile()) {
            let contents = _fs().default.readFileSync(filepath).toString();
            if (_path().default.extname(filepath) === ".kt") {
              contents = replacePackageName(contents, currentPackageName, kotlinSanitizedPackageName);
            } else {
              contents = replacePackageName(contents, currentPackageName, packageName);
            }
            if ([".h", ".cpp"].includes(_path().default.extname(filepath))) {
              contents = contents.replace(new RegExp(transformJavaClassDescriptor(currentPackageName).replace(/\//g, "\\"), "g"), transformJavaClassDescriptor(packageName));
            }
            _fs().default.writeFileSync(filepath, contents);
          }
        } catch {
          debug(`Error updating "${filepath}" for type "${type}"`);
        }
      });
    }
    function moveFileSync(src, dest) {
      _fs().default.mkdirSync(_path().default.dirname(dest), {
        recursive: true
      });
      _fs().default.renameSync(src, dest);
    }
    function setPackageInBuildGradle(config, buildGradle) {
      const packageName = getPackage(config);
      if (packageName === null) {
        return buildGradle;
      }
      const pattern = new RegExp(`(applicationId|namespace) ['"].*['"]`, "g");
      return buildGradle.replace(pattern, `$1 '${packageName}'`);
    }
    async function getApplicationIdAsync(projectRoot) {
      const buildGradlePath = (0, _Paths().getAppBuildGradleFilePath)(projectRoot);
      if (!_fs().default.existsSync(buildGradlePath)) {
        return null;
      }
      const buildGradle = await _fs().default.promises.readFile(buildGradlePath, "utf8");
      const matchResult = buildGradle.match(/applicationId ['"](.*)['"]/);
      return matchResult?.[1] ?? null;
    }
    function replacePackageName(content, oldName, newName) {
      const oldNameEscaped = oldName.replace(/\./g, "\\.");
      return content.replace(new RegExp(`"${oldNameEscaped}"`, "g"), `"${newName}"`).replace(new RegExp(`(package|namespace)(\\s+)${oldNameEscaped}`, "g"), `$1$2${newName}`).replace(new RegExp(`(import\\s+)${oldNameEscaped}\\.`, "g"), `$1${newName}.`);
    }
    function transformJavaClassDescriptor(packageName) {
      return `L${packageName.replace(/\./g, "/")}`;
    }
    function kotlinSanitized(packageName) {
      const stringsToWrap = ["is", "in", "as", "fun"];
      const parts = packageName.split(".");
      const cleanParts = parts.map((part) => stringsToWrap.includes(part) ? "`" + part + "`" : part);
      const cleanName = cleanParts.join(".");
      return cleanName;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Permissions.js
var require_Permissions = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addBlockedPermissions = addBlockedPermissions;
    exports2.addPermission = addPermission;
    exports2.addPermissionToManifest = addPermissionToManifest;
    exports2.ensurePermission = ensurePermission;
    exports2.ensurePermissionNameFormat = ensurePermissionNameFormat;
    exports2.ensurePermissions = ensurePermissions;
    exports2.getAndroidPermissions = getAndroidPermissions;
    exports2.getPermissions = getPermissions;
    exports2.isPermissionAlreadyRequested = isPermissionAlreadyRequested;
    exports2.removePermissions = removePermissions;
    exports2.setAndroidPermissions = setAndroidPermissions;
    exports2.withPermissions = exports2.withInternalBlockedPermissions = exports2.withBlockedPermissions = void 0;
    function _Manifest() {
      const data = require_Manifest();
      _Manifest = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    var USES_PERMISSION = "uses-permission";
    var withPermissions = (config, permissions) => {
      if (Array.isArray(permissions)) {
        permissions = permissions.filter(Boolean);
        if (!config.android) config.android = {};
        if (!config.android.permissions) config.android.permissions = [];
        config.android.permissions = [
          // @ts-ignore
          ...new Set(config.android.permissions.concat(permissions))
        ];
      }
      return (0, _androidPlugins().withAndroidManifest)(config, async (config2) => {
        config2.modResults = await setAndroidPermissions(config2, config2.modResults);
        return config2;
      });
    };
    exports2.withPermissions = withPermissions;
    var withBlockedPermissions = (config, permissions) => {
      const resolvedPermissions = prefixAndroidPermissionsIfNecessary((Array.isArray(permissions) ? permissions : [permissions]).filter(Boolean));
      if (config?.android?.permissions && Array.isArray(config.android.permissions)) {
        config.android.permissions = prefixAndroidPermissionsIfNecessary(config.android.permissions).filter((permission) => !resolvedPermissions.includes(permission));
      }
      return (0, _androidPlugins().withAndroidManifest)(config, async (config2) => {
        config2.modResults = (0, _Manifest().ensureToolsAvailable)(config2.modResults);
        config2.modResults = addBlockedPermissions(config2.modResults, resolvedPermissions);
        return config2;
      });
    };
    exports2.withBlockedPermissions = withBlockedPermissions;
    var withInternalBlockedPermissions = (config) => {
      if (config.android?.blockedPermissions?.length) {
        return withBlockedPermissions(config, config.android.blockedPermissions);
      }
      return config;
    };
    exports2.withInternalBlockedPermissions = withInternalBlockedPermissions;
    function addBlockedPermissions(androidManifest, permissions) {
      if (!Array.isArray(androidManifest.manifest["uses-permission"])) {
        androidManifest.manifest["uses-permission"] = [];
      }
      for (const permission of prefixAndroidPermissionsIfNecessary(permissions)) {
        androidManifest.manifest["uses-permission"] = ensureBlockedPermission(androidManifest.manifest["uses-permission"], permission);
      }
      return androidManifest;
    }
    function ensureBlockedPermission(manifestPermissions, permission) {
      manifestPermissions = manifestPermissions.filter((e) => e.$["android:name"] !== permission);
      manifestPermissions.push({
        $: {
          "android:name": permission,
          "tools:node": "remove"
        }
      });
      return manifestPermissions;
    }
    function prefixAndroidPermissionsIfNecessary(permissions) {
      return permissions.map((permission) => {
        if (!permission.includes(".")) {
          return `android.permission.${permission}`;
        }
        return permission;
      });
    }
    function getAndroidPermissions(config) {
      return config.android?.permissions ?? [];
    }
    function setAndroidPermissions(config, androidManifest) {
      const permissions = getAndroidPermissions(config);
      const providedPermissions = prefixAndroidPermissionsIfNecessary(permissions);
      const permissionsToAdd = [...providedPermissions];
      if (!androidManifest.manifest.hasOwnProperty("uses-permission")) {
        androidManifest.manifest["uses-permission"] = [];
      }
      const manifestPermissions = androidManifest.manifest["uses-permission"] ?? [];
      permissionsToAdd.forEach((permission) => {
        if (!isPermissionAlreadyRequested(permission, manifestPermissions)) {
          addPermissionToManifest(permission, manifestPermissions);
        }
      });
      return androidManifest;
    }
    function isPermissionAlreadyRequested(permission, manifestPermissions) {
      return manifestPermissions.some((e) => e.$["android:name"] === permission);
    }
    function addPermissionToManifest(permission, manifestPermissions) {
      manifestPermissions.push({
        $: {
          "android:name": permission
        }
      });
      return manifestPermissions;
    }
    function removePermissions(androidManifest, permissionNames) {
      const targetNames = permissionNames ? permissionNames.map(ensurePermissionNameFormat) : null;
      const permissions = androidManifest.manifest[USES_PERMISSION] || [];
      const nextPermissions = [];
      for (const attribute of permissions) {
        if (targetNames) {
          const value = attribute.$["android:name"] || attribute.$.name;
          if (!targetNames.includes(value)) {
            nextPermissions.push(attribute);
          }
        }
      }
      androidManifest.manifest[USES_PERMISSION] = nextPermissions;
    }
    function addPermission(androidManifest, permissionName) {
      const usesPermissions = androidManifest.manifest[USES_PERMISSION] || [];
      usesPermissions.push({
        $: {
          "android:name": permissionName
        }
      });
      androidManifest.manifest[USES_PERMISSION] = usesPermissions;
    }
    function ensurePermissions(androidManifest, permissionNames) {
      const permissions = getPermissions(androidManifest);
      const results = {};
      for (const permissionName of permissionNames) {
        const targetName = ensurePermissionNameFormat(permissionName);
        if (!permissions.includes(targetName)) {
          addPermission(androidManifest, targetName);
          results[permissionName] = true;
        } else {
          results[permissionName] = false;
        }
      }
      return results;
    }
    function ensurePermission(androidManifest, permissionName) {
      const permissions = getPermissions(androidManifest);
      const targetName = ensurePermissionNameFormat(permissionName);
      if (!permissions.includes(targetName)) {
        addPermission(androidManifest, targetName);
        return true;
      }
      return false;
    }
    function ensurePermissionNameFormat(permissionName) {
      if (permissionName.includes(".")) {
        const com = permissionName.split(".");
        const name = com.pop();
        return [...com, name.toUpperCase()].join(".");
      } else {
        return ensurePermissionNameFormat(`android.permission.${permissionName}`);
      }
    }
    function getPermissions(androidManifest) {
      const usesPermissions = androidManifest.manifest[USES_PERMISSION] || [];
      const permissions = usesPermissions.map((permissionObject) => {
        return permissionObject.$["android:name"] || permissionObject.$.name;
      });
      return permissions;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Styles.js
var require_Styles = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Styles.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assignStylesValue = assignStylesValue;
    exports2.getAppThemeGroup = getAppThemeGroup;
    exports2.getAppThemeLightNoActionBarGroup = getAppThemeLightNoActionBarGroup;
    exports2.getProjectStylesXMLPathAsync = getProjectStylesXMLPathAsync;
    exports2.getStyleParent = getStyleParent;
    exports2.getStylesGroupAsObject = getStylesGroupAsObject;
    exports2.getStylesItem = getStylesItem;
    exports2.readStylesXMLAsync = readStylesXMLAsync;
    exports2.removeStylesItem = removeStylesItem;
    exports2.setStylesItem = setStylesItem;
    function _Paths() {
      const data = require_Paths();
      _Paths = function() {
        return data;
      };
      return data;
    }
    function _Resources() {
      const data = require_Resources();
      _Resources = function() {
        return data;
      };
      return data;
    }
    var fallbackResourceString = `<?xml version="1.0" encoding="utf-8"?><resources xmlns:tools="http://schemas.android.com/tools"></resources>`;
    async function readStylesXMLAsync({
      path: path11,
      fallback = fallbackResourceString
    }) {
      return (0, _Resources().readResourcesXMLAsync)({
        path: path11,
        fallback
      });
    }
    async function getProjectStylesXMLPathAsync(projectRoot, {
      kind
    } = {}) {
      return (0, _Paths().getResourceXMLPathAsync)(projectRoot, {
        kind,
        name: "styles"
      });
    }
    function ensureDefaultStyleResourceXML(xml) {
      xml = (0, _Resources().ensureDefaultResourceXML)(xml);
      if (!Array.isArray(xml?.resources?.style)) {
        xml.resources.style = [];
      }
      return xml;
    }
    function getStyleParent(xml, group) {
      return (0, _Resources().findResourceGroup)(xml.resources.style, group);
    }
    function getStylesItem({
      name,
      xml,
      parent
    }) {
      xml = ensureDefaultStyleResourceXML(xml);
      const appTheme = getStyleParent(xml, parent);
      if (!appTheme) {
        return null;
      }
      if (appTheme.item) {
        const existingItem = appTheme.item.filter(({
          $: head
        }) => head.name === name)[0];
        if (existingItem) {
          return existingItem;
        }
      }
      return null;
    }
    function setStylesItem({
      item,
      xml,
      parent
    }) {
      xml = ensureDefaultStyleResourceXML(xml);
      let appTheme = getStyleParent(xml, parent);
      if (!appTheme) {
        appTheme = (0, _Resources().buildResourceGroup)({
          parent: "Theme.AppCompat.Light.NoActionBar",
          // Default AppTheme parent
          ...parent
        });
        xml.resources.style.push(appTheme);
      }
      if (appTheme.item) {
        const existingItem = appTheme.item.filter(({
          $: head
        }) => head.name === item.$.name)[0];
        if (existingItem) {
          existingItem._ = item._;
          existingItem.$ = item.$;
        } else {
          appTheme.item.push(item);
        }
      } else {
        appTheme.item = [item];
      }
      return xml;
    }
    function removeStylesItem({
      name,
      xml,
      parent
    }) {
      xml = ensureDefaultStyleResourceXML(xml);
      const appTheme = getStyleParent(xml, parent);
      if (appTheme?.item) {
        const index = appTheme.item.findIndex(({
          $: head
        }) => head.name === name);
        if (index > -1) {
          appTheme.item.splice(index, 1);
        }
      }
      return xml;
    }
    function getAppThemeLightNoActionBarGroup() {
      return {
        name: "AppTheme",
        parent: "Theme.AppCompat.Light.NoActionBar"
      };
    }
    function getAppThemeGroup() {
      return {
        name: "AppTheme"
      };
    }
    function assignStylesValue(xml, {
      add,
      value,
      targetApi,
      name,
      parent
    }) {
      if (add) {
        return setStylesItem({
          xml,
          parent,
          item: (0, _Resources().buildResourceItem)({
            name,
            targetApi,
            value
          })
        });
      }
      return removeStylesItem({
        xml,
        parent,
        name
      });
    }
    function getStylesGroupAsObject(xml, group) {
      const xmlGroup = getStyleParent(xml, group);
      return xmlGroup?.item ? (0, _Resources().getResourceItemsAsObject)(xmlGroup.item) : null;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/PrimaryColor.js
var require_PrimaryColor = __commonJS({
  "node_modules/@expo/config-plugins/build/android/PrimaryColor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getPrimaryColor = getPrimaryColor;
    exports2.withPrimaryColorStyles = exports2.withPrimaryColorColors = exports2.withPrimaryColor = void 0;
    function _Colors() {
      const data = require_Colors();
      _Colors = function() {
        return data;
      };
      return data;
    }
    function _Styles() {
      const data = require_Styles();
      _Styles = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    var COLOR_PRIMARY_KEY = "colorPrimary";
    var DEFAULT_PRIMARY_COLOR = "#023c69";
    var withPrimaryColor = (config) => {
      config = withPrimaryColorColors(config);
      config = withPrimaryColorStyles(config);
      return config;
    };
    exports2.withPrimaryColor = withPrimaryColor;
    var withPrimaryColorColors = (config) => {
      return (0, _androidPlugins().withAndroidColors)(config, (config2) => {
        config2.modResults = (0, _Colors().assignColorValue)(config2.modResults, {
          name: COLOR_PRIMARY_KEY,
          value: getPrimaryColor(config2)
        });
        return config2;
      });
    };
    exports2.withPrimaryColorColors = withPrimaryColorColors;
    var withPrimaryColorStyles = (config) => {
      return (0, _androidPlugins().withAndroidStyles)(config, (config2) => {
        config2.modResults = (0, _Styles().assignStylesValue)(config2.modResults, {
          add: !!getPrimaryColor(config2),
          parent: (0, _Styles().getAppThemeGroup)(),
          name: COLOR_PRIMARY_KEY,
          value: `@color/${COLOR_PRIMARY_KEY}`
        });
        return config2;
      });
    };
    exports2.withPrimaryColorStyles = withPrimaryColorStyles;
    function getPrimaryColor(config) {
      return config.primaryColor ?? DEFAULT_PRIMARY_COLOR;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Properties.js
var require_Properties = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parsePropertiesFile = parsePropertiesFile;
    exports2.propertiesListToString = propertiesListToString;
    function parsePropertiesFile(contents) {
      const propertiesList = [];
      const lines = contents.split("\n");
      for (let i2 = 0; i2 < lines.length; i2++) {
        const line2 = lines[i2].trim();
        if (!line2) {
          propertiesList.push({
            type: "empty"
          });
        } else if (line2.startsWith("#")) {
          propertiesList.push({
            type: "comment",
            value: line2.substring(1).trimStart()
          });
        } else {
          const eok = line2.indexOf("=");
          const key3 = line2.slice(0, eok);
          const value = line2.slice(eok + 1, line2.length);
          propertiesList.push({
            type: "property",
            key: key3,
            value
          });
        }
      }
      return propertiesList;
    }
    function propertiesListToString(props) {
      let output = "";
      for (let i2 = 0; i2 < props.length; i2++) {
        const prop = props[i2];
        if (prop.type === "empty") {
          output += "";
        } else if (prop.type === "comment") {
          output += "# " + prop.value;
        } else if (prop.type === "property") {
          output += `${prop.key}=${prop.value}`;
        } else {
          throw new Error(`Invalid properties type "${prop.type}"`);
        }
        if (i2 < props.length - 1) {
          output += "\n";
        }
      }
      return output;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Scheme.js
var require_Scheme = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Scheme.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.appendScheme = appendScheme;
    exports2.ensureManifestHasValidIntentFilter = ensureManifestHasValidIntentFilter;
    exports2.getScheme = getScheme;
    exports2.getSchemesFromManifest = getSchemesFromManifest;
    exports2.hasScheme = hasScheme;
    exports2.removeScheme = removeScheme;
    exports2.setScheme = setScheme;
    exports2.withScheme = void 0;
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    var withScheme = exports2.withScheme = (0, _androidPlugins().createAndroidManifestPlugin)(setScheme, "withScheme");
    function getScheme(config) {
      if (Array.isArray(config.scheme)) {
        const validate = (value) => typeof value === "string";
        return config.scheme.filter(validate);
      } else if (typeof config.scheme === "string") {
        return [config.scheme];
      }
      return [];
    }
    function setScheme(config, androidManifest) {
      const schemes = [...getScheme(config), ...getScheme(config.android ?? {})];
      if (schemes.length === 0) {
        return androidManifest;
      }
      if (!ensureManifestHasValidIntentFilter(androidManifest)) {
        (0, _warnings().addWarningAndroid)("scheme", `Cannot add schemes because the provided manifest does not have a valid Activity with \`android:launchMode="singleTask"\``, "https://expo.fyi/setup-android-uri-scheme");
        return androidManifest;
      }
      const currentSchemes = getSchemesFromManifest(androidManifest);
      for (const uri of currentSchemes) {
        const index = schemes.indexOf(uri);
        if (index > -1) schemes.splice(index, 1);
      }
      for (const uri of schemes) {
        androidManifest = appendScheme(uri, androidManifest);
      }
      return androidManifest;
    }
    function isValidRedirectIntentFilter({
      actions,
      categories
    }) {
      return actions.includes("android.intent.action.VIEW") && !categories.includes("android.intent.category.LAUNCHER");
    }
    function propertiesFromIntentFilter(intentFilter) {
      const actions = intentFilter?.action?.map((data2) => data2?.$?.["android:name"]) ?? [];
      const categories = intentFilter?.category?.map((data2) => data2?.$?.["android:name"]) ?? [];
      const data = intentFilter?.data?.filter((data2) => data2?.$?.["android:scheme"])?.map((data2) => ({
        scheme: data2?.$?.["android:scheme"],
        host: data2?.$?.["android:host"]
      })) ?? [];
      return {
        actions,
        categories,
        data
      };
    }
    function getSingleTaskIntentFilters(androidManifest) {
      if (!Array.isArray(androidManifest.manifest.application)) return [];
      let outputSchemes = [];
      for (const application of androidManifest.manifest.application) {
        const {
          activity
        } = application;
        const activities = Array.isArray(activity) ? activity : [activity];
        const singleTaskActivities = activities.filter((activity2) => activity2?.$?.["android:launchMode"] === "singleTask");
        for (const activity2 of singleTaskActivities) {
          const intentFilters = activity2["intent-filter"];
          outputSchemes = outputSchemes.concat(intentFilters);
        }
      }
      return outputSchemes;
    }
    function getSchemesFromManifest(androidManifest, requestedHost = null) {
      const outputSchemes = [];
      const singleTaskIntentFilters = getSingleTaskIntentFilters(androidManifest);
      for (const intentFilter of singleTaskIntentFilters) {
        const properties = propertiesFromIntentFilter(intentFilter);
        if (isValidRedirectIntentFilter(properties) && properties.data) {
          for (const {
            scheme,
            host
          } of properties.data) {
            if (requestedHost === null || !host || host === requestedHost) {
              outputSchemes.push(scheme);
            }
          }
        }
      }
      return outputSchemes;
    }
    function ensureManifestHasValidIntentFilter(androidManifest) {
      if (!Array.isArray(androidManifest.manifest.application)) {
        return false;
      }
      for (const application of androidManifest.manifest.application) {
        for (const activity of application.activity || []) {
          if (activity?.$?.["android:launchMode"] === "singleTask") {
            for (const intentFilter of activity["intent-filter"] || []) {
              const properties = propertiesFromIntentFilter(intentFilter);
              if (isValidRedirectIntentFilter(properties)) {
                return true;
              }
            }
            if (!activity["intent-filter"]) {
              activity["intent-filter"] = [];
            }
            activity["intent-filter"].push({
              action: [{
                $: {
                  "android:name": "android.intent.action.VIEW"
                }
              }],
              category: [{
                $: {
                  "android:name": "android.intent.category.DEFAULT"
                }
              }, {
                $: {
                  "android:name": "android.intent.category.BROWSABLE"
                }
              }]
            });
            return true;
          }
        }
      }
      return false;
    }
    function hasScheme(scheme, androidManifest) {
      const schemes = getSchemesFromManifest(androidManifest);
      return schemes.includes(scheme);
    }
    function appendScheme(scheme, androidManifest) {
      if (!Array.isArray(androidManifest.manifest.application)) {
        return androidManifest;
      }
      if (!ensureManifestHasValidIntentFilter(androidManifest)) {
        (0, _warnings().addWarningAndroid)("scheme", `Cannot add schemes because the provided manifest does not have a valid Activity with \`android:launchMode="singleTask"\``, "https://expo.fyi/setup-android-uri-scheme");
        return androidManifest;
      }
      for (const application of androidManifest.manifest.application) {
        for (const activity of application.activity || []) {
          if (activity?.$?.["android:launchMode"] === "singleTask") {
            for (const intentFilter of activity["intent-filter"] || []) {
              const properties = propertiesFromIntentFilter(intentFilter);
              if (isValidRedirectIntentFilter(properties)) {
                if (!intentFilter.data) intentFilter.data = [];
                intentFilter.data.push({
                  $: {
                    "android:scheme": scheme
                  }
                });
              }
            }
            break;
          }
        }
      }
      return androidManifest;
    }
    function removeScheme(scheme, androidManifest) {
      if (!Array.isArray(androidManifest.manifest.application)) {
        return androidManifest;
      }
      for (const application of androidManifest.manifest.application) {
        for (const activity of application.activity || []) {
          if (activity?.$?.["android:launchMode"] === "singleTask") {
            for (const intentFilter of activity["intent-filter"] || []) {
              const properties = propertiesFromIntentFilter(intentFilter);
              if (isValidRedirectIntentFilter(properties)) {
                for (const dataKey in intentFilter?.data || []) {
                  const data = intentFilter.data?.[dataKey];
                  if (data?.$?.["android:scheme"] === scheme) {
                    delete intentFilter.data?.[dataKey];
                  }
                }
              }
            }
            break;
          }
        }
      }
      return androidManifest;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/StatusBar.js
var require_StatusBar = __commonJS({
  "node_modules/@expo/config-plugins/build/android/StatusBar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getStatusBarColor = getStatusBarColor;
    exports2.getStatusBarStyle = getStatusBarStyle;
    exports2.getStatusBarTranslucent = getStatusBarTranslucent;
    exports2.setStatusBarColors = setStatusBarColors;
    exports2.setStatusBarStyles = setStatusBarStyles;
    exports2.withStatusBar = void 0;
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function _Colors() {
      const data = require_Colors();
      _Colors = function() {
        return data;
      };
      return data;
    }
    function _Styles() {
      const data = require_Styles();
      _Styles = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var COLOR_PRIMARY_DARK_KEY = "colorPrimaryDark";
    var WINDOW_LIGHT_STATUS_BAR = "android:windowLightStatusBar";
    var STATUS_BAR_COLOR = "android:statusBarColor";
    var withStatusBar = (config) => {
      config = withStatusBarColors(config);
      config = withStatusBarStyles(config);
      return config;
    };
    exports2.withStatusBar = withStatusBar;
    var withStatusBarColors = (config) => {
      return (0, _androidPlugins().withAndroidColors)(config, (config2) => {
        config2.modResults = setStatusBarColors(config2, config2.modResults);
        return config2;
      });
    };
    var withStatusBarStyles = (config) => {
      return (0, _androidPlugins().withAndroidStyles)(config, (config2) => {
        config2.modResults = setStatusBarStyles(config2, config2.modResults);
        return config2;
      });
    };
    function setStatusBarColors(config, colors) {
      return (0, _Colors().assignColorValue)(colors, {
        name: COLOR_PRIMARY_DARK_KEY,
        value: getStatusBarColor(config)
      });
    }
    function setStatusBarStyles(config, styles) {
      const hexString = getStatusBarColor(config);
      const floatElement = getStatusBarTranslucent(config);
      styles = (0, _Styles().assignStylesValue)(styles, {
        parent: (0, _Styles().getAppThemeGroup)(),
        name: WINDOW_LIGHT_STATUS_BAR,
        value: "true",
        // Default is light-content, don't need to do anything to set it
        add: getStatusBarStyle(config) === "dark-content"
      });
      styles = (0, _Styles().assignStylesValue)(styles, {
        parent: (0, _Styles().getAppThemeGroup)(),
        name: STATUS_BAR_COLOR,
        value: floatElement ? "@android:color/transparent" : hexString ?? "@color/colorPrimaryDark",
        // Remove the color if translucent is used
        add: floatElement || !!hexString
      });
      return styles;
    }
    function getStatusBarColor(config) {
      const backgroundColor = config.androidStatusBar?.backgroundColor;
      if (backgroundColor) {
        (0, _assert().default)(backgroundColor !== "translucent", `androidStatusBar.backgroundColor must be a valid hex string, instead got: "${backgroundColor}"`);
      }
      return backgroundColor;
    }
    function getStatusBarTranslucent(config) {
      return config.androidStatusBar?.translucent ?? false;
    }
    function getStatusBarStyle(config) {
      return config.androidStatusBar?.barStyle || "light-content";
    }
  }
});

// node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "node_modules/resolve-from/index.js"(exports2, module2) {
    "use strict";
    var path11 = require("path");
    var Module = require("module");
    var fs7 = require("fs");
    var resolveFrom = (fromDirectory, moduleId, silent) => {
      if (typeof fromDirectory !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDirectory = fs7.realpathSync(fromDirectory);
      } catch (error) {
        if (error.code === "ENOENT") {
          fromDirectory = path11.resolve(fromDirectory);
        } else if (silent) {
          return;
        } else {
          throw error;
        }
      }
      const fromFile = path11.join(fromDirectory, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDirectory)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (error) {
          return;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId);
    module2.exports.silent = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId, true);
  }
});

// node_modules/@expo/config-plugins/build/utils/plugin-resolver.js
var require_plugin_resolver = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/plugin-resolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertInternalProjectRoot = assertInternalProjectRoot;
    exports2.moduleNameIsDirectFileReference = moduleNameIsDirectFileReference;
    exports2.moduleNameIsPackageReference = moduleNameIsPackageReference;
    exports2.normalizeStaticPlugin = normalizeStaticPlugin;
    exports2.pluginFileName = void 0;
    exports2.resolveConfigPluginExport = resolveConfigPluginExport;
    exports2.resolveConfigPluginFunction = resolveConfigPluginFunction;
    exports2.resolveConfigPluginFunctionWithInfo = resolveConfigPluginFunctionWithInfo;
    exports2.resolvePluginForModule = resolvePluginForModule;
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function path11() {
      const data = _interopRequireWildcard(require("path"));
      path11 = function() {
        return data;
      };
      return data;
    }
    function _resolveFrom() {
      const data = _interopRequireDefault(require_resolve_from());
      _resolveFrom = function() {
        return data;
      };
      return data;
    }
    function _errors() {
      const data = require_errors();
      _errors = function() {
        return data;
      };
      return data;
    }
    function _modules() {
      const data = require_modules();
      _modules = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var pluginFileName = exports2.pluginFileName = "app.plugin.js";
    function resolvePluginForModule(projectRoot, pluginReference) {
      if (moduleNameIsDirectFileReference(pluginReference)) {
        const pluginScriptFile = _resolveFrom().default.silent(projectRoot, pluginReference);
        if (pluginScriptFile) {
          return {
            // NOTE(cedric): `path.sep` is required here, we are resolving the absolute path, not the plugin reference
            isPluginFile: pluginScriptFile.endsWith(path11().sep + pluginFileName),
            filePath: pluginScriptFile
          };
        }
      } else if (moduleNameIsPackageReference(pluginReference)) {
        const pluginPackageFile = _resolveFrom().default.silent(projectRoot, `${pluginReference}/${pluginFileName}`);
        if (pluginPackageFile && (0, _modules().fileExists)(pluginPackageFile)) {
          return {
            isPluginFile: true,
            filePath: pluginPackageFile
          };
        }
        const packageMainEntry = _resolveFrom().default.silent(projectRoot, pluginReference);
        if (packageMainEntry) {
          return {
            isPluginFile: false,
            filePath: packageMainEntry
          };
        }
      }
      throw new (_errors()).PluginError(`Failed to resolve plugin for module "${pluginReference}" relative to "${projectRoot}". Do you have node modules installed?`, "PLUGIN_NOT_FOUND");
    }
    function pathIsFilePath(name) {
      return !!name.match(/^(\.|~\/|\/)/g);
    }
    function moduleNameIsDirectFileReference(name) {
      if (pathIsFilePath(name)) {
        return true;
      }
      const slashCount = name.split("/")?.length;
      if (name.startsWith("@")) {
        return slashCount > 2;
      }
      return slashCount > 1;
    }
    function moduleNameIsPackageReference(name) {
      const slashCount = name.split("/")?.length;
      return name.startsWith("@") ? slashCount === 2 : slashCount === 1;
    }
    function normalizeStaticPlugin(plugin) {
      if (Array.isArray(plugin)) {
        (0, _assert().default)(plugin.length > 0 && plugin.length < 3, `Wrong number of arguments provided for static config plugin, expected either 1 or 2, got ${plugin.length}`);
        return plugin;
      }
      return [plugin, void 0];
    }
    function assertInternalProjectRoot(projectRoot) {
      (0, _assert().default)(projectRoot, `Unexpected: Config \`_internal.projectRoot\` isn't defined by expo-cli, this is a bug.`);
    }
    function resolveConfigPluginFunction(projectRoot, pluginReference) {
      const {
        plugin
      } = resolveConfigPluginFunctionWithInfo(projectRoot, pluginReference);
      return plugin;
    }
    function resolveConfigPluginFunctionWithInfo(projectRoot, pluginReference) {
      const {
        filePath: pluginFile,
        isPluginFile
      } = resolvePluginForModule(projectRoot, pluginReference);
      let result;
      try {
        result = requirePluginFile(pluginFile);
      } catch (error) {
        if (error instanceof SyntaxError) {
          const learnMoreLink = `Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin`;
          if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {
            const pluginError = new (_errors()).PluginError(`Package "${pluginReference}" does not contain a valid config plugin.
${learnMoreLink}

${error.message}`, "INVALID_PLUGIN_IMPORT");
            pluginError.stack = error.stack;
            throw pluginError;
          }
        }
        throw error;
      }
      const plugin = resolveConfigPluginExport({
        plugin: result,
        pluginFile,
        pluginReference,
        isPluginFile
      });
      return {
        plugin,
        pluginFile,
        pluginReference,
        isPluginFile
      };
    }
    function resolveConfigPluginExport({
      plugin,
      pluginFile,
      pluginReference,
      isPluginFile
    }) {
      if (plugin.default != null) {
        plugin = plugin.default;
      }
      if (typeof plugin !== "function") {
        const learnMoreLink = `Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin`;
        if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {
          throw new (_errors()).PluginError(`Package "${pluginReference}" does not contain a valid config plugin. Module must export a function from file: ${pluginFile}
${learnMoreLink}`, "INVALID_PLUGIN_TYPE");
        }
        throw new (_errors()).PluginError(`Plugin "${pluginReference}" must export a function from file: ${pluginFile}. ${learnMoreLink}`, "INVALID_PLUGIN_TYPE");
      }
      return plugin;
    }
    function requirePluginFile(filePath) {
      try {
        return require(filePath);
      } catch (error) {
        throw error;
      }
    }
  }
});

// node_modules/@expo/config-plugins/build/plugins/withStaticPlugin.js
var require_withStaticPlugin = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/withStaticPlugin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.withStaticPlugin = void 0;
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function _getenv() {
      const data = require_getenv();
      _getenv = function() {
        return data;
      };
      return data;
    }
    function _errors() {
      const data = require_errors();
      _errors = function() {
        return data;
      };
      return data;
    }
    function _pluginResolver() {
      const data = require_plugin_resolver();
      _pluginResolver = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var EXPO_DEBUG = (0, _getenv().boolish)("EXPO_DEBUG", false);
    var EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = (0, _getenv().boolish)("EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS", false);
    var EXPO_USE_UNVERSIONED_PLUGINS = (0, _getenv().boolish)("EXPO_USE_UNVERSIONED_PLUGINS", false);
    function isModuleMissingError(name, error) {
      if (["MODULE_NOT_FOUND", "PLUGIN_NOT_FOUND"].includes(error.code)) {
        return true;
      }
      return error.message.includes(`Cannot find module '${name}'`);
    }
    function isUnexpectedTokenError(error) {
      if (error instanceof SyntaxError || error instanceof _errors().PluginError && error.code === "INVALID_PLUGIN_IMPORT") {
        return (
          // These are the most common errors that'll be thrown when a package isn't transpiled correctly.
          !!error.message.match(/Unexpected token/) || !!error.message.match(/Cannot use import statement/)
        );
      }
      return false;
    }
    var withStaticPlugin = (config, props) => {
      let projectRoot = props.projectRoot;
      if (!projectRoot) {
        projectRoot = config._internal?.projectRoot;
        (0, _pluginResolver().assertInternalProjectRoot)(projectRoot);
      }
      let [pluginResolve, pluginProps] = (0, _pluginResolver().normalizeStaticPlugin)(props.plugin);
      (0, _assert().default)(!pluginProps?._resolverError, `Plugin property '_resolverError' is a reserved property of \`withStaticPlugin\``);
      let withPlugin;
      if (
        // Function was provided, no need to resolve: [withPlugin, {}]
        typeof pluginResolve === "function"
      ) {
        withPlugin = pluginResolve;
      } else if (typeof pluginResolve === "string") {
        try {
          withPlugin = (0, _pluginResolver().resolveConfigPluginFunction)(projectRoot, pluginResolve);
          if (EXPO_USE_UNVERSIONED_PLUGINS && !!withPlugin && !!props._isLegacyPlugin && !!props.fallback) {
            console.log(`Force "${pluginResolve}" to unversioned plugin`);
            withPlugin = props.fallback;
          }
        } catch (error) {
          if (EXPO_DEBUG) {
            if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {
              console.log(`Error resolving plugin "${pluginResolve}"`);
              console.log(error);
              console.log();
            } else {
              const shouldMuteWarning = props._isLegacyPlugin && (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));
              if (!shouldMuteWarning) {
                if (isModuleMissingError(pluginResolve, error)) {
                  console.log(`Could not find plugin "${pluginResolve}"`);
                } else {
                  console.log(`Error resolving plugin "${pluginResolve}"`);
                  console.log(error);
                  console.log();
                }
              }
            }
          }
          if (props.fallback) {
            if (!pluginProps) pluginProps = {};
            pluginProps._resolverError = error;
            withPlugin = props.fallback;
          } else {
            throw error;
          }
        }
      } else {
        if (typeof pluginResolve === "object") {
          throw new (_errors()).PluginError(`Plugin is an unexpected object, with keys: "${Object.keys(pluginResolve).join(", ")}".

If you tried to provide parameters to a config plugin, make sure the plugin configuration is wrapped by square brackets. Ex:

[
  "some-config-plugin",
  {
    "someParam": "someValue"
  }
]


See the package documentation on how to correctly configure the plugin.`, "INVALID_PLUGIN_TYPE");
        }
        throw new (_errors()).PluginError(`Plugin is an unexpected type: ${typeof pluginResolve}. See the package documentation on how to correctly configure the plugin.`, "INVALID_PLUGIN_TYPE");
      }
      config = withPlugin(config, pluginProps);
      return config;
    };
    exports2.withStaticPlugin = withStaticPlugin;
  }
});

// node_modules/@expo/config-plugins/build/plugins/withPlugins.js
var require_withPlugins = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/withPlugins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.withPlugins = void 0;
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function _withStaticPlugin() {
      const data = require_withStaticPlugin();
      _withStaticPlugin = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var withPlugins = (config, plugins) => {
      (0, _assert().default)(Array.isArray(plugins), "withPlugins expected a valid array of plugins or plugin module paths");
      return plugins.reduce((prev, plugin) => (0, _withStaticPlugin().withStaticPlugin)(prev, {
        plugin
      }), config);
    };
    exports2.withPlugins = withPlugins;
  }
});

// node_modules/@expo/sdk-runtime-versions/build/index.js
var require_build = __commonJS({
  "node_modules/@expo/sdk-runtime-versions/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSDKVersionRuntimeVersion = exports2.getSDKVersionFromRuntimeVersion = exports2.getRuntimeVersionForSDKVersion = exports2.RUNTIME_VERSION_PREFIX = void 0;
    exports2.RUNTIME_VERSION_PREFIX = "exposdk:";
    function getRuntimeVersionForSDKVersion(sdkVersion) {
      return "" + exports2.RUNTIME_VERSION_PREFIX + sdkVersion;
    }
    exports2.getRuntimeVersionForSDKVersion = getRuntimeVersionForSDKVersion;
    function getSDKVersionFromRuntimeVersion(runtimeVersion) {
      var regexMatches = /^exposdk:(\d+\.\d+\.\d+)$/.exec(runtimeVersion);
      if (!regexMatches || regexMatches.length < 2) {
        return void 0;
      }
      return regexMatches[1];
    }
    exports2.getSDKVersionFromRuntimeVersion = getSDKVersionFromRuntimeVersion;
    function isSDKVersionRuntimeVersion(runtimeVersion) {
      return getSDKVersionFromRuntimeVersion(runtimeVersion) !== void 0;
    }
    exports2.isSDKVersionRuntimeVersion = isSDKVersionRuntimeVersion;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token2, max] of safeRegexReplacements) {
        value = value.split(`${token2}*`).join(`${token2}{0,${max}}`).split(`${token2}+`).join(`${token2}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i2 = 0;
        do {
          const a = this.prerelease[i2];
          const b = other.prerelease[i2];
          debug("prerelease compare", i2, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i2);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i2 = 0;
        do {
          const a = this.build[i2];
          const b = other.build[i2];
          debug("build compare", i2, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i2);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i2 = this.prerelease.length;
              while (--i2 >= 0) {
                if (typeof this.prerelease[i2] === "number") {
                  this.prerelease[i2]++;
                  i2 = -2;
                }
              }
              if (i2 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse3;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var valid = (version, options) => {
      const v = parse3(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var clean = (version, options) => {
      const s = parse3(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var diff = (version1, version2) => {
      const v12 = parse3(version1, null, true);
      const v2 = parse3(version2, null, true);
      const comparison = v12.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v12 : v2;
      const lowVersion = v1Higher ? v2 : v12;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v12.major !== v2.major) {
        return prefix + "major";
      }
      if (v12.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v12.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse3(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key3) {
        const value = this.map.get(key3);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key3);
          this.map.set(key3, value);
          return value;
        }
      }
      delete(key3) {
        return this.map.delete(key3);
      }
      set(key3, value) {
        const deleted = this.delete(key3);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key3, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c2) => c2.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c2) => !isNullSet(c2[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c2 of this.set) {
              if (c2.length === 1 && isAny(c2[0])) {
                this.set = [c2];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i2 = 0; i2 < this.set.length; i2++) {
            if (i2 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i2];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i2 = 0; i2 < this.set.length; i2++) {
          if (testSet(this.set[i2], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c2) => c2.value === "<0.0.0-0";
    var isAny = (c2) => c2.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === Comparator.ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            const allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i2 = 0; i2 < range.set.length; ++i2) {
        const comparators = range.set[i2];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i2 = 0; i2 < range.set.length; ++i2) {
        const comparators = range.set[i2];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c2 of sub) {
        if (c2.operator === ">" || c2.operator === ">=") {
          gt = higherGT(gt, c2, options);
        } else if (c2.operator === "<" || c2.operator === "<=") {
          lt = lowerLT(lt, c2, options);
        } else {
          eqSet.add(c2.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c2 of dom) {
          if (!satisfies(eq, String(c2), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c2 of dom) {
        hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
        hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c2.operator === ">" || c2.operator === ">=") {
            higher = higherGT(gt, c2, options);
            if (higher === c2 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c2), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c2.operator === "<" || c2.operator === "<=") {
            lower = lowerLT(lt, c2, options);
            if (lower === c2 && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c2), options)) {
            return false;
          }
        }
        if (!c2.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse3 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse3,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/@expo/config-plugins/build/android/Version.js
var require_Version = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getVersionCode = getVersionCode;
    exports2.getVersionName = getVersionName;
    exports2.setMinBuildScriptExtVersion = setMinBuildScriptExtVersion;
    exports2.setVersionCode = setVersionCode;
    exports2.setVersionName = setVersionName;
    exports2.withVersion = exports2.withBuildScriptExtMinimumVersion = void 0;
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    var withVersion = (config) => {
      return (0, _androidPlugins().withAppBuildGradle)(config, (config2) => {
        if (config2.modResults.language === "groovy") {
          config2.modResults.contents = setVersionCode(config2, config2.modResults.contents);
          config2.modResults.contents = setVersionName(config2, config2.modResults.contents);
        } else {
          (0, _warnings().addWarningAndroid)("android.versionCode", `Cannot automatically configure app build.gradle if it's not groovy`);
        }
        return config2;
      });
    };
    exports2.withVersion = withVersion;
    var withBuildScriptExtMinimumVersion = (config, props) => {
      return (0, _androidPlugins().withProjectBuildGradle)(config, (config2) => {
        if (config2.modResults.language === "groovy") {
          config2.modResults.contents = setMinBuildScriptExtVersion(config2.modResults.contents, props);
        } else {
          (0, _warnings().addWarningAndroid)("withBuildScriptExtVersion", `Cannot automatically configure project build.gradle if it's not groovy`);
        }
        return config2;
      });
    };
    exports2.withBuildScriptExtMinimumVersion = withBuildScriptExtMinimumVersion;
    function setMinBuildScriptExtVersion(buildGradle, {
      name,
      minVersion
    }) {
      const regex = new RegExp(`(${name}\\s?=\\s?)(\\d+(?:\\.\\d+)?)`);
      const currentVersion = buildGradle.match(regex)?.[2];
      if (!currentVersion) {
        (0, _warnings().addWarningAndroid)("withBuildScriptExtVersion", `Cannot set minimum buildscript.ext.${name} version because the property "${name}" cannot be found or does not have a numeric value.`);
        return buildGradle;
      }
      const currentVersionNum = Number(currentVersion);
      return buildGradle.replace(regex, `$1${Math.max(minVersion, currentVersionNum)}`);
    }
    function getVersionName(config) {
      return config.android?.version ?? config.version ?? null;
    }
    function setVersionName(config, buildGradle) {
      const versionName = getVersionName(config);
      if (versionName === null) {
        return buildGradle;
      }
      const pattern = new RegExp(`versionName ".*"`);
      return buildGradle.replace(pattern, `versionName "${versionName}"`);
    }
    function getVersionCode(config) {
      return config.android?.versionCode ?? 1;
    }
    function setVersionCode(config, buildGradle) {
      const versionCode = getVersionCode(config);
      if (versionCode === null) {
        return buildGradle;
      }
      const pattern = new RegExp(`versionCode.*`);
      return buildGradle.replace(pattern, `versionCode ${versionCode}`);
    }
  }
});

// node_modules/@expo/config-plugins/build/utils/obj.js
var require_obj = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/obj.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.get = get;
    function get(obj, key3) {
      const branches = key3.split(".");
      let current = obj;
      let branch;
      while (branch = branches.shift()) {
        if (!(branch in current)) {
          return void 0;
        }
        current = current[branch];
      }
      return current;
    }
  }
});

// node_modules/@expo/config-plugins/build/plugins/ios-plugins.js
var require_ios_plugins = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/ios-plugins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createEntitlementsPlugin = createEntitlementsPlugin;
    exports2.createInfoPlistPlugin = createInfoPlistPlugin;
    exports2.createInfoPlistPluginWithPropertyGuard = createInfoPlistPluginWithPropertyGuard;
    exports2.withXcodeProject = exports2.withPodfileProperties = exports2.withPodfile = exports2.withInfoPlist = exports2.withExpoPlist = exports2.withEntitlementsPlist = exports2.withAppDelegate = void 0;
    function _withMod() {
      const data = require_withMod();
      _withMod = function() {
        return data;
      };
      return data;
    }
    function _obj() {
      const data = require_obj();
      _obj = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    function createInfoPlistPlugin(action, name) {
      const withUnknown = (config) => withInfoPlist(config, async (config2) => {
        config2.modResults = await action(config2, config2.modResults);
        return config2;
      });
      if (name) {
        Object.defineProperty(withUnknown, "name", {
          value: name
        });
      }
      return withUnknown;
    }
    function createInfoPlistPluginWithPropertyGuard(action, settings, name) {
      const withUnknown = (config) => withInfoPlist(config, async (config2) => {
        const existingProperty = settings.expoPropertyGetter ? settings.expoPropertyGetter(config2) : (0, _obj().get)(config2, settings.expoConfigProperty);
        if (config2.modRawConfig.ios?.infoPlist?.[settings.infoPlistProperty] === void 0) {
          config2.modResults = await action(config2, config2.modResults);
        } else if (existingProperty !== void 0) {
          (0, _warnings().addWarningIOS)(settings.expoConfigProperty, `"ios.infoPlist.${settings.infoPlistProperty}" is set in the config. Ignoring abstract property "${settings.expoConfigProperty}": ${existingProperty}`);
        }
        return config2;
      });
      if (name) {
        Object.defineProperty(withUnknown, "name", {
          value: name
        });
      }
      return withUnknown;
    }
    function createEntitlementsPlugin(action, name) {
      const withUnknown = (config) => withEntitlementsPlist(config, async (config2) => {
        config2.modResults = await action(config2, config2.modResults);
        return config2;
      });
      if (name) {
        Object.defineProperty(withUnknown, "name", {
          value: name
        });
      }
      return withUnknown;
    }
    var withAppDelegate = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "ios",
        mod: "appDelegate",
        action
      });
    };
    exports2.withAppDelegate = withAppDelegate;
    var withInfoPlist = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "ios",
        mod: "infoPlist",
        async action(config2) {
          config2 = await action(config2);
          if (!config2.ios) {
            config2.ios = {};
          }
          config2.ios.infoPlist = config2.modResults;
          return config2;
        }
      });
    };
    exports2.withInfoPlist = withInfoPlist;
    var withEntitlementsPlist = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "ios",
        mod: "entitlements",
        async action(config2) {
          config2 = await action(config2);
          if (!config2.ios) {
            config2.ios = {};
          }
          config2.ios.entitlements = config2.modResults;
          return config2;
        }
      });
    };
    exports2.withEntitlementsPlist = withEntitlementsPlist;
    var withExpoPlist = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "ios",
        mod: "expoPlist",
        action
      });
    };
    exports2.withExpoPlist = withExpoPlist;
    var withXcodeProject = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "ios",
        mod: "xcodeproj",
        action
      });
    };
    exports2.withXcodeProject = withXcodeProject;
    var withPodfile = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "ios",
        mod: "podfile",
        action
      });
    };
    exports2.withPodfile = withPodfile;
    var withPodfileProperties = (config, action) => {
      return (0, _withMod().withMod)(config, {
        platform: "ios",
        mod: "podfileProperties",
        action
      });
    };
    exports2.withPodfileProperties = withPodfileProperties;
  }
});

// node_modules/@expo/config-plugins/build/ios/Version.js
var require_Version2 = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getBuildNumber = getBuildNumber;
    exports2.getVersion = getVersion;
    exports2.setBuildNumber = setBuildNumber;
    exports2.setVersion = setVersion;
    exports2.withVersion = exports2.withBuildNumber = void 0;
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    var withVersion = exports2.withVersion = (0, _iosPlugins().createInfoPlistPluginWithPropertyGuard)(setVersion, {
      infoPlistProperty: "CFBundleShortVersionString",
      expoConfigProperty: "version | ios.version",
      expoPropertyGetter: getVersion
    }, "withVersion");
    var withBuildNumber = exports2.withBuildNumber = (0, _iosPlugins().createInfoPlistPluginWithPropertyGuard)(setBuildNumber, {
      infoPlistProperty: "CFBundleVersion",
      expoConfigProperty: "ios.buildNumber"
    }, "withBuildNumber");
    function getVersion(config) {
      return config.ios?.version || config.version || "1.0.0";
    }
    function setVersion(config, infoPlist) {
      return {
        ...infoPlist,
        CFBundleShortVersionString: getVersion(config)
      };
    }
    function getBuildNumber(config) {
      return config.ios?.buildNumber ? config.ios.buildNumber : "1";
    }
    function setBuildNumber(config, infoPlist) {
      return {
        ...infoPlist,
        CFBundleVersion: getBuildNumber(config)
      };
    }
  }
});

// node_modules/@expo/config-plugins/build/utils/Updates.js
var require_Updates = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/Updates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FINGERPRINT_RUNTIME_VERSION_SENTINEL = void 0;
    exports2.getAppVersion = getAppVersion;
    exports2.getDisableAntiBrickingMeasures = getDisableAntiBrickingMeasures;
    exports2.getExpoUpdatesPackageVersion = getExpoUpdatesPackageVersion;
    exports2.getNativeVersion = getNativeVersion;
    exports2.getRuntimeVersionAsync = getRuntimeVersionAsync;
    exports2.getRuntimeVersionNullableAsync = getRuntimeVersionNullableAsync;
    exports2.getSDKVersion = getSDKVersion;
    exports2.getUpdateUrl = getUpdateUrl;
    exports2.getUpdatesCheckOnLaunch = getUpdatesCheckOnLaunch;
    exports2.getUpdatesCodeSigningCertificate = getUpdatesCodeSigningCertificate;
    exports2.getUpdatesCodeSigningMetadata = getUpdatesCodeSigningMetadata;
    exports2.getUpdatesCodeSigningMetadataStringified = getUpdatesCodeSigningMetadataStringified;
    exports2.getUpdatesEnabled = getUpdatesEnabled;
    exports2.getUpdatesRequestHeaders = getUpdatesRequestHeaders;
    exports2.getUpdatesRequestHeadersStringified = getUpdatesRequestHeadersStringified;
    exports2.getUpdatesTimeout = getUpdatesTimeout;
    exports2.getUpdatesUseEmbeddedUpdate = getUpdatesUseEmbeddedUpdate;
    exports2.resolveRuntimeVersionPolicyAsync = resolveRuntimeVersionPolicyAsync;
    function _sdkRuntimeVersions() {
      const data = require_build();
      _sdkRuntimeVersions = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _getenv() {
      const data = require_getenv();
      _getenv = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _resolveFrom() {
      const data = _interopRequireDefault(require_resolve_from());
      _resolveFrom = function() {
        return data;
      };
      return data;
    }
    function _semver() {
      const data = _interopRequireDefault(require_semver2());
      _semver = function() {
        return data;
      };
      return data;
    }
    function AndroidVersion() {
      const data = _interopRequireWildcard(require_Version());
      AndroidVersion = function() {
        return data;
      };
      return data;
    }
    function IOSVersion() {
      const data = _interopRequireWildcard(require_Version2());
      IOSVersion = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var FINGERPRINT_RUNTIME_VERSION_SENTINEL = exports2.FINGERPRINT_RUNTIME_VERSION_SENTINEL = "file:fingerprint";
    function getExpoUpdatesPackageVersion(projectRoot) {
      const expoUpdatesPackageJsonPath = _resolveFrom().default.silent(projectRoot, "expo-updates/package.json");
      if (!expoUpdatesPackageJsonPath || !_fs().default.existsSync(expoUpdatesPackageJsonPath)) {
        return null;
      }
      const packageJson = JSON.parse(_fs().default.readFileSync(expoUpdatesPackageJsonPath, "utf8"));
      return packageJson.version;
    }
    function getUpdateUrl(config) {
      return config.updates?.url ?? null;
    }
    function getAppVersion(config) {
      return config.version ?? "1.0.0";
    }
    function getNativeVersion(config, platform) {
      const version = IOSVersion().getVersion(config);
      switch (platform) {
        case "ios": {
          const buildNumber = IOSVersion().getBuildNumber(config);
          return `${version}(${buildNumber})`;
        }
        case "android": {
          const versionCode = AndroidVersion().getVersionCode(config);
          return `${version}(${versionCode})`;
        }
        default: {
          throw new Error(`"${platform}" is not a supported platform. Choose either "ios" or "android".`);
        }
      }
    }
    async function getRuntimeVersionNullableAsync(...[projectRoot, config, platform]) {
      try {
        return await getRuntimeVersionAsync(projectRoot, config, platform);
      } catch (e) {
        if ((0, _getenv().boolish)("EXPO_DEBUG", false)) {
          console.log(e);
        }
        return null;
      }
    }
    async function getRuntimeVersionAsync(projectRoot, config, platform) {
      const runtimeVersion = config[platform]?.runtimeVersion ?? config.runtimeVersion;
      if (!runtimeVersion) {
        return null;
      }
      if (typeof runtimeVersion === "string") {
        if (runtimeVersion === FINGERPRINT_RUNTIME_VERSION_SENTINEL) {
          throw new Error(`${FINGERPRINT_RUNTIME_VERSION_SENTINEL} is a reserved value for runtime version. To use a fingerprint runtime version, use the "fingerprint" runtime version policy.`);
        }
        return runtimeVersion;
      } else if (!runtimeVersion.policy) {
        throw new Error(`"${runtimeVersion}" is not a valid runtime version. Only a string or a runtime version policy is supported.`);
      } else if (runtimeVersion.policy === "fingerprint") {
        return FINGERPRINT_RUNTIME_VERSION_SENTINEL;
      } else {
        return await resolveRuntimeVersionPolicyAsync(runtimeVersion.policy, config, platform);
      }
    }
    async function resolveRuntimeVersionPolicyAsync(policy, config, platform) {
      if (policy === "appVersion") {
        return getAppVersion(config);
      } else if (policy === "nativeVersion") {
        return getNativeVersion(config, platform);
      } else if (policy === "sdkVersion") {
        if (!config.sdkVersion) {
          throw new Error("An SDK version must be defined when using the 'sdkVersion' runtime policy.");
        }
        return (0, _sdkRuntimeVersions().getRuntimeVersionForSDKVersion)(config.sdkVersion);
      } else {
        throw new Error(`"${policy}" is not a valid runtime version policy type.`);
      }
    }
    function getSDKVersion(config) {
      return typeof config.sdkVersion === "string" ? config.sdkVersion : null;
    }
    function getUpdatesEnabled(config) {
      if (config.updates?.enabled !== void 0) {
        return config.updates.enabled;
      }
      return getUpdateUrl(config) !== null;
    }
    function getUpdatesUseEmbeddedUpdate(config) {
      if (config.updates?.useEmbeddedUpdate !== void 0) {
        return config.updates.useEmbeddedUpdate;
      }
      return true;
    }
    function getUpdatesTimeout(config) {
      return config.updates?.fallbackToCacheTimeout ?? 0;
    }
    function getUpdatesCheckOnLaunch(config, expoUpdatesPackageVersion) {
      if (config.updates?.checkAutomatically === "ON_ERROR_RECOVERY") {
        if (expoUpdatesPackageVersion && _semver().default.gte(expoUpdatesPackageVersion, "0.11.0")) {
          return "ERROR_RECOVERY_ONLY";
        }
        return "NEVER";
      } else if (config.updates?.checkAutomatically === "ON_LOAD") {
        return "ALWAYS";
      } else if (config.updates?.checkAutomatically === "WIFI_ONLY") {
        return "WIFI_ONLY";
      } else if (config.updates?.checkAutomatically === "NEVER") {
        return "NEVER";
      }
      return "ALWAYS";
    }
    function getUpdatesCodeSigningCertificate(projectRoot, config) {
      const codeSigningCertificatePath = config.updates?.codeSigningCertificate;
      if (!codeSigningCertificatePath) {
        return void 0;
      }
      const finalPath = _path().default.join(projectRoot, codeSigningCertificatePath);
      if (!_fs().default.existsSync(finalPath)) {
        throw new Error(`File not found at \`updates.codeSigningCertificate\` path: ${finalPath}`);
      }
      return _fs().default.readFileSync(finalPath, "utf8");
    }
    function getUpdatesCodeSigningMetadata(config) {
      return config.updates?.codeSigningMetadata;
    }
    function getUpdatesCodeSigningMetadataStringified(config) {
      const metadata = getUpdatesCodeSigningMetadata(config);
      if (!metadata) {
        return void 0;
      }
      return JSON.stringify(metadata);
    }
    function getUpdatesRequestHeaders(config) {
      return config.updates?.requestHeaders;
    }
    function getUpdatesRequestHeadersStringified(config) {
      const metadata = getUpdatesRequestHeaders(config);
      if (!metadata) {
        return void 0;
      }
      return JSON.stringify(metadata);
    }
    function getDisableAntiBrickingMeasures(config) {
      return config.updates?.disableAntiBrickingMeasures;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/Updates.js
var require_Updates2 = __commonJS({
  "node_modules/@expo/config-plugins/build/android/Updates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Config = void 0;
    exports2.applyRuntimeVersionFromConfigAsync = applyRuntimeVersionFromConfigAsync;
    exports2.applyRuntimeVersionFromConfigForProjectRootAsync = applyRuntimeVersionFromConfigForProjectRootAsync;
    exports2.setUpdatesConfigAsync = setUpdatesConfigAsync;
    exports2.setVersionsConfigAsync = setVersionsConfigAsync;
    exports2.withUpdates = void 0;
    function _BuildProperties() {
      const data = require_BuildProperties();
      _BuildProperties = function() {
        return data;
      };
      return data;
    }
    function _Manifest() {
      const data = require_Manifest();
      _Manifest = function() {
        return data;
      };
      return data;
    }
    function _Resources() {
      const data = require_Resources();
      _Resources = function() {
        return data;
      };
      return data;
    }
    function _Strings() {
      const data = require_Strings();
      _Strings = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    function _withPlugins() {
      const data = require_withPlugins();
      _withPlugins = function() {
        return data;
      };
      return data;
    }
    function _Updates() {
      const data = require_Updates();
      _Updates = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    var Config = exports2.Config = /* @__PURE__ */ function(Config2) {
      Config2["ENABLED"] = "expo.modules.updates.ENABLED";
      Config2["CHECK_ON_LAUNCH"] = "expo.modules.updates.EXPO_UPDATES_CHECK_ON_LAUNCH";
      Config2["LAUNCH_WAIT_MS"] = "expo.modules.updates.EXPO_UPDATES_LAUNCH_WAIT_MS";
      Config2["RUNTIME_VERSION"] = "expo.modules.updates.EXPO_RUNTIME_VERSION";
      Config2["UPDATE_URL"] = "expo.modules.updates.EXPO_UPDATE_URL";
      Config2["UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY"] = "expo.modules.updates.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY";
      Config2["UPDATES_HAS_EMBEDDED_UPDATE"] = "expo.modules.updates.HAS_EMBEDDED_UPDATE";
      Config2["CODE_SIGNING_CERTIFICATE"] = "expo.modules.updates.CODE_SIGNING_CERTIFICATE";
      Config2["CODE_SIGNING_METADATA"] = "expo.modules.updates.CODE_SIGNING_METADATA";
      Config2["DISABLE_ANTI_BRICKING_MEASURES"] = "expo.modules.updates.DISABLE_ANTI_BRICKING_MEASURES";
      return Config2;
    }({});
    var withUpdates = (config) => {
      return (0, _withPlugins().withPlugins)(config, [withUpdatesManifest, withRuntimeVersionResource, withUpdatesNativeDebugGradleProps]);
    };
    exports2.withUpdates = withUpdates;
    var withUpdatesNativeDebugGradleProps = (0, _BuildProperties().createBuildGradlePropsConfigPlugin)([{
      propName: "EX_UPDATES_NATIVE_DEBUG",
      propValueGetter: (config) => config?.updates?.useNativeDebug === true ? "true" : void 0
    }], "withUpdatesNativeDebugGradleProps");
    var withUpdatesManifest = (config) => {
      return (0, _androidPlugins().withAndroidManifest)(config, async (config2) => {
        const projectRoot = config2.modRequest.projectRoot;
        const expoUpdatesPackageVersion = (0, _Updates().getExpoUpdatesPackageVersion)(projectRoot);
        config2.modResults = await setUpdatesConfigAsync(projectRoot, config2, config2.modResults, expoUpdatesPackageVersion);
        return config2;
      });
    };
    var withRuntimeVersionResource = (0, _androidPlugins().createStringsXmlPlugin)(applyRuntimeVersionFromConfigAsync, "withRuntimeVersionResource");
    async function applyRuntimeVersionFromConfigAsync(config, stringsJSON) {
      const projectRoot = config.modRequest.projectRoot;
      return await applyRuntimeVersionFromConfigForProjectRootAsync(projectRoot, config, stringsJSON);
    }
    async function applyRuntimeVersionFromConfigForProjectRootAsync(projectRoot, config, stringsJSON) {
      const runtimeVersion = await (0, _Updates().getRuntimeVersionNullableAsync)(projectRoot, config, "android");
      if (runtimeVersion) {
        return (0, _Strings().setStringItem)([(0, _Resources().buildResourceItem)({
          name: "expo_runtime_version",
          value: runtimeVersion
        })], stringsJSON);
      }
      return (0, _Strings().removeStringItem)("expo_runtime_version", stringsJSON);
    }
    async function setUpdatesConfigAsync(projectRoot, config, androidManifest, expoUpdatesPackageVersion) {
      const mainApplication = (0, _Manifest().getMainApplicationOrThrow)(androidManifest);
      (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.ENABLED, String((0, _Updates().getUpdatesEnabled)(config)));
      const checkOnLaunch = (0, _Updates().getUpdatesCheckOnLaunch)(config, expoUpdatesPackageVersion);
      (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.CHECK_ON_LAUNCH, checkOnLaunch);
      const timeout = (0, _Updates().getUpdatesTimeout)(config);
      (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.LAUNCH_WAIT_MS, String(timeout));
      const useEmbeddedUpdate = (0, _Updates().getUpdatesUseEmbeddedUpdate)(config);
      if (useEmbeddedUpdate) {
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, Config.UPDATES_HAS_EMBEDDED_UPDATE);
      } else {
        if (timeout === 0 && checkOnLaunch !== "ALWAYS") {
          (0, _warnings().addWarningAndroid)("updates.useEmbeddedUpdate", `updates.checkOnLaunch should be set to "ON_LOAD" and updates.fallbackToCacheTimeout should be set to a non-zero value when updates.useEmbeddedUpdate is set to false. This is because an update must be fetched on the initial launch, when no embedded update is available.`);
        }
        (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.UPDATES_HAS_EMBEDDED_UPDATE, "false");
      }
      const updateUrl = (0, _Updates().getUpdateUrl)(config);
      if (updateUrl) {
        (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.UPDATE_URL, updateUrl);
      } else {
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, Config.UPDATE_URL);
      }
      const codeSigningCertificate = (0, _Updates().getUpdatesCodeSigningCertificate)(projectRoot, config);
      if (codeSigningCertificate) {
        (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.CODE_SIGNING_CERTIFICATE, codeSigningCertificate);
      } else {
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, Config.CODE_SIGNING_CERTIFICATE);
      }
      const codeSigningMetadata = (0, _Updates().getUpdatesCodeSigningMetadataStringified)(config);
      if (codeSigningMetadata) {
        (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.CODE_SIGNING_METADATA, codeSigningMetadata);
      } else {
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, Config.CODE_SIGNING_METADATA);
      }
      const requestHeaders = (0, _Updates().getUpdatesRequestHeadersStringified)(config);
      if (requestHeaders) {
        (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY, requestHeaders);
      } else {
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, Config.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY);
      }
      const disableAntiBrickingMeasures = (0, _Updates().getDisableAntiBrickingMeasures)(config);
      if (disableAntiBrickingMeasures) {
        (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.DISABLE_ANTI_BRICKING_MEASURES, "true");
      } else {
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, Config.DISABLE_ANTI_BRICKING_MEASURES);
      }
      return await setVersionsConfigAsync(projectRoot, config, androidManifest);
    }
    async function setVersionsConfigAsync(projectRoot, config, androidManifest) {
      const mainApplication = (0, _Manifest().getMainApplicationOrThrow)(androidManifest);
      const runtimeVersion = await (0, _Updates().getRuntimeVersionNullableAsync)(projectRoot, config, "android");
      if (!runtimeVersion && (0, _Manifest().findMetaDataItem)(mainApplication, Config.RUNTIME_VERSION) > -1) {
        throw new Error("A runtime version is set in your AndroidManifest.xml, but is missing from your Expo app config (app.json/app.config.js). Either set runtimeVersion in your Expo app config or remove expo.modules.updates.EXPO_RUNTIME_VERSION from your AndroidManifest.xml.");
      }
      if (runtimeVersion) {
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, "expo.modules.updates.EXPO_SDK_VERSION");
        (0, _Manifest().addMetaDataItemToMainApplication)(mainApplication, Config.RUNTIME_VERSION, "@string/expo_runtime_version");
      } else {
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, Config.RUNTIME_VERSION);
        (0, _Manifest().removeMetaDataItemFromMainApplication)(mainApplication, "expo.modules.updates.EXPO_SDK_VERSION");
      }
      return androidManifest;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/WindowSoftInputMode.js
var require_WindowSoftInputMode = __commonJS({
  "node_modules/@expo/config-plugins/build/android/WindowSoftInputMode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getWindowSoftInputModeMode = getWindowSoftInputModeMode;
    exports2.setWindowSoftInputModeMode = setWindowSoftInputModeMode;
    exports2.withWindowSoftInputMode = void 0;
    function _Manifest() {
      const data = require_Manifest();
      _Manifest = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    var ANDROID_WINDOW_SOFT_INPUT_MODE = "android:windowSoftInputMode";
    var MAPPING = {
      pan: "adjustPan",
      resize: "adjustResize"
    };
    var withWindowSoftInputMode = (config) => {
      return (0, _androidPlugins().withAndroidManifest)(config, async (config2) => {
        config2.modResults = setWindowSoftInputModeMode(config2, config2.modResults);
        return config2;
      });
    };
    exports2.withWindowSoftInputMode = withWindowSoftInputMode;
    function setWindowSoftInputModeMode(config, androidManifest) {
      const app = (0, _Manifest().getMainActivityOrThrow)(androidManifest);
      app.$[ANDROID_WINDOW_SOFT_INPUT_MODE] = getWindowSoftInputModeMode(config);
      return androidManifest;
    }
    function getWindowSoftInputModeMode(config) {
      const value = config.android?.softwareKeyboardLayoutMode;
      if (!value) {
        return "adjustResize";
      }
      return MAPPING[value] ?? value;
    }
  }
});

// node_modules/@expo/config-plugins/build/android/index.js
var require_android = __commonJS({
  "node_modules/@expo/config-plugins/build/android/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WindowSoftInputMode = exports2.Version = exports2.Updates = exports2.Styles = exports2.Strings = exports2.StatusBar = exports2.Scheme = exports2.Resources = exports2.Properties = exports2.PrimaryColor = exports2.Permissions = exports2.Paths = exports2.Package = exports2.Orientation = exports2.Name = exports2.Manifest = exports2.Locales = exports2.IntentFilters = exports2.GoogleServices = exports2.GoogleMapsApiKey = exports2.EasBuild = exports2.Colors = exports2.BuildProperties = exports2.AllowBackup = void 0;
    function AllowBackup() {
      const data = _interopRequireWildcard(require_AllowBackup());
      AllowBackup = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "AllowBackup", {
      enumerable: true,
      get: function() {
        return AllowBackup();
      }
    });
    function BuildProperties() {
      const data = _interopRequireWildcard(require_BuildProperties());
      BuildProperties = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "BuildProperties", {
      enumerable: true,
      get: function() {
        return BuildProperties();
      }
    });
    function Colors() {
      const data = _interopRequireWildcard(require_Colors());
      Colors = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Colors", {
      enumerable: true,
      get: function() {
        return Colors();
      }
    });
    function EasBuild() {
      const data = _interopRequireWildcard(require_EasBuild());
      EasBuild = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "EasBuild", {
      enumerable: true,
      get: function() {
        return EasBuild();
      }
    });
    function GoogleMapsApiKey() {
      const data = _interopRequireWildcard(require_GoogleMapsApiKey());
      GoogleMapsApiKey = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "GoogleMapsApiKey", {
      enumerable: true,
      get: function() {
        return GoogleMapsApiKey();
      }
    });
    function GoogleServices() {
      const data = _interopRequireWildcard(require_GoogleServices());
      GoogleServices = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "GoogleServices", {
      enumerable: true,
      get: function() {
        return GoogleServices();
      }
    });
    function IntentFilters() {
      const data = _interopRequireWildcard(require_IntentFilters());
      IntentFilters = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "IntentFilters", {
      enumerable: true,
      get: function() {
        return IntentFilters();
      }
    });
    function Locales() {
      const data = _interopRequireWildcard(require_Locales());
      Locales = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Locales", {
      enumerable: true,
      get: function() {
        return Locales();
      }
    });
    function Manifest() {
      const data = _interopRequireWildcard(require_Manifest());
      Manifest = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Manifest", {
      enumerable: true,
      get: function() {
        return Manifest();
      }
    });
    function Name() {
      const data = _interopRequireWildcard(require_Name());
      Name = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function() {
        return Name();
      }
    });
    function Orientation() {
      const data = _interopRequireWildcard(require_Orientation());
      Orientation = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Orientation", {
      enumerable: true,
      get: function() {
        return Orientation();
      }
    });
    function Package() {
      const data = _interopRequireWildcard(require_Package());
      Package = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Package", {
      enumerable: true,
      get: function() {
        return Package();
      }
    });
    function Paths() {
      const data = _interopRequireWildcard(require_Paths());
      Paths = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Paths", {
      enumerable: true,
      get: function() {
        return Paths();
      }
    });
    function Permissions() {
      const data = _interopRequireWildcard(require_Permissions());
      Permissions = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Permissions", {
      enumerable: true,
      get: function() {
        return Permissions();
      }
    });
    function PrimaryColor() {
      const data = _interopRequireWildcard(require_PrimaryColor());
      PrimaryColor = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "PrimaryColor", {
      enumerable: true,
      get: function() {
        return PrimaryColor();
      }
    });
    function Properties() {
      const data = _interopRequireWildcard(require_Properties());
      Properties = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Properties", {
      enumerable: true,
      get: function() {
        return Properties();
      }
    });
    function Resources() {
      const data = _interopRequireWildcard(require_Resources());
      Resources = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Resources", {
      enumerable: true,
      get: function() {
        return Resources();
      }
    });
    function Scheme() {
      const data = _interopRequireWildcard(require_Scheme());
      Scheme = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Scheme", {
      enumerable: true,
      get: function() {
        return Scheme();
      }
    });
    function StatusBar() {
      const data = _interopRequireWildcard(require_StatusBar());
      StatusBar = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "StatusBar", {
      enumerable: true,
      get: function() {
        return StatusBar();
      }
    });
    function Strings() {
      const data = _interopRequireWildcard(require_Strings());
      Strings = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Strings", {
      enumerable: true,
      get: function() {
        return Strings();
      }
    });
    function Styles() {
      const data = _interopRequireWildcard(require_Styles());
      Styles = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Styles", {
      enumerable: true,
      get: function() {
        return Styles();
      }
    });
    function Updates() {
      const data = _interopRequireWildcard(require_Updates2());
      Updates = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Updates", {
      enumerable: true,
      get: function() {
        return Updates();
      }
    });
    function Version() {
      const data = _interopRequireWildcard(require_Version());
      Version = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Version", {
      enumerable: true,
      get: function() {
        return Version();
      }
    });
    function WindowSoftInputMode() {
      const data = _interopRequireWildcard(require_WindowSoftInputMode());
      WindowSoftInputMode = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "WindowSoftInputMode", {
      enumerable: true,
      get: function() {
        return WindowSoftInputMode();
      }
    });
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
  }
});

// node_modules/slugify/slugify.js
var require_slugify = __commonJS({
  "node_modules/slugify/slugify.js"(exports2, module2) {
    "use strict";
    (function(name, root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = factory();
        module2.exports["default"] = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root2[name] = factory();
      }
    })("slugify", exports2, function() {
      var charMap = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","\xA2":"cent","\xA3":"pound","\xA4":"currency","\xA5":"yen","\xA9":"(c)","\xAA":"a","\xAE":"(r)","\xBA":"o","\xC0":"A","\xC1":"A","\xC2":"A","\xC3":"A","\xC4":"A","\xC5":"A","\xC6":"AE","\xC7":"C","\xC8":"E","\xC9":"E","\xCA":"E","\xCB":"E","\xCC":"I","\xCD":"I","\xCE":"I","\xCF":"I","\xD0":"D","\xD1":"N","\xD2":"O","\xD3":"O","\xD4":"O","\xD5":"O","\xD6":"O","\xD8":"O","\xD9":"U","\xDA":"U","\xDB":"U","\xDC":"U","\xDD":"Y","\xDE":"TH","\xDF":"ss","\xE0":"a","\xE1":"a","\xE2":"a","\xE3":"a","\xE4":"a","\xE5":"a","\xE6":"ae","\xE7":"c","\xE8":"e","\xE9":"e","\xEA":"e","\xEB":"e","\xEC":"i","\xED":"i","\xEE":"i","\xEF":"i","\xF0":"d","\xF1":"n","\xF2":"o","\xF3":"o","\xF4":"o","\xF5":"o","\xF6":"o","\xF8":"o","\xF9":"u","\xFA":"u","\xFB":"u","\xFC":"u","\xFD":"y","\xFE":"th","\xFF":"y","\u0100":"A","\u0101":"a","\u0102":"A","\u0103":"a","\u0104":"A","\u0105":"a","\u0106":"C","\u0107":"c","\u010C":"C","\u010D":"c","\u010E":"D","\u010F":"d","\u0110":"DJ","\u0111":"dj","\u0112":"E","\u0113":"e","\u0116":"E","\u0117":"e","\u0118":"e","\u0119":"e","\u011A":"E","\u011B":"e","\u011E":"G","\u011F":"g","\u0122":"G","\u0123":"g","\u0128":"I","\u0129":"i","\u012A":"i","\u012B":"i","\u012E":"I","\u012F":"i","\u0130":"I","\u0131":"i","\u0136":"k","\u0137":"k","\u013B":"L","\u013C":"l","\u013D":"L","\u013E":"l","\u0141":"L","\u0142":"l","\u0143":"N","\u0144":"n","\u0145":"N","\u0146":"n","\u0147":"N","\u0148":"n","\u014C":"O","\u014D":"o","\u0150":"O","\u0151":"o","\u0152":"OE","\u0153":"oe","\u0154":"R","\u0155":"r","\u0158":"R","\u0159":"r","\u015A":"S","\u015B":"s","\u015E":"S","\u015F":"s","\u0160":"S","\u0161":"s","\u0162":"T","\u0163":"t","\u0164":"T","\u0165":"t","\u0168":"U","\u0169":"u","\u016A":"u","\u016B":"u","\u016E":"U","\u016F":"u","\u0170":"U","\u0171":"u","\u0172":"U","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017A":"z","\u017B":"Z","\u017C":"z","\u017D":"Z","\u017E":"z","\u018F":"E","\u0192":"f","\u01A0":"O","\u01A1":"o","\u01AF":"U","\u01B0":"u","\u01C8":"LJ","\u01C9":"lj","\u01CB":"NJ","\u01CC":"nj","\u0218":"S","\u0219":"s","\u021A":"T","\u021B":"t","\u0259":"e","\u02DA":"o","\u0386":"A","\u0388":"E","\u0389":"H","\u038A":"I","\u038C":"O","\u038E":"Y","\u038F":"W","\u0390":"i","\u0391":"A","\u0392":"B","\u0393":"G","\u0394":"D","\u0395":"E","\u0396":"Z","\u0397":"H","\u0398":"8","\u0399":"I","\u039A":"K","\u039B":"L","\u039C":"M","\u039D":"N","\u039E":"3","\u039F":"O","\u03A0":"P","\u03A1":"R","\u03A3":"S","\u03A4":"T","\u03A5":"Y","\u03A6":"F","\u03A7":"X","\u03A8":"PS","\u03A9":"W","\u03AA":"I","\u03AB":"Y","\u03AC":"a","\u03AD":"e","\u03AE":"h","\u03AF":"i","\u03B0":"y","\u03B1":"a","\u03B2":"b","\u03B3":"g","\u03B4":"d","\u03B5":"e","\u03B6":"z","\u03B7":"h","\u03B8":"8","\u03B9":"i","\u03BA":"k","\u03BB":"l","\u03BC":"m","\u03BD":"n","\u03BE":"3","\u03BF":"o","\u03C0":"p","\u03C1":"r","\u03C2":"s","\u03C3":"s","\u03C4":"t","\u03C5":"y","\u03C6":"f","\u03C7":"x","\u03C8":"ps","\u03C9":"w","\u03CA":"i","\u03CB":"y","\u03CC":"o","\u03CD":"y","\u03CE":"w","\u0401":"Yo","\u0402":"DJ","\u0404":"Ye","\u0406":"I","\u0407":"Yi","\u0408":"J","\u0409":"LJ","\u040A":"NJ","\u040B":"C","\u040F":"DZ","\u0410":"A","\u0411":"B","\u0412":"V","\u0413":"G","\u0414":"D","\u0415":"E","\u0416":"Zh","\u0417":"Z","\u0418":"I","\u0419":"J","\u041A":"K","\u041B":"L","\u041C":"M","\u041D":"N","\u041E":"O","\u041F":"P","\u0420":"R","\u0421":"S","\u0422":"T","\u0423":"U","\u0424":"F","\u0425":"H","\u0426":"C","\u0427":"Ch","\u0428":"Sh","\u0429":"Sh","\u042A":"U","\u042B":"Y","\u042C":"","\u042D":"E","\u042E":"Yu","\u042F":"Ya","\u0430":"a","\u0431":"b","\u0432":"v","\u0433":"g","\u0434":"d","\u0435":"e","\u0436":"zh","\u0437":"z","\u0438":"i","\u0439":"j","\u043A":"k","\u043B":"l","\u043C":"m","\u043D":"n","\u043E":"o","\u043F":"p","\u0440":"r","\u0441":"s","\u0442":"t","\u0443":"u","\u0444":"f","\u0445":"h","\u0446":"c","\u0447":"ch","\u0448":"sh","\u0449":"sh","\u044A":"u","\u044B":"y","\u044C":"","\u044D":"e","\u044E":"yu","\u044F":"ya","\u0451":"yo","\u0452":"dj","\u0454":"ye","\u0456":"i","\u0457":"yi","\u0458":"j","\u0459":"lj","\u045A":"nj","\u045B":"c","\u045D":"u","\u045F":"dz","\u0490":"G","\u0491":"g","\u0492":"GH","\u0493":"gh","\u049A":"KH","\u049B":"kh","\u04A2":"NG","\u04A3":"ng","\u04AE":"UE","\u04AF":"ue","\u04B0":"U","\u04B1":"u","\u04BA":"H","\u04BB":"h","\u04D8":"AE","\u04D9":"ae","\u04E8":"OE","\u04E9":"oe","\u0531":"A","\u0532":"B","\u0533":"G","\u0534":"D","\u0535":"E","\u0536":"Z","\u0537":"E'","\u0538":"Y'","\u0539":"T'","\u053A":"JH","\u053B":"I","\u053C":"L","\u053D":"X","\u053E":"C'","\u053F":"K","\u0540":"H","\u0541":"D'","\u0542":"GH","\u0543":"TW","\u0544":"M","\u0545":"Y","\u0546":"N","\u0547":"SH","\u0549":"CH","\u054A":"P","\u054B":"J","\u054C":"R'","\u054D":"S","\u054E":"V","\u054F":"T","\u0550":"R","\u0551":"C","\u0553":"P'","\u0554":"Q'","\u0555":"O''","\u0556":"F","\u0587":"EV","\u0621":"a","\u0622":"aa","\u0623":"a","\u0624":"u","\u0625":"i","\u0626":"e","\u0627":"a","\u0628":"b","\u0629":"h","\u062A":"t","\u062B":"th","\u062C":"j","\u062D":"h","\u062E":"kh","\u062F":"d","\u0630":"th","\u0631":"r","\u0632":"z","\u0633":"s","\u0634":"sh","\u0635":"s","\u0636":"dh","\u0637":"t","\u0638":"z","\u0639":"a","\u063A":"gh","\u0641":"f","\u0642":"q","\u0643":"k","\u0644":"l","\u0645":"m","\u0646":"n","\u0647":"h","\u0648":"w","\u0649":"a","\u064A":"y","\u064B":"an","\u064C":"on","\u064D":"en","\u064E":"a","\u064F":"u","\u0650":"e","\u0652":"","\u0660":"0","\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u067E":"p","\u0686":"ch","\u0698":"zh","\u06A9":"k","\u06AF":"g","\u06CC":"y","\u06F0":"0","\u06F1":"1","\u06F2":"2","\u06F3":"3","\u06F4":"4","\u06F5":"5","\u06F6":"6","\u06F7":"7","\u06F8":"8","\u06F9":"9","\u0E3F":"baht","\u10D0":"a","\u10D1":"b","\u10D2":"g","\u10D3":"d","\u10D4":"e","\u10D5":"v","\u10D6":"z","\u10D7":"t","\u10D8":"i","\u10D9":"k","\u10DA":"l","\u10DB":"m","\u10DC":"n","\u10DD":"o","\u10DE":"p","\u10DF":"zh","\u10E0":"r","\u10E1":"s","\u10E2":"t","\u10E3":"u","\u10E4":"f","\u10E5":"k","\u10E6":"gh","\u10E7":"q","\u10E8":"sh","\u10E9":"ch","\u10EA":"ts","\u10EB":"dz","\u10EC":"ts","\u10ED":"ch","\u10EE":"kh","\u10EF":"j","\u10F0":"h","\u1E62":"S","\u1E63":"s","\u1E80":"W","\u1E81":"w","\u1E82":"W","\u1E83":"w","\u1E84":"W","\u1E85":"w","\u1E9E":"SS","\u1EA0":"A","\u1EA1":"a","\u1EA2":"A","\u1EA3":"a","\u1EA4":"A","\u1EA5":"a","\u1EA6":"A","\u1EA7":"a","\u1EA8":"A","\u1EA9":"a","\u1EAA":"A","\u1EAB":"a","\u1EAC":"A","\u1EAD":"a","\u1EAE":"A","\u1EAF":"a","\u1EB0":"A","\u1EB1":"a","\u1EB2":"A","\u1EB3":"a","\u1EB4":"A","\u1EB5":"a","\u1EB6":"A","\u1EB7":"a","\u1EB8":"E","\u1EB9":"e","\u1EBA":"E","\u1EBB":"e","\u1EBC":"E","\u1EBD":"e","\u1EBE":"E","\u1EBF":"e","\u1EC0":"E","\u1EC1":"e","\u1EC2":"E","\u1EC3":"e","\u1EC4":"E","\u1EC5":"e","\u1EC6":"E","\u1EC7":"e","\u1EC8":"I","\u1EC9":"i","\u1ECA":"I","\u1ECB":"i","\u1ECC":"O","\u1ECD":"o","\u1ECE":"O","\u1ECF":"o","\u1ED0":"O","\u1ED1":"o","\u1ED2":"O","\u1ED3":"o","\u1ED4":"O","\u1ED5":"o","\u1ED6":"O","\u1ED7":"o","\u1ED8":"O","\u1ED9":"o","\u1EDA":"O","\u1EDB":"o","\u1EDC":"O","\u1EDD":"o","\u1EDE":"O","\u1EDF":"o","\u1EE0":"O","\u1EE1":"o","\u1EE2":"O","\u1EE3":"o","\u1EE4":"U","\u1EE5":"u","\u1EE6":"U","\u1EE7":"u","\u1EE8":"U","\u1EE9":"u","\u1EEA":"U","\u1EEB":"u","\u1EEC":"U","\u1EED":"u","\u1EEE":"U","\u1EEF":"u","\u1EF0":"U","\u1EF1":"u","\u1EF2":"Y","\u1EF3":"y","\u1EF4":"Y","\u1EF5":"y","\u1EF6":"Y","\u1EF7":"y","\u1EF8":"Y","\u1EF9":"y","\u2013":"-","\u2018":"'","\u2019":"'","\u201C":"\\"","\u201D":"\\"","\u201E":"\\"","\u2020":"+","\u2022":"*","\u2026":"...","\u20A0":"ecu","\u20A2":"cruzeiro","\u20A3":"french franc","\u20A4":"lira","\u20A5":"mill","\u20A6":"naira","\u20A7":"peseta","\u20A8":"rupee","\u20A9":"won","\u20AA":"new shequel","\u20AB":"dong","\u20AC":"euro","\u20AD":"kip","\u20AE":"tugrik","\u20AF":"drachma","\u20B0":"penny","\u20B1":"peso","\u20B2":"guarani","\u20B3":"austral","\u20B4":"hryvnia","\u20B5":"cedi","\u20B8":"kazakhstani tenge","\u20B9":"indian rupee","\u20BA":"turkish lira","\u20BD":"russian ruble","\u20BF":"bitcoin","\u2120":"sm","\u2122":"tm","\u2202":"d","\u2206":"delta","\u2211":"sum","\u221E":"infinity","\u2665":"love","\u5143":"yuan","\u5186":"yen","\uFDFC":"rial","\uFEF5":"laa","\uFEF7":"laa","\uFEF9":"lai","\uFEFB":"la"}`);
      var locales = JSON.parse('{"bg":{"\u0419":"Y","\u0426":"Ts","\u0429":"Sht","\u042A":"A","\u042C":"Y","\u0439":"y","\u0446":"ts","\u0449":"sht","\u044A":"a","\u044C":"y"},"de":{"\xC4":"AE","\xE4":"ae","\xD6":"OE","\xF6":"oe","\xDC":"UE","\xFC":"ue","\xDF":"ss","%":"prozent","&":"und","|":"oder","\u2211":"summe","\u221E":"unendlich","\u2665":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","\xA2":"centavos","\xA3":"libras","\xA4":"moneda","\u20A3":"francos","\u2211":"suma","\u221E":"infinito","\u2665":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","\xA2":"centime","\xA3":"livre","\xA4":"devise","\u20A3":"franc","\u2211":"somme","\u221E":"infini","\u2665":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","\xA2":"centavo","\u2211":"soma","\xA3":"libra","\u221E":"infinito","\u2665":"amor"},"uk":{"\u0418":"Y","\u0438":"y","\u0419":"Y","\u0439":"y","\u0426":"Ts","\u0446":"ts","\u0425":"Kh","\u0445":"kh","\u0429":"Shch","\u0449":"shch","\u0413":"H","\u0433":"h"},"vi":{"\u0110":"D","\u0111":"d"},"da":{"\xD8":"OE","\xF8":"oe","\xC5":"AA","\xE5":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"st\xF8rre end"},"nb":{"&":"og","\xC5":"AA","\xC6":"AE","\xD8":"OE","\xE5":"aa","\xE6":"ae","\xF8":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","\xC5":"AA","\xC4":"AE","\xD6":"OE","\xE5":"aa","\xE4":"ae","\xF6":"oe"}}');
      function replace(string, options) {
        if (typeof string !== "string") {
          throw new Error("slugify: string argument expected");
        }
        options = typeof options === "string" ? { replacement: options } : options || {};
        var locale = locales[options.locale] || {};
        var replacement = options.replacement === void 0 ? "-" : options.replacement;
        var trim = options.trim === void 0 ? true : options.trim;
        var slug = string.normalize().split("").reduce(function(result, ch) {
          var appendChar = locale[ch];
          if (appendChar === void 0) appendChar = charMap[ch];
          if (appendChar === void 0) appendChar = ch;
          if (appendChar === replacement) appendChar = " ";
          return result + appendChar.replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "");
        if (options.strict) {
          slug = slug.replace(/[^A-Za-z0-9\s]/g, "");
        }
        if (trim) {
          slug = slug.trim();
        }
        slug = slug.replace(/\s+/g, replacement);
        if (options.lower) {
          slug = slug.toLowerCase();
        }
        return slug;
      }
      replace.extend = function(customMap) {
        Object.assign(charMap, customMap);
      };
      return replace;
    });
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  return import_crypto.default.randomBytes(16);
}
var import_crypto;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    "use strict";
    import_crypto = __toESM(require("crypto"));
  }
});

// node_modules/uuid/dist/esm-node/bytesToUuid.js
function bytesToUuid(buf, offset) {
  var i2 = offset || 0;
  var bth = byteToHex;
  return [bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]]].join("");
}
var byteToHex, i2, bytesToUuid_default;
var init_bytesToUuid = __esm({
  "node_modules/uuid/dist/esm-node/bytesToUuid.js"() {
    "use strict";
    byteToHex = [];
    for (i2 = 0; i2 < 256; ++i2) {
      byteToHex[i2] = (i2 + 256).toString(16).substr(1);
    }
    bytesToUuid_default = bytesToUuid;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  var i2 = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i2++] = tl >>> 24 & 255;
  b[i2++] = tl >>> 16 & 255;
  b[i2++] = tl >>> 8 & 255;
  b[i2++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i2++] = tmh >>> 8 & 255;
  b[i2++] = tmh & 255;
  b[i2++] = tmh >>> 24 & 15 | 16;
  b[i2++] = tmh >>> 16 & 255;
  b[i2++] = clockseq >>> 8 | 128;
  b[i2++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i2 + n] = node[n];
  }
  return buf ? buf : bytesToUuid_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    "use strict";
    init_rng();
    init_bytesToUuid();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/v35.js
function uuidToBytes(uuid) {
  var bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
    bytes.push(parseInt(hex, 16));
  });
  return bytes;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = new Array(str.length);
  for (var i2 = 0; i2 < str.length; i2++) {
    bytes[i2] = str.charCodeAt(i2);
  }
  return bytes;
}
function v35_default(name, version, hashfunc) {
  var generateUUID = function(value, namespace, buf, offset) {
    var off = buf && offset || 0;
    if (typeof value == "string") value = stringToBytes(value);
    if (typeof namespace == "string") namespace = uuidToBytes(namespace);
    if (!Array.isArray(value)) throw TypeError("value must be an array of bytes");
    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError("namespace must be uuid string or an Array of 16 byte values");
    var bytes = hashfunc(namespace.concat(value));
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      for (var idx = 0; idx < 16; ++idx) {
        buf[off + idx] = bytes[idx];
      }
    }
    return buf || bytesToUuid_default(bytes);
  };
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-node/v35.js"() {
    "use strict";
    init_bytesToUuid();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-node/md5.js"() {
    "use strict";
    import_crypto2 = __toESM(require("crypto"));
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-node/v3.js"() {
    "use strict";
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  var i2 = buf && offset || 0;
  if (typeof options == "string") {
    buf = options === "binary" ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i2 + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    "use strict";
    init_rng();
    init_bytesToUuid();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto3.default.createHash("sha1").update(bytes).digest();
}
var import_crypto3, sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-node/sha1.js"() {
    "use strict";
    import_crypto3 = __toESM(require("crypto"));
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-node/v5.js"() {
    "use strict";
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default
});
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    "use strict";
    init_v1();
    init_v3();
    init_v4();
    init_v5();
  }
});

// node_modules/xcode/lib/pbxWriter.js
var require_pbxWriter = __commonJS({
  "node_modules/xcode/lib/pbxWriter.js"(exports2, module2) {
    "use strict";
    var pbxProj = require_pbxProject();
    var util2 = require("util");
    var f = util2.format;
    var INDENT = "	";
    var COMMENT_KEY = /_comment$/;
    var EventEmitter = require("events").EventEmitter;
    function i2(x) {
      if (x <= 0)
        return "";
      else
        return INDENT + i2(x - 1);
    }
    function comment(key3, parent) {
      var text = parent[key3 + "_comment"];
      if (text)
        return text;
      else
        return null;
    }
    function isObject(obj) {
      return obj === Object(obj);
    }
    function isArray(obj) {
      return Array.isArray(obj);
    }
    function pbxWriter(contents, options) {
      if (!options) {
        options = {};
      }
      if (options.omitEmptyValues === void 0) {
        options.omitEmptyValues = false;
      }
      this.contents = contents;
      this.sync = false;
      this.indentLevel = 0;
      this.omitEmptyValues = options.omitEmptyValues;
    }
    util2.inherits(pbxWriter, EventEmitter);
    pbxWriter.prototype.write = function(str) {
      var fmt = f.apply(null, arguments);
      if (this.sync) {
        this.buffer += f("%s%s", i2(this.indentLevel), fmt);
      } else {
      }
    };
    pbxWriter.prototype.writeFlush = function(str) {
      var oldIndent = this.indentLevel;
      this.indentLevel = 0;
      this.write.apply(this, arguments);
      this.indentLevel = oldIndent;
    };
    pbxWriter.prototype.writeSync = function() {
      this.sync = true;
      this.buffer = "";
      this.writeHeadComment();
      this.writeProject();
      return this.buffer;
    };
    pbxWriter.prototype.writeHeadComment = function() {
      if (this.contents.headComment) {
        this.write("// %s\n", this.contents.headComment);
      }
    };
    pbxWriter.prototype.writeProject = function() {
      var proj = this.contents.project, key3, cmt, obj;
      this.write("{\n");
      if (proj) {
        this.indentLevel++;
        for (key3 in proj) {
          if (COMMENT_KEY.test(key3)) continue;
          cmt = comment(key3, proj);
          obj = proj[key3];
          if (isArray(obj)) {
            this.writeArray(obj, key3);
          } else if (isObject(obj)) {
            this.write("%s = {\n", key3);
            this.indentLevel++;
            if (key3 === "objects") {
              this.writeObjectsSections(obj);
            } else {
              this.writeObject(obj);
            }
            this.indentLevel--;
            this.write("};\n");
          } else if (this.omitEmptyValues && (obj === void 0 || obj === null)) {
            continue;
          } else if (cmt) {
            this.write("%s = %s /* %s */;\n", key3, obj, cmt);
          } else {
            this.write("%s = %s;\n", key3, obj);
          }
        }
        this.indentLevel--;
      }
      this.write("}\n");
    };
    pbxWriter.prototype.writeObject = function(object) {
      var key3, obj, cmt;
      for (key3 in object) {
        if (COMMENT_KEY.test(key3)) continue;
        cmt = comment(key3, object);
        obj = object[key3];
        if (isArray(obj)) {
          this.writeArray(obj, key3);
        } else if (isObject(obj)) {
          this.write("%s = {\n", key3);
          this.indentLevel++;
          this.writeObject(obj);
          this.indentLevel--;
          this.write("};\n");
        } else {
          if (this.omitEmptyValues && (obj === void 0 || obj === null)) {
            continue;
          } else if (cmt) {
            this.write("%s = %s /* %s */;\n", key3, obj, cmt);
          } else {
            this.write("%s = %s;\n", key3, obj);
          }
        }
      }
    };
    pbxWriter.prototype.writeObjectsSections = function(objects) {
      var key3, obj;
      for (key3 in objects) {
        this.writeFlush("\n");
        obj = objects[key3];
        if (isObject(obj)) {
          this.writeSectionComment(key3, true);
          this.writeSection(obj);
          this.writeSectionComment(key3, false);
        }
      }
    };
    pbxWriter.prototype.writeArray = function(arr, name) {
      var i3, entry;
      this.write("%s = (\n", name);
      this.indentLevel++;
      for (i3 = 0; i3 < arr.length; i3++) {
        entry = arr[i3];
        if (entry.value && entry.comment) {
          this.write("%s /* %s */,\n", entry.value, entry.comment);
        } else if (isObject(entry)) {
          this.write("{\n");
          this.indentLevel++;
          this.writeObject(entry);
          this.indentLevel--;
          this.write("},\n");
        } else {
          this.write("%s,\n", entry);
        }
      }
      this.indentLevel--;
      this.write(");\n");
    };
    pbxWriter.prototype.writeSectionComment = function(name, begin) {
      if (begin) {
        this.writeFlush("/* Begin %s section */\n", name);
      } else {
        this.writeFlush("/* End %s section */\n", name);
      }
    };
    pbxWriter.prototype.writeSection = function(section) {
      var key3, obj, cmt;
      for (key3 in section) {
        if (COMMENT_KEY.test(key3)) continue;
        cmt = comment(key3, section);
        obj = section[key3];
        if (obj.isa == "PBXBuildFile" || obj.isa == "PBXFileReference") {
          this.writeInlineObject(key3, cmt, obj);
        } else {
          if (cmt) {
            this.write("%s /* %s */ = {\n", key3, cmt);
          } else {
            this.write("%s = {\n", key3);
          }
          this.indentLevel++;
          this.writeObject(obj);
          this.indentLevel--;
          this.write("};\n");
        }
      }
    };
    pbxWriter.prototype.writeInlineObject = function(n, d, r) {
      var output = [];
      var self = this;
      var inlineObjectHelper = function(name, desc, ref) {
        var key3, cmt, obj;
        if (desc) {
          output.push(f("%s /* %s */ = {", name, desc));
        } else {
          output.push(f("%s = {", name));
        }
        for (key3 in ref) {
          if (COMMENT_KEY.test(key3)) continue;
          cmt = comment(key3, ref);
          obj = ref[key3];
          if (isArray(obj)) {
            output.push(f("%s = (", key3));
            for (var i3 = 0; i3 < obj.length; i3++) {
              output.push(f("%s, ", obj[i3]));
            }
            output.push("); ");
          } else if (isObject(obj)) {
            inlineObjectHelper(key3, cmt, obj);
          } else if (self.omitEmptyValues && (obj === void 0 || obj === null)) {
            continue;
          } else if (cmt) {
            output.push(f("%s = %s /* %s */; ", key3, obj, cmt));
          } else {
            output.push(f("%s = %s; ", key3, obj));
          }
        }
        output.push("}; ");
      };
      inlineObjectHelper(n, d, r);
      this.write("%s\n", output.join("").trim());
    };
    module2.exports = pbxWriter;
  }
});

// node_modules/xcode/lib/pbxFile.js
var require_pbxFile = __commonJS({
  "node_modules/xcode/lib/pbxFile.js"(exports2, module2) {
    "use strict";
    var path11 = require("path");
    var util2 = require("util");
    var DEFAULT_SOURCETREE = '"<group>"';
    var DEFAULT_PRODUCT_SOURCETREE = "BUILT_PRODUCTS_DIR";
    var DEFAULT_GROUP = "Resources";
    var DEFAULT_FILETYPE = "unknown";
    var FILETYPE_BY_EXTENSION = {
      a: "archive.ar",
      app: "wrapper.application",
      appex: "wrapper.app-extension",
      bundle: "wrapper.plug-in",
      dylib: "compiled.mach-o.dylib",
      framework: "wrapper.framework",
      h: "sourcecode.c.h",
      m: "sourcecode.c.objc",
      markdown: "text",
      mdimporter: "wrapper.cfbundle",
      octest: "wrapper.cfbundle",
      pch: "sourcecode.c.h",
      plist: "text.plist.xml",
      sh: "text.script.sh",
      swift: "sourcecode.swift",
      tbd: "sourcecode.text-based-dylib-definition",
      xcassets: "folder.assetcatalog",
      xcconfig: "text.xcconfig",
      xcdatamodel: "wrapper.xcdatamodel",
      xcodeproj: "wrapper.pb-project",
      xctest: "wrapper.cfbundle",
      xib: "file.xib",
      strings: "text.plist.strings"
    };
    var GROUP_BY_FILETYPE = {
      "archive.ar": "Frameworks",
      "compiled.mach-o.dylib": "Frameworks",
      "sourcecode.text-based-dylib-definition": "Frameworks",
      "wrapper.framework": "Frameworks",
      "embedded.framework": "Embed Frameworks",
      "sourcecode.c.h": "Resources",
      "sourcecode.c.objc": "Sources",
      "sourcecode.swift": "Sources"
    };
    var PATH_BY_FILETYPE = {
      "compiled.mach-o.dylib": "usr/lib/",
      "sourcecode.text-based-dylib-definition": "usr/lib/",
      "wrapper.framework": "System/Library/Frameworks/"
    };
    var SOURCETREE_BY_FILETYPE = {
      "compiled.mach-o.dylib": "SDKROOT",
      "sourcecode.text-based-dylib-definition": "SDKROOT",
      "wrapper.framework": "SDKROOT"
    };
    var ENCODING_BY_FILETYPE = {
      "sourcecode.c.h": 4,
      "sourcecode.c.h": 4,
      "sourcecode.c.objc": 4,
      "sourcecode.swift": 4,
      "text": 4,
      "text.plist.xml": 4,
      "text.script.sh": 4,
      "text.xcconfig": 4,
      "text.plist.strings": 4
    };
    function unquoted(text) {
      return text == null ? "" : text.replace(/(^")|("$)/g, "");
    }
    function detectType(filePath) {
      var extension = path11.extname(filePath).substring(1), filetype = FILETYPE_BY_EXTENSION[unquoted(extension)];
      if (!filetype) {
        return DEFAULT_FILETYPE;
      }
      return filetype;
    }
    function defaultExtension(fileRef) {
      var filetype = fileRef.lastKnownFileType && fileRef.lastKnownFileType != DEFAULT_FILETYPE ? fileRef.lastKnownFileType : fileRef.explicitFileType;
      for (var extension in FILETYPE_BY_EXTENSION) {
        if (FILETYPE_BY_EXTENSION.hasOwnProperty(unquoted(extension))) {
          if (FILETYPE_BY_EXTENSION[unquoted(extension)] === unquoted(filetype))
            return extension;
        }
      }
    }
    function defaultEncoding(fileRef) {
      var filetype = fileRef.lastKnownFileType || fileRef.explicitFileType, encoding = ENCODING_BY_FILETYPE[unquoted(filetype)];
      if (encoding) {
        return encoding;
      }
    }
    function detectGroup(fileRef, opt) {
      var extension = path11.extname(fileRef.basename).substring(1), filetype = fileRef.lastKnownFileType || fileRef.explicitFileType, groupName = GROUP_BY_FILETYPE[unquoted(filetype)];
      if (extension === "xcdatamodeld") {
        return "Sources";
      }
      if (opt.customFramework && opt.embed) {
        return GROUP_BY_FILETYPE["embedded.framework"];
      }
      if (!groupName) {
        return DEFAULT_GROUP;
      }
      return groupName;
    }
    function detectSourcetree(fileRef) {
      var filetype = fileRef.lastKnownFileType || fileRef.explicitFileType, sourcetree = SOURCETREE_BY_FILETYPE[unquoted(filetype)];
      if (fileRef.explicitFileType) {
        return DEFAULT_PRODUCT_SOURCETREE;
      }
      if (fileRef.customFramework) {
        return DEFAULT_SOURCETREE;
      }
      if (!sourcetree) {
        return DEFAULT_SOURCETREE;
      }
      return sourcetree;
    }
    function defaultPath(fileRef, filePath) {
      var filetype = fileRef.lastKnownFileType || fileRef.explicitFileType, defaultPath2 = PATH_BY_FILETYPE[unquoted(filetype)];
      if (fileRef.customFramework) {
        return filePath;
      }
      if (defaultPath2) {
        return path11.join(defaultPath2, path11.basename(filePath));
      }
      return filePath;
    }
    function pbxFile(filepath, opt) {
      var opt = opt || {};
      this.basename = path11.basename(filepath);
      this.lastKnownFileType = opt.lastKnownFileType || detectType(filepath);
      this.group = detectGroup(this, opt);
      if (opt.customFramework == true) {
        this.customFramework = true;
        this.dirname = path11.dirname(filepath).replace(/\\/g, "/");
      }
      this.path = defaultPath(this, filepath).replace(/\\/g, "/");
      this.fileEncoding = this.defaultEncoding = opt.defaultEncoding || defaultEncoding(this);
      if (opt.explicitFileType) {
        this.explicitFileType = opt.explicitFileType;
        this.basename = this.basename + "." + defaultExtension(this);
        delete this.path;
        delete this.lastKnownFileType;
        delete this.group;
        delete this.defaultEncoding;
      }
      this.sourceTree = opt.sourceTree || detectSourcetree(this);
      this.includeInIndex = 0;
      if (opt.weak && opt.weak === true)
        this.settings = { ATTRIBUTES: ["Weak"] };
      if (opt.compilerFlags) {
        if (!this.settings)
          this.settings = {};
        this.settings.COMPILER_FLAGS = util2.format('"%s"', opt.compilerFlags);
      }
      if (opt.embed && opt.sign) {
        if (!this.settings)
          this.settings = {};
        if (!this.settings.ATTRIBUTES)
          this.settings.ATTRIBUTES = [];
        this.settings.ATTRIBUTES.push("CodeSignOnCopy");
      }
    }
    module2.exports = pbxFile;
  }
});

// node_modules/xcode/lib/parser/pbxproj.js
var require_pbxproj = __commonJS({
  "node_modules/xcode/lib/parser/pbxproj.js"(exports2, module2) {
    "use strict";
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        "class": function(expectation) {
          var escapedParts = "", i2;
          for (i2 = 0; i2 < expectation.parts.length; i2++) {
            escapedParts += expectation.parts[i2] instanceof Array ? classEscape(expectation.parts[i2][0]) + "-" + classEscape(expectation.parts[i2][1]) : classEscape(expectation.parts[i2]);
          }
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function(expectation) {
          return "any character";
        },
        end: function(expectation) {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = new Array(expected2.length), i2, j;
        for (i2 = 0; i2 < expected2.length; i2++) {
          descriptions[i2] = describeExpectation(expected2[i2]);
        }
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i2 = 1, j = 1; i2 < descriptions.length; i2++) {
            if (descriptions[i2 - 1] !== descriptions[i2]) {
              descriptions[j] = descriptions[i2];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {}, peg$startRuleFunctions = { Project: peg$parseProject }, peg$startRuleFunction = peg$parseProject, peg$c0 = function(headComment, obj) {
        var proj = /* @__PURE__ */ Object.create(null);
        proj.project = obj;
        if (headComment) {
          proj.headComment = headComment;
        }
        return proj;
      }, peg$c1 = "{", peg$c2 = peg$literalExpectation("{", false), peg$c3 = "}", peg$c4 = peg$literalExpectation("}", false), peg$c5 = function(obj) {
        return obj;
      }, peg$c6 = function() {
        return /* @__PURE__ */ Object.create(null);
      }, peg$c7 = function(list) {
        var returnObject = list[0][0];
        for (var i2 = 1; i2 < list.length; i2++) {
          var another = list[i2][0];
          returnObject = Object.assign(returnObject, another);
        }
        return returnObject;
      }, peg$c8 = "=", peg$c9 = peg$literalExpectation("=", false), peg$c10 = ";", peg$c11 = peg$literalExpectation(";", false), peg$c12 = function(id, val) {
        var result = /* @__PURE__ */ Object.create(null);
        result[id] = val;
        return result;
      }, peg$c13 = function(commentedId, val) {
        var result = /* @__PURE__ */ Object.create(null), commentKey = commentedId.id + "_comment";
        result[commentedId.id] = val;
        result[commentKey] = commentedId[commentKey];
        return result;
      }, peg$c14 = function(id, commentedVal) {
        var result = /* @__PURE__ */ Object.create(null);
        result[id] = commentedVal.value;
        result[id + "_comment"] = commentedVal.comment;
        return result;
      }, peg$c15 = function(id, comment) {
        var result = /* @__PURE__ */ Object.create(null);
        result.id = id;
        result[id + "_comment"] = comment.trim();
        return result;
      }, peg$c16 = function(literal2, comment) {
        var result = /* @__PURE__ */ Object.create(null);
        result.comment = comment.trim();
        result.value = literal2.trim();
        return result;
      }, peg$c17 = /^[^*]/, peg$c18 = peg$classExpectation(["*"], true, false), peg$c19 = function(body) {
        return body.join("");
      }, peg$c20 = "/*", peg$c21 = peg$literalExpectation("/*", false), peg$c22 = "*/", peg$c23 = peg$literalExpectation("*/", false), peg$c24 = function(begin, fields) {
        var section = /* @__PURE__ */ Object.create(null);
        section[begin.name] = fields;
        return section;
      }, peg$c25 = "/* Begin ", peg$c26 = peg$literalExpectation("/* Begin ", false), peg$c27 = " section */", peg$c28 = peg$literalExpectation(" section */", false), peg$c29 = function(sectionName) {
        return { name: sectionName };
      }, peg$c30 = "/* End ", peg$c31 = peg$literalExpectation("/* End ", false), peg$c32 = "(", peg$c33 = peg$literalExpectation("(", false), peg$c34 = ")", peg$c35 = peg$literalExpectation(")", false), peg$c36 = function(arr) {
        return arr;
      }, peg$c37 = function() {
        return [];
      }, peg$c38 = function(head, tail) {
        if (tail) {
          tail.unshift(head);
          return tail;
        } else {
          return [head];
        }
      }, peg$c39 = function(val) {
        return val;
      }, peg$c40 = function(val, comment) {
        var result = /* @__PURE__ */ Object.create(null);
        result.value = val.trim();
        result.comment = comment.trim();
        return result;
      }, peg$c41 = ",", peg$c42 = peg$literalExpectation(",", false), peg$c43 = /^[A-Za-z0-9_.]/, peg$c44 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "_", "."], false, false), peg$c45 = function(id) {
        return id.join("");
      }, peg$c46 = ".", peg$c47 = peg$literalExpectation(".", false), peg$c48 = function(decimal) {
        return decimal.join("");
      }, peg$c49 = function(number) {
        return parseInt(number.join(""), 10);
      }, peg$c50 = function(str) {
        return '"' + str + '"';
      }, peg$c51 = function(str) {
        return str.join("");
      }, peg$c52 = peg$anyExpectation(), peg$c53 = function(char) {
        return char;
      }, peg$c54 = "\\", peg$c55 = peg$literalExpectation("\\", false), peg$c56 = function() {
        return '\\"';
      }, peg$c57 = function(literal2) {
        return literal2.join("");
      }, peg$c58 = /^[^;,\n]/, peg$c59 = peg$classExpectation([";", ",", "\n"], true, false), peg$c60 = "//", peg$c61 = peg$literalExpectation("//", false), peg$c62 = function(contents) {
        return contents;
      }, peg$c63 = function(contents) {
        return contents.join("");
      }, peg$c64 = /^[0-9]/, peg$c65 = peg$classExpectation([["0", "9"]], false, false), peg$c66 = /^[A-Za-z]/, peg$c67 = peg$classExpectation([["A", "Z"], ["a", "z"]], false, false), peg$c68 = '"', peg$c69 = peg$literalExpectation('"', false), peg$c70 = peg$otherExpectation("whitespace"), peg$c71 = /^[\t ]/, peg$c72 = peg$classExpectation(["	", " "], false, false), peg$c73 = /^[\n\r]/, peg$c74 = peg$classExpectation(["\n", "\r"], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos2) {
        var details = peg$posDetailsCache[pos2], p;
        if (details) {
          return details;
        } else {
          p = pos2 - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos2) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos2] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseProject() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseSingleLineComment();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseInlineComment();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseObject();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseNewLine();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c0(s1, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseObject() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseAssignmentList();
          if (s2 === peg$FAILED) {
            s2 = peg$parseEmptyBody();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s3 = peg$c3;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c5(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEmptyBody() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c6();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseAssignmentList() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseAssignment();
          if (s4 === peg$FAILED) {
            s4 = peg$parseDelimitedSection();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseAssignment();
              if (s4 === peg$FAILED) {
                s4 = peg$parseDelimitedSection();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseAssignment() {
        var s0;
        s0 = peg$parseSimpleAssignment();
        if (s0 === peg$FAILED) {
          s0 = peg$parseCommentedAssignment();
        }
        return s0;
      }
      function peg$parseSimpleAssignment() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c8;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseValue();
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s6 = peg$c10;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c11);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c12(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseCommentedAssignment() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseCommentedIdentifier();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c8;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseValue();
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s6 = peg$c10;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c11);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c13(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c8;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c9);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseCommentedValue();
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                      s6 = peg$c10;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c11);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c14(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseCommentedIdentifier() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseInlineComment();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c15(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseCommentedValue() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseValue();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseInlineComment();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseInlineComment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseInlineCommentOpen();
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c17.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c18);
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c17.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c18);
                }
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseInlineCommentClose();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c19(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseInlineCommentOpen() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c20) {
          s0 = peg$c20;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }
        return s0;
      }
      function peg$parseInlineCommentClose() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c22) {
          s0 = peg$c22;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }
        return s0;
      }
      function peg$parseDelimitedSection() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseDelimitedSectionBegin();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseAssignmentList();
            if (s3 === peg$FAILED) {
              s3 = peg$parseEmptyBody();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDelimitedSectionEnd();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c24(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseDelimitedSectionBegin() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c25) {
          s1 = peg$c25;
          peg$currPos += 9;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 11) === peg$c27) {
              s3 = peg$c27;
              peg$currPos += 11;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseNewLine();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c29(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseDelimitedSectionEnd() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c30) {
          s1 = peg$c30;
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 11) === peg$c27) {
              s3 = peg$c27;
              peg$currPos += 11;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseNewLine();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c29(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseArray() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c32;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c33);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseArrayBody();
          if (s2 === peg$FAILED) {
            s2 = peg$parseEmptyArray();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s3 = peg$c34;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c36(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEmptyArray() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c37();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseArrayBody() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseArrayEntry();
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseArrayBody();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c38(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseArrayEntry() {
        var s0;
        s0 = peg$parseSimpleArrayEntry();
        if (s0 === peg$FAILED) {
          s0 = peg$parseCommentedArrayEntry();
        }
        return s0;
      }
      function peg$parseSimpleArrayEntry() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseValue();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEndArrayEntry();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c39(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseCommentedArrayEntry() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseValue();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseInlineComment();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseEndArrayEntry();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c40(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEndArrayEntry() {
        var s0, s1, s2, s3;
        if (input.charCodeAt(peg$currPos) === 44) {
          s0 = peg$c41;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 41) {
              s3 = peg$c34;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }
            peg$silentFails--;
            if (s3 !== peg$FAILED) {
              peg$currPos = s2;
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseIdentifier() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c43.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c44);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c45(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$parseQuotedString();
        }
        return s0;
      }
      function peg$parseValue() {
        var s0;
        s0 = peg$parseObject();
        if (s0 === peg$FAILED) {
          s0 = peg$parseArray();
          if (s0 === peg$FAILED) {
            s0 = peg$parseNumberValue();
            if (s0 === peg$FAILED) {
              s0 = peg$parseStringValue();
            }
          }
        }
        return s0;
      }
      function peg$parseNumberValue() {
        var s0;
        s0 = peg$parseDecimalValue();
        if (s0 === peg$FAILED) {
          s0 = peg$parseIntegerValue();
        }
        return s0;
      }
      function peg$parseDecimalValue() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseIntegerValue();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c46;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseIntegerValue();
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseIntegerValue() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parseAlpha();
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDigit();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseDigit();
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parseNonTerminator();
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = void 0;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c49(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseStringValue() {
        var s0;
        s0 = peg$parseQuotedString();
        if (s0 === peg$FAILED) {
          s0 = peg$parseLiteralString();
        }
        return s0;
      }
      function peg$parseQuotedString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseDoubleQuote();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseQuotedBody();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDoubleQuote();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c50(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseQuotedBody() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseNonQuote();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseNonQuote();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c51(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseNonQuote() {
        var s0, s1, s2;
        s0 = peg$parseEscapedQuote();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parseDoubleQuote();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c53(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseEscapedQuote() {
        var s0, s1, s2;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseDoubleQuote();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c56();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseLiteralString() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseLiteralChar();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseLiteralChar();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c57(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseLiteralChar() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parseInlineCommentOpen();
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parseLineTerminator();
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseNonTerminator();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c53(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseNonTerminator() {
        var s0;
        if (peg$c58.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c59);
          }
        }
        return s0;
      }
      function peg$parseSingleLineComment() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c60) {
          s1 = peg$c60;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c61);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseOneLineString();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseNewLine();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c62(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseOneLineString() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseNonLine();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseNonLine();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c63(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseDigit() {
        var s0;
        if (peg$c64.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        return s0;
      }
      function peg$parseAlpha() {
        var s0;
        if (peg$c66.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }
        return s0;
      }
      function peg$parseDoubleQuote() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c68;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c69);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parsewhitespace();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsewhitespace();
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c70);
          }
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0;
        s0 = peg$parseNewLine();
        if (s0 === peg$FAILED) {
          if (peg$c71.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }
        }
        return s0;
      }
      function peg$parseNonLine() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parseNewLine();
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseChar();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c53(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseLineTerminator() {
        var s0;
        s0 = peg$parseNewLine();
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s0 = peg$c10;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }
        }
        return s0;
      }
      function peg$parseNewLine() {
        var s0;
        if (peg$c73.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }
        return s0;
      }
      function peg$parseChar() {
        var s0;
        if (input.length > peg$currPos) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    module2.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});

// node_modules/simple-plist/dist/index.js
var require_dist = __commonJS({
  "node_modules/simple-plist/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "bplist-creator", "bplist-parser", "./parse", "./readFile", "./readFileSync", "./stringify", "./writeBinaryFile", "./writeBinaryFileSync", "./writeFile", "./writeFileSync"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      var bplist_creator_1 = __importDefault(require2("bplist-creator"));
      var bplist_parser_1 = __importDefault(require2("bplist-parser"));
      var parse_1 = require2("./parse");
      var readFile_1 = require2("./readFile");
      var readFileSync_1 = require2("./readFileSync");
      var stringify_1 = require2("./stringify");
      var writeBinaryFile_1 = require2("./writeBinaryFile");
      var writeBinaryFileSync_1 = require2("./writeBinaryFileSync");
      var writeFile_1 = require2("./writeFile");
      var writeFileSync_1 = require2("./writeFileSync");
      var SimplePlist = {
        bplistCreator: bplist_creator_1.default,
        bplistParser: bplist_parser_1.default,
        parse: parse_1.parse,
        readFile: readFile_1.readFile,
        readFileSync: readFileSync_1.readFileSync,
        stringify: stringify_1.stringify,
        writeBinaryFile: writeBinaryFile_1.writeBinaryFile,
        writeBinaryFileSync: writeBinaryFileSync_1.writeBinaryFileSync,
        writeFile: writeFile_1.writeFile,
        writeFileSync: writeFileSync_1.writeFileSync
      };
      exports3.default = SimplePlist;
      module2.exports = SimplePlist;
    });
  }
});

// node_modules/xcode/lib/pbxProject.js
var require_pbxProject = __commonJS({
  "node_modules/xcode/lib/pbxProject.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var f = util2.format;
    var EventEmitter = require("events").EventEmitter;
    var path11 = require("path");
    var uuid = (init_esm_node(), __toCommonJS(esm_node_exports));
    var fork = require("child_process").fork;
    var pbxWriter = require_pbxWriter();
    var pbxFile = require_pbxFile();
    var fs7 = require("fs");
    var parser = require_pbxproj();
    var plist = require_dist();
    var COMMENT_KEY = /_comment$/;
    function pbxProject(filename) {
      if (!(this instanceof pbxProject))
        return new pbxProject(filename);
      this.filepath = path11.resolve(filename);
    }
    util2.inherits(pbxProject, EventEmitter);
    pbxProject.prototype.parse = function(cb) {
      var worker = fork(__dirname + "/parseJob.js", [this.filepath]);
      worker.on("message", function(msg) {
        if (msg.name == "SyntaxError" || msg.code) {
          this.emit("error", msg);
        } else {
          this.hash = msg;
          this.emit("end", null, msg);
        }
      }.bind(this));
      if (cb) {
        this.on("error", cb);
        this.on("end", cb);
      }
      return this;
    };
    pbxProject.prototype.parseSync = function() {
      var file_contents = fs7.readFileSync(this.filepath, "utf-8");
      this.hash = parser.parse(file_contents);
      return this;
    };
    pbxProject.prototype.writeSync = function(options) {
      this.writer = new pbxWriter(this.hash, options);
      return this.writer.writeSync();
    };
    pbxProject.prototype.allUuids = function() {
      var sections = this.hash.project.objects, uuids = [], section;
      for (key in sections) {
        section = sections[key];
        uuids = uuids.concat(Object.keys(section));
      }
      uuids = uuids.filter(function(str) {
        return !COMMENT_KEY.test(str) && str.length == 24;
      });
      return uuids;
    };
    pbxProject.prototype.generateUuid = function() {
      var id = uuid.v4().replace(/-/g, "").substr(0, 24).toUpperCase();
      if (this.allUuids().indexOf(id) >= 0) {
        return this.generateUuid();
      } else {
        return id;
      }
    };
    pbxProject.prototype.addPluginFile = function(path12, opt) {
      var file = new pbxFile(path12, opt);
      file.plugin = true;
      correctForPluginsPath(file, this);
      if (this.hasFile(file.path)) return null;
      file.fileRef = this.generateUuid();
      this.addToPbxFileReferenceSection(file);
      this.addToPluginsPbxGroup(file);
      return file;
    };
    pbxProject.prototype.removePluginFile = function(path12, opt) {
      var file = new pbxFile(path12, opt);
      correctForPluginsPath(file, this);
      this.removeFromPbxFileReferenceSection(file);
      this.removeFromPluginsPbxGroup(file);
      return file;
    };
    pbxProject.prototype.addProductFile = function(targetPath, opt) {
      var file = new pbxFile(targetPath, opt);
      file.includeInIndex = 0;
      file.fileRef = this.generateUuid();
      file.target = opt ? opt.target : void 0;
      file.group = opt ? opt.group : void 0;
      file.uuid = this.generateUuid();
      file.path = file.basename;
      this.addToPbxFileReferenceSection(file);
      this.addToProductsPbxGroup(file);
      return file;
    };
    pbxProject.prototype.removeProductFile = function(path12, opt) {
      var file = new pbxFile(path12, opt);
      this.removeFromProductsPbxGroup(file);
      return file;
    };
    pbxProject.prototype.addSourceFile = function(path12, opt, group) {
      var file;
      if (group) {
        file = this.addFile(path12, group, opt);
      } else {
        file = this.addPluginFile(path12, opt);
      }
      if (!file) return false;
      file.target = opt ? opt.target : void 0;
      file.uuid = this.generateUuid();
      this.addToPbxBuildFileSection(file);
      this.addToPbxSourcesBuildPhase(file);
      return file;
    };
    pbxProject.prototype.removeSourceFile = function(path12, opt, group) {
      var file;
      if (group) {
        file = this.removeFile(path12, group, opt);
      } else {
        file = this.removePluginFile(path12, opt);
      }
      file.target = opt ? opt.target : void 0;
      this.removeFromPbxBuildFileSection(file);
      this.removeFromPbxSourcesBuildPhase(file);
      return file;
    };
    pbxProject.prototype.addHeaderFile = function(path12, opt, group) {
      if (group) {
        return this.addFile(path12, group, opt);
      } else {
        return this.addPluginFile(path12, opt);
      }
    };
    pbxProject.prototype.removeHeaderFile = function(path12, opt, group) {
      if (group) {
        return this.removeFile(path12, group, opt);
      } else {
        return this.removePluginFile(path12, opt);
      }
    };
    pbxProject.prototype.addResourceFile = function(path12, opt, group) {
      opt = opt || {};
      var file;
      if (opt.plugin) {
        file = this.addPluginFile(path12, opt);
        if (!file) return false;
      } else {
        file = new pbxFile(path12, opt);
        if (this.hasFile(file.path)) return false;
      }
      file.uuid = this.generateUuid();
      file.target = opt ? opt.target : void 0;
      if (!opt.plugin) {
        correctForResourcesPath(file, this);
        file.fileRef = this.generateUuid();
      }
      if (!opt.variantGroup) {
        this.addToPbxBuildFileSection(file);
        this.addToPbxResourcesBuildPhase(file);
      }
      if (!opt.plugin) {
        this.addToPbxFileReferenceSection(file);
        if (group) {
          if (this.getPBXGroupByKey(group)) {
            this.addToPbxGroup(file, group);
          } else if (this.getPBXVariantGroupByKey(group)) {
            this.addToPbxVariantGroup(file, group);
          }
        } else {
          this.addToResourcesPbxGroup(file);
        }
      }
      return file;
    };
    pbxProject.prototype.removeResourceFile = function(path12, opt, group) {
      var file = new pbxFile(path12, opt);
      file.target = opt ? opt.target : void 0;
      correctForResourcesPath(file, this);
      this.removeFromPbxBuildFileSection(file);
      this.removeFromPbxFileReferenceSection(file);
      if (group) {
        if (this.getPBXGroupByKey(group)) {
          this.removeFromPbxGroup(file, group);
        } else if (this.getPBXVariantGroupByKey(group)) {
          this.removeFromPbxVariantGroup(file, group);
        }
      } else {
        this.removeFromResourcesPbxGroup(file);
      }
      this.removeFromPbxResourcesBuildPhase(file);
      return file;
    };
    pbxProject.prototype.addFramework = function(fpath, opt) {
      var customFramework = opt && opt.customFramework == true;
      var link = !opt || (opt.link == void 0 || opt.link);
      var embed = opt && opt.embed;
      if (opt) {
        delete opt.embed;
      }
      var file = new pbxFile(fpath, opt);
      file.uuid = this.generateUuid();
      file.fileRef = this.generateUuid();
      file.target = opt ? opt.target : void 0;
      if (this.hasFile(file.path)) return false;
      this.addToPbxBuildFileSection(file);
      this.addToPbxFileReferenceSection(file);
      this.addToFrameworksPbxGroup(file);
      if (link) {
        this.addToPbxFrameworksBuildPhase(file);
      }
      if (customFramework) {
        this.addToFrameworkSearchPaths(file);
        if (embed) {
          opt.embed = embed;
          var embeddedFile = new pbxFile(fpath, opt);
          embeddedFile.uuid = this.generateUuid();
          embeddedFile.fileRef = file.fileRef;
          this.addToPbxBuildFileSection(embeddedFile);
          this.addToPbxEmbedFrameworksBuildPhase(embeddedFile);
          return embeddedFile;
        }
      }
      return file;
    };
    pbxProject.prototype.removeFramework = function(fpath, opt) {
      var embed = opt && opt.embed;
      if (opt) {
        delete opt.embed;
      }
      var file = new pbxFile(fpath, opt);
      file.target = opt ? opt.target : void 0;
      this.removeFromPbxBuildFileSection(file);
      this.removeFromPbxFileReferenceSection(file);
      this.removeFromFrameworksPbxGroup(file);
      this.removeFromPbxFrameworksBuildPhase(file);
      if (opt && opt.customFramework) {
        this.removeFromFrameworkSearchPaths(file);
      }
      opt = opt || {};
      opt.embed = true;
      var embeddedFile = new pbxFile(fpath, opt);
      embeddedFile.fileRef = file.fileRef;
      this.removeFromPbxBuildFileSection(embeddedFile);
      this.removeFromPbxEmbedFrameworksBuildPhase(embeddedFile);
      return file;
    };
    pbxProject.prototype.addCopyfile = function(fpath, opt) {
      var file = new pbxFile(fpath, opt);
      if (this.hasFile(file.path)) {
        file = this.hasFile(file.path);
      }
      file.fileRef = file.uuid = this.generateUuid();
      file.target = opt ? opt.target : void 0;
      this.addToPbxBuildFileSection(file);
      this.addToPbxFileReferenceSection(file);
      this.addToPbxCopyfilesBuildPhase(file);
      return file;
    };
    pbxProject.prototype.pbxCopyfilesBuildPhaseObj = function(target) {
      return this.buildPhaseObject("PBXCopyFilesBuildPhase", "Copy Files", target);
    };
    pbxProject.prototype.addToPbxCopyfilesBuildPhase = function(file) {
      var sources = this.buildPhaseObject("PBXCopyFilesBuildPhase", "Copy Files", file.target);
      sources.files.push(pbxBuildPhaseObj(file));
    };
    pbxProject.prototype.removeCopyfile = function(fpath, opt) {
      var file = new pbxFile(fpath, opt);
      file.target = opt ? opt.target : void 0;
      this.removeFromPbxBuildFileSection(file);
      this.removeFromPbxFileReferenceSection(file);
      this.removeFromPbxCopyfilesBuildPhase(file);
      return file;
    };
    pbxProject.prototype.removeFromPbxCopyfilesBuildPhase = function(file) {
      var sources = this.pbxCopyfilesBuildPhaseObj(file.target);
      for (i in sources.files) {
        if (sources.files[i].comment == longComment(file)) {
          sources.files.splice(i, 1);
          break;
        }
      }
    };
    pbxProject.prototype.addStaticLibrary = function(path12, opt) {
      opt = opt || {};
      var file;
      if (opt.plugin) {
        file = this.addPluginFile(path12, opt);
        if (!file) return false;
      } else {
        file = new pbxFile(path12, opt);
        if (this.hasFile(file.path)) return false;
      }
      file.uuid = this.generateUuid();
      file.target = opt ? opt.target : void 0;
      if (!opt.plugin) {
        file.fileRef = this.generateUuid();
        this.addToPbxFileReferenceSection(file);
      }
      this.addToPbxBuildFileSection(file);
      this.addToPbxFrameworksBuildPhase(file);
      this.addToLibrarySearchPaths(file);
      return file;
    };
    pbxProject.prototype.addToPbxBuildFileSection = function(file) {
      var commentKey = f("%s_comment", file.uuid);
      this.pbxBuildFileSection()[file.uuid] = pbxBuildFileObj(file);
      this.pbxBuildFileSection()[commentKey] = pbxBuildFileComment(file);
    };
    pbxProject.prototype.removeFromPbxBuildFileSection = function(file) {
      var uuid2;
      for (uuid2 in this.pbxBuildFileSection()) {
        if (this.pbxBuildFileSection()[uuid2].fileRef_comment == file.basename) {
          file.uuid = uuid2;
          delete this.pbxBuildFileSection()[uuid2];
          var commentKey = f("%s_comment", uuid2);
          delete this.pbxBuildFileSection()[commentKey];
        }
      }
    };
    pbxProject.prototype.addPbxGroup = function(filePathsArray, name, path12, sourceTree) {
      var groups = this.hash.project.objects["PBXGroup"], pbxGroupUuid = this.generateUuid(), commentKey = f("%s_comment", pbxGroupUuid), pbxGroup = {
        isa: "PBXGroup",
        children: [],
        name,
        path: path12,
        sourceTree: sourceTree ? sourceTree : '"<group>"'
      }, fileReferenceSection = this.pbxFileReferenceSection(), filePathToReference = {};
      for (var key3 in fileReferenceSection) {
        if (!COMMENT_KEY.test(key3)) continue;
        var fileReferenceKey = key3.split(COMMENT_KEY)[0], fileReference2 = fileReferenceSection[fileReferenceKey];
        filePathToReference[fileReference2.path] = { fileRef: fileReferenceKey, basename: fileReferenceSection[key3] };
      }
      for (var index = 0; index < filePathsArray.length; index++) {
        var filePath = filePathsArray[index], filePathQuoted = '"' + filePath + '"';
        if (filePathToReference[filePath]) {
          pbxGroup.children.push(pbxGroupChild(filePathToReference[filePath]));
          continue;
        } else if (filePathToReference[filePathQuoted]) {
          pbxGroup.children.push(pbxGroupChild(filePathToReference[filePathQuoted]));
          continue;
        }
        var file = new pbxFile(filePath);
        file.uuid = this.generateUuid();
        file.fileRef = this.generateUuid();
        this.addToPbxFileReferenceSection(file);
        this.addToPbxBuildFileSection(file);
        pbxGroup.children.push(pbxGroupChild(file));
      }
      if (groups) {
        groups[pbxGroupUuid] = pbxGroup;
        groups[commentKey] = name;
      }
      return { uuid: pbxGroupUuid, pbxGroup };
    };
    pbxProject.prototype.removePbxGroup = function(groupName) {
      var section = this.hash.project.objects["PBXGroup"], key3, itemKey;
      for (key3 in section) {
        if (!COMMENT_KEY.test(key3)) continue;
        if (section[key3] == groupName) {
          itemKey = key3.split(COMMENT_KEY)[0];
          delete section[itemKey];
        }
      }
    };
    pbxProject.prototype.addToPbxProjectSection = function(target) {
      var newTarget = {
        value: target.uuid,
        comment: pbxNativeTargetComment(target.pbxNativeTarget)
      };
      this.pbxProjectSection()[this.getFirstProject()["uuid"]]["targets"].push(newTarget);
    };
    pbxProject.prototype.addToPbxNativeTargetSection = function(target) {
      var commentKey = f("%s_comment", target.uuid);
      this.pbxNativeTargetSection()[target.uuid] = target.pbxNativeTarget;
      this.pbxNativeTargetSection()[commentKey] = target.pbxNativeTarget.name;
    };
    pbxProject.prototype.addToPbxFileReferenceSection = function(file) {
      var commentKey = f("%s_comment", file.fileRef);
      this.pbxFileReferenceSection()[file.fileRef] = pbxFileReferenceObj(file);
      this.pbxFileReferenceSection()[commentKey] = pbxFileReferenceComment(file);
    };
    pbxProject.prototype.removeFromPbxFileReferenceSection = function(file) {
      var i2;
      var refObj = pbxFileReferenceObj(file);
      for (i2 in this.pbxFileReferenceSection()) {
        if (this.pbxFileReferenceSection()[i2].name == refObj.name || '"' + this.pbxFileReferenceSection()[i2].name + '"' == refObj.name || this.pbxFileReferenceSection()[i2].path == refObj.path || '"' + this.pbxFileReferenceSection()[i2].path + '"' == refObj.path) {
          file.fileRef = file.uuid = i2;
          delete this.pbxFileReferenceSection()[i2];
          break;
        }
      }
      var commentKey = f("%s_comment", file.fileRef);
      if (this.pbxFileReferenceSection()[commentKey] != void 0) {
        delete this.pbxFileReferenceSection()[commentKey];
      }
      return file;
    };
    pbxProject.prototype.addToXcVersionGroupSection = function(file) {
      if (!file.models || !file.currentModel) {
        throw new Error("Cannot create a XCVersionGroup section from not a data model document file");
      }
      var commentKey = f("%s_comment", file.fileRef);
      if (!this.xcVersionGroupSection()[file.fileRef]) {
        this.xcVersionGroupSection()[file.fileRef] = {
          isa: "XCVersionGroup",
          children: file.models.map(function(el) {
            return el.fileRef;
          }),
          currentVersion: file.currentModel.fileRef,
          name: path11.basename(file.path),
          path: file.path,
          sourceTree: '"<group>"',
          versionGroupType: "wrapper.xcdatamodel"
        };
        this.xcVersionGroupSection()[commentKey] = path11.basename(file.path);
      }
    };
    pbxProject.prototype.addToPluginsPbxGroup = function(file) {
      var pluginsGroup = this.pbxGroupByName("Plugins");
      if (!pluginsGroup) {
        this.addPbxGroup([file.path], "Plugins");
      } else {
        pluginsGroup.children.push(pbxGroupChild(file));
      }
    };
    pbxProject.prototype.removeFromPluginsPbxGroup = function(file) {
      if (!this.pbxGroupByName("Plugins")) {
        return null;
      }
      var pluginsGroupChildren = this.pbxGroupByName("Plugins").children, i2;
      for (i2 in pluginsGroupChildren) {
        if (pbxGroupChild(file).value == pluginsGroupChildren[i2].value && pbxGroupChild(file).comment == pluginsGroupChildren[i2].comment) {
          pluginsGroupChildren.splice(i2, 1);
          break;
        }
      }
    };
    pbxProject.prototype.addToResourcesPbxGroup = function(file) {
      var pluginsGroup = this.pbxGroupByName("Resources");
      if (!pluginsGroup) {
        this.addPbxGroup([file.path], "Resources");
      } else {
        pluginsGroup.children.push(pbxGroupChild(file));
      }
    };
    pbxProject.prototype.removeFromResourcesPbxGroup = function(file) {
      if (!this.pbxGroupByName("Resources")) {
        return null;
      }
      var pluginsGroupChildren = this.pbxGroupByName("Resources").children, i2;
      for (i2 in pluginsGroupChildren) {
        if (pbxGroupChild(file).value == pluginsGroupChildren[i2].value && pbxGroupChild(file).comment == pluginsGroupChildren[i2].comment) {
          pluginsGroupChildren.splice(i2, 1);
          break;
        }
      }
    };
    pbxProject.prototype.addToFrameworksPbxGroup = function(file) {
      var pluginsGroup = this.pbxGroupByName("Frameworks");
      if (!pluginsGroup) {
        this.addPbxGroup([file.path], "Frameworks");
      } else {
        pluginsGroup.children.push(pbxGroupChild(file));
      }
    };
    pbxProject.prototype.removeFromFrameworksPbxGroup = function(file) {
      if (!this.pbxGroupByName("Frameworks")) {
        return null;
      }
      var pluginsGroupChildren = this.pbxGroupByName("Frameworks").children;
      for (i in pluginsGroupChildren) {
        if (pbxGroupChild(file).value == pluginsGroupChildren[i].value && pbxGroupChild(file).comment == pluginsGroupChildren[i].comment) {
          pluginsGroupChildren.splice(i, 1);
          break;
        }
      }
    };
    pbxProject.prototype.addToPbxEmbedFrameworksBuildPhase = function(file) {
      var sources = this.pbxEmbedFrameworksBuildPhaseObj(file.target);
      if (sources) {
        sources.files.push(pbxBuildPhaseObj(file));
      }
    };
    pbxProject.prototype.removeFromPbxEmbedFrameworksBuildPhase = function(file) {
      var sources = this.pbxEmbedFrameworksBuildPhaseObj(file.target);
      if (sources) {
        var files = [];
        for (i in sources.files) {
          if (sources.files[i].comment != longComment(file)) {
            files.push(sources.files[i]);
          }
        }
        sources.files = files;
      }
    };
    pbxProject.prototype.addToProductsPbxGroup = function(file) {
      var productsGroup = this.pbxGroupByName("Products");
      if (!productsGroup) {
        this.addPbxGroup([file.path], "Products");
      } else {
        productsGroup.children.push(pbxGroupChild(file));
      }
    };
    pbxProject.prototype.removeFromProductsPbxGroup = function(file) {
      if (!this.pbxGroupByName("Products")) {
        return null;
      }
      var productsGroupChildren = this.pbxGroupByName("Products").children, i2;
      for (i2 in productsGroupChildren) {
        if (pbxGroupChild(file).value == productsGroupChildren[i2].value && pbxGroupChild(file).comment == productsGroupChildren[i2].comment) {
          productsGroupChildren.splice(i2, 1);
          break;
        }
      }
    };
    pbxProject.prototype.addToPbxSourcesBuildPhase = function(file) {
      var sources = this.pbxSourcesBuildPhaseObj(file.target);
      sources.files.push(pbxBuildPhaseObj(file));
    };
    pbxProject.prototype.removeFromPbxSourcesBuildPhase = function(file) {
      var sources = this.pbxSourcesBuildPhaseObj(file.target), i2;
      for (i2 in sources.files) {
        if (sources.files[i2].comment == longComment(file)) {
          sources.files.splice(i2, 1);
          break;
        }
      }
    };
    pbxProject.prototype.addToPbxResourcesBuildPhase = function(file) {
      var sources = this.pbxResourcesBuildPhaseObj(file.target);
      sources.files.push(pbxBuildPhaseObj(file));
    };
    pbxProject.prototype.removeFromPbxResourcesBuildPhase = function(file) {
      var sources = this.pbxResourcesBuildPhaseObj(file.target), i2;
      for (i2 in sources.files) {
        if (sources.files[i2].comment == longComment(file)) {
          sources.files.splice(i2, 1);
          break;
        }
      }
    };
    pbxProject.prototype.addToPbxFrameworksBuildPhase = function(file) {
      var sources = this.pbxFrameworksBuildPhaseObj(file.target);
      sources.files.push(pbxBuildPhaseObj(file));
    };
    pbxProject.prototype.removeFromPbxFrameworksBuildPhase = function(file) {
      var sources = this.pbxFrameworksBuildPhaseObj(file.target);
      for (i in sources.files) {
        if (sources.files[i].comment == longComment(file)) {
          sources.files.splice(i, 1);
          break;
        }
      }
    };
    pbxProject.prototype.addXCConfigurationList = function(configurationObjectsArray, defaultConfigurationName, comment) {
      var pbxBuildConfigurationSection = this.pbxXCBuildConfigurationSection(), pbxXCConfigurationListSection = this.pbxXCConfigurationList(), xcConfigurationListUuid = this.generateUuid(), commentKey = f("%s_comment", xcConfigurationListUuid), xcConfigurationList = {
        isa: "XCConfigurationList",
        buildConfigurations: [],
        defaultConfigurationIsVisible: 0,
        defaultConfigurationName
      };
      for (var index = 0; index < configurationObjectsArray.length; index++) {
        var configuration = configurationObjectsArray[index], configurationUuid = this.generateUuid(), configurationCommentKey = f("%s_comment", configurationUuid);
        pbxBuildConfigurationSection[configurationUuid] = configuration;
        pbxBuildConfigurationSection[configurationCommentKey] = configuration.name;
        xcConfigurationList.buildConfigurations.push({ value: configurationUuid, comment: configuration.name });
      }
      if (pbxXCConfigurationListSection) {
        pbxXCConfigurationListSection[xcConfigurationListUuid] = xcConfigurationList;
        pbxXCConfigurationListSection[commentKey] = comment;
      }
      return { uuid: xcConfigurationListUuid, xcConfigurationList };
    };
    pbxProject.prototype.addTargetDependency = function(target, dependencyTargets) {
      if (!target)
        return void 0;
      var nativeTargets = this.pbxNativeTargetSection();
      if (typeof nativeTargets[target] == "undefined")
        throw new Error("Invalid target: " + target);
      for (var index = 0; index < dependencyTargets.length; index++) {
        var dependencyTarget = dependencyTargets[index];
        if (typeof nativeTargets[dependencyTarget] == "undefined")
          throw new Error("Invalid target: " + dependencyTarget);
      }
      var pbxTargetDependency = "PBXTargetDependency", pbxContainerItemProxy = "PBXContainerItemProxy", pbxTargetDependencySection = this.hash.project.objects[pbxTargetDependency], pbxContainerItemProxySection = this.hash.project.objects[pbxContainerItemProxy];
      for (var index = 0; index < dependencyTargets.length; index++) {
        var dependencyTargetUuid = dependencyTargets[index], dependencyTargetCommentKey = f("%s_comment", dependencyTargetUuid), targetDependencyUuid = this.generateUuid(), targetDependencyCommentKey = f("%s_comment", targetDependencyUuid), itemProxyUuid = this.generateUuid(), itemProxyCommentKey = f("%s_comment", itemProxyUuid), itemProxy = {
          isa: pbxContainerItemProxy,
          containerPortal: this.hash.project["rootObject"],
          containerPortal_comment: this.hash.project["rootObject_comment"],
          proxyType: 1,
          remoteGlobalIDString: dependencyTargetUuid,
          remoteInfo: nativeTargets[dependencyTargetUuid].name
        }, targetDependency = {
          isa: pbxTargetDependency,
          target: dependencyTargetUuid,
          target_comment: nativeTargets[dependencyTargetCommentKey],
          targetProxy: itemProxyUuid,
          targetProxy_comment: pbxContainerItemProxy
        };
        if (pbxContainerItemProxySection && pbxTargetDependencySection) {
          pbxContainerItemProxySection[itemProxyUuid] = itemProxy;
          pbxContainerItemProxySection[itemProxyCommentKey] = pbxContainerItemProxy;
          pbxTargetDependencySection[targetDependencyUuid] = targetDependency;
          pbxTargetDependencySection[targetDependencyCommentKey] = pbxTargetDependency;
          nativeTargets[target].dependencies.push({ value: targetDependencyUuid, comment: pbxTargetDependency });
        }
      }
      return { uuid: target, target: nativeTargets[target] };
    };
    pbxProject.prototype.addBuildPhase = function(filePathsArray, buildPhaseType, comment, target, optionsOrFolderType, subfolderPath) {
      var buildPhaseSection, fileReferenceSection = this.pbxFileReferenceSection(), buildFileSection = this.pbxBuildFileSection(), buildPhaseUuid = this.generateUuid(), buildPhaseTargetUuid = target || this.getFirstTarget().uuid, commentKey = f("%s_comment", buildPhaseUuid), buildPhase = {
        isa: buildPhaseType,
        buildActionMask: 2147483647,
        files: [],
        runOnlyForDeploymentPostprocessing: 0
      }, filePathToBuildFile = {};
      if (buildPhaseType === "PBXCopyFilesBuildPhase") {
        buildPhase = pbxCopyFilesBuildPhaseObj(buildPhase, optionsOrFolderType, subfolderPath, comment);
      } else if (buildPhaseType === "PBXShellScriptBuildPhase") {
        buildPhase = pbxShellScriptBuildPhaseObj(buildPhase, optionsOrFolderType, comment);
      }
      if (!this.hash.project.objects[buildPhaseType]) {
        this.hash.project.objects[buildPhaseType] = new Object();
      }
      if (!this.hash.project.objects[buildPhaseType][buildPhaseUuid]) {
        this.hash.project.objects[buildPhaseType][buildPhaseUuid] = buildPhase;
        this.hash.project.objects[buildPhaseType][commentKey] = comment;
      }
      if (this.hash.project.objects["PBXNativeTarget"][buildPhaseTargetUuid]["buildPhases"]) {
        this.hash.project.objects["PBXNativeTarget"][buildPhaseTargetUuid]["buildPhases"].push({
          value: buildPhaseUuid,
          comment
        });
      }
      for (var key3 in buildFileSection) {
        if (!COMMENT_KEY.test(key3)) continue;
        var buildFileKey = key3.split(COMMENT_KEY)[0], buildFile = buildFileSection[buildFileKey];
        fileReference = fileReferenceSection[buildFile.fileRef];
        if (!fileReference) continue;
        var pbxFileObj = new pbxFile(fileReference.path);
        filePathToBuildFile[fileReference.path] = { uuid: buildFileKey, basename: pbxFileObj.basename, group: pbxFileObj.group };
      }
      for (var index = 0; index < filePathsArray.length; index++) {
        var filePath = filePathsArray[index], filePathQuoted = '"' + filePath + '"', file = new pbxFile(filePath);
        if (filePathToBuildFile[filePath]) {
          buildPhase.files.push(pbxBuildPhaseObj(filePathToBuildFile[filePath]));
          continue;
        } else if (filePathToBuildFile[filePathQuoted]) {
          buildPhase.files.push(pbxBuildPhaseObj(filePathToBuildFile[filePathQuoted]));
          continue;
        }
        file.uuid = this.generateUuid();
        file.fileRef = this.generateUuid();
        this.addToPbxFileReferenceSection(file);
        this.addToPbxBuildFileSection(file);
        buildPhase.files.push(pbxBuildPhaseObj(file));
      }
      if (buildPhaseSection) {
        buildPhaseSection[buildPhaseUuid] = buildPhase;
        buildPhaseSection[commentKey] = comment;
      }
      return { uuid: buildPhaseUuid, buildPhase };
    };
    pbxProject.prototype.pbxProjectSection = function() {
      return this.hash.project.objects["PBXProject"];
    };
    pbxProject.prototype.pbxBuildFileSection = function() {
      return this.hash.project.objects["PBXBuildFile"];
    };
    pbxProject.prototype.pbxXCBuildConfigurationSection = function() {
      return this.hash.project.objects["XCBuildConfiguration"];
    };
    pbxProject.prototype.pbxFileReferenceSection = function() {
      return this.hash.project.objects["PBXFileReference"];
    };
    pbxProject.prototype.pbxNativeTargetSection = function() {
      return this.hash.project.objects["PBXNativeTarget"];
    };
    pbxProject.prototype.xcVersionGroupSection = function() {
      if (typeof this.hash.project.objects["XCVersionGroup"] !== "object") {
        this.hash.project.objects["XCVersionGroup"] = {};
      }
      return this.hash.project.objects["XCVersionGroup"];
    };
    pbxProject.prototype.pbxXCConfigurationList = function() {
      return this.hash.project.objects["XCConfigurationList"];
    };
    pbxProject.prototype.pbxGroupByName = function(name) {
      var groups = this.hash.project.objects["PBXGroup"], key3, groupKey;
      for (key3 in groups) {
        if (!COMMENT_KEY.test(key3)) continue;
        if (groups[key3] == name) {
          groupKey = key3.split(COMMENT_KEY)[0];
          return groups[groupKey];
        }
      }
      return null;
    };
    pbxProject.prototype.pbxTargetByName = function(name) {
      return this.pbxItemByComment(name, "PBXNativeTarget");
    };
    pbxProject.prototype.findTargetKey = function(name) {
      var targets = this.hash.project.objects["PBXNativeTarget"];
      for (var key3 in targets) {
        if (COMMENT_KEY.test(key3)) continue;
        var target = targets[key3];
        if (target.name === name) {
          return key3;
        }
      }
      return null;
    };
    pbxProject.prototype.pbxItemByComment = function(name, pbxSectionName) {
      var section = this.hash.project.objects[pbxSectionName], key3, itemKey;
      for (key3 in section) {
        if (!COMMENT_KEY.test(key3)) continue;
        if (section[key3] == name) {
          itemKey = key3.split(COMMENT_KEY)[0];
          return section[itemKey];
        }
      }
      return null;
    };
    pbxProject.prototype.pbxSourcesBuildPhaseObj = function(target) {
      return this.buildPhaseObject("PBXSourcesBuildPhase", "Sources", target);
    };
    pbxProject.prototype.pbxResourcesBuildPhaseObj = function(target) {
      return this.buildPhaseObject("PBXResourcesBuildPhase", "Resources", target);
    };
    pbxProject.prototype.pbxFrameworksBuildPhaseObj = function(target) {
      return this.buildPhaseObject("PBXFrameworksBuildPhase", "Frameworks", target);
    };
    pbxProject.prototype.pbxEmbedFrameworksBuildPhaseObj = function(target) {
      return this.buildPhaseObject("PBXCopyFilesBuildPhase", "Embed Frameworks", target);
    };
    pbxProject.prototype.buildPhase = function(group, target) {
      if (!target)
        return void 0;
      var nativeTargets = this.pbxNativeTargetSection();
      if (typeof nativeTargets[target] == "undefined")
        throw new Error("Invalid target: " + target);
      var nativeTarget = nativeTargets[target];
      var buildPhases = nativeTarget.buildPhases;
      for (var i2 in buildPhases) {
        var buildPhase = buildPhases[i2];
        if (buildPhase.comment == group)
          return buildPhase.value + "_comment";
      }
    };
    pbxProject.prototype.buildPhaseObject = function(name, group, target) {
      var section = this.hash.project.objects[name], obj, sectionKey, key3;
      var buildPhase = this.buildPhase(group, target);
      for (key3 in section) {
        if (!COMMENT_KEY.test(key3)) continue;
        if (buildPhase && buildPhase != key3)
          continue;
        if (section[key3] == group) {
          sectionKey = key3.split(COMMENT_KEY)[0];
          return section[sectionKey];
        }
      }
      return null;
    };
    pbxProject.prototype.addBuildProperty = function(prop, value, build_name) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), key3, configuration;
      for (key3 in configurations) {
        configuration = configurations[key3];
        if (!build_name || configuration.name === build_name) {
          configuration.buildSettings[prop] = value;
        }
      }
    };
    pbxProject.prototype.removeBuildProperty = function(prop, build_name) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), key3, configuration;
      for (key3 in configurations) {
        configuration = configurations[key3];
        if (configuration.buildSettings[prop] && !build_name || configuration.name === build_name) {
          delete configuration.buildSettings[prop];
        }
      }
    };
    pbxProject.prototype.updateBuildProperty = function(prop, value, build, targetName) {
      let validConfigs = [];
      if (targetName) {
        const target = this.pbxTargetByName(targetName);
        const targetBuildConfigs = target && target.buildConfigurationList;
        const xcConfigList = this.pbxXCConfigurationList();
        for (const configName2 in xcConfigList) {
          if (!COMMENT_KEY.test(configName2) && targetBuildConfigs === configName2) {
            const buildVariants = xcConfigList[configName2].buildConfigurations;
            for (const item of buildVariants) {
              validConfigs.push(item.value);
            }
            break;
          }
        }
      }
      var configs = this.pbxXCBuildConfigurationSection();
      for (var configName in configs) {
        if (!COMMENT_KEY.test(configName)) {
          if (targetName && !validConfigs.includes(configName)) continue;
          var config = configs[configName];
          if (build && config.name === build || !build) {
            config.buildSettings[prop] = value;
          }
        }
      }
    };
    pbxProject.prototype.updateProductName = function(name) {
      this.updateBuildProperty("PRODUCT_NAME", '"' + name + '"');
    };
    pbxProject.prototype.removeFromFrameworkSearchPaths = function(file) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), INHERITED = '"$(inherited)"', SEARCH_PATHS = "FRAMEWORK_SEARCH_PATHS", config, buildSettings, searchPaths;
      var new_path = searchPathForFile(file, this);
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        if (unquote(buildSettings["PRODUCT_NAME"]) != this.productName)
          continue;
        searchPaths = buildSettings[SEARCH_PATHS];
        if (searchPaths && Array.isArray(searchPaths)) {
          var matches = searchPaths.filter(function(p) {
            return p.indexOf(new_path) > -1;
          });
          matches.forEach(function(m) {
            var idx = searchPaths.indexOf(m);
            searchPaths.splice(idx, 1);
          });
        }
      }
    };
    pbxProject.prototype.addToFrameworkSearchPaths = function(file) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), INHERITED = '"$(inherited)"', config, buildSettings, searchPaths;
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        if (unquote(buildSettings["PRODUCT_NAME"]) != this.productName)
          continue;
        if (!buildSettings["FRAMEWORK_SEARCH_PATHS"] || buildSettings["FRAMEWORK_SEARCH_PATHS"] === INHERITED) {
          buildSettings["FRAMEWORK_SEARCH_PATHS"] = [INHERITED];
        }
        buildSettings["FRAMEWORK_SEARCH_PATHS"].push(searchPathForFile(file, this));
      }
    };
    pbxProject.prototype.removeFromLibrarySearchPaths = function(file) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), INHERITED = '"$(inherited)"', SEARCH_PATHS = "LIBRARY_SEARCH_PATHS", config, buildSettings, searchPaths;
      var new_path = searchPathForFile(file, this);
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        if (unquote(buildSettings["PRODUCT_NAME"]) != this.productName)
          continue;
        searchPaths = buildSettings[SEARCH_PATHS];
        if (searchPaths && Array.isArray(searchPaths)) {
          var matches = searchPaths.filter(function(p) {
            return p.indexOf(new_path) > -1;
          });
          matches.forEach(function(m) {
            var idx = searchPaths.indexOf(m);
            searchPaths.splice(idx, 1);
          });
        }
      }
    };
    pbxProject.prototype.addToLibrarySearchPaths = function(file) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), INHERITED = '"$(inherited)"', config, buildSettings, searchPaths;
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        if (unquote(buildSettings["PRODUCT_NAME"]) != this.productName)
          continue;
        if (!buildSettings["LIBRARY_SEARCH_PATHS"] || buildSettings["LIBRARY_SEARCH_PATHS"] === INHERITED) {
          buildSettings["LIBRARY_SEARCH_PATHS"] = [INHERITED];
        }
        if (typeof file === "string") {
          buildSettings["LIBRARY_SEARCH_PATHS"].push(file);
        } else {
          buildSettings["LIBRARY_SEARCH_PATHS"].push(searchPathForFile(file, this));
        }
      }
    };
    pbxProject.prototype.removeFromHeaderSearchPaths = function(file) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), INHERITED = '"$(inherited)"', SEARCH_PATHS = "HEADER_SEARCH_PATHS", config, buildSettings, searchPaths;
      var new_path = searchPathForFile(file, this);
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        if (unquote(buildSettings["PRODUCT_NAME"]) != this.productName)
          continue;
        if (buildSettings[SEARCH_PATHS]) {
          var matches = buildSettings[SEARCH_PATHS].filter(function(p) {
            return p.indexOf(new_path) > -1;
          });
          matches.forEach(function(m) {
            var idx = buildSettings[SEARCH_PATHS].indexOf(m);
            buildSettings[SEARCH_PATHS].splice(idx, 1);
          });
        }
      }
    };
    pbxProject.prototype.addToHeaderSearchPaths = function(file) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), INHERITED = '"$(inherited)"', config, buildSettings, searchPaths;
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        if (unquote(buildSettings["PRODUCT_NAME"]) != this.productName)
          continue;
        if (!buildSettings["HEADER_SEARCH_PATHS"]) {
          buildSettings["HEADER_SEARCH_PATHS"] = [INHERITED];
        }
        if (typeof file === "string") {
          buildSettings["HEADER_SEARCH_PATHS"].push(file);
        } else {
          buildSettings["HEADER_SEARCH_PATHS"].push(searchPathForFile(file, this));
        }
      }
    };
    pbxProject.prototype.addToOtherLinkerFlags = function(flag) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), INHERITED = '"$(inherited)"', OTHER_LDFLAGS = "OTHER_LDFLAGS", config, buildSettings;
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        if (unquote(buildSettings["PRODUCT_NAME"]) != this.productName)
          continue;
        if (!buildSettings[OTHER_LDFLAGS] || buildSettings[OTHER_LDFLAGS] === INHERITED) {
          buildSettings[OTHER_LDFLAGS] = [INHERITED];
        }
        buildSettings[OTHER_LDFLAGS].push(flag);
      }
    };
    pbxProject.prototype.removeFromOtherLinkerFlags = function(flag) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), OTHER_LDFLAGS = "OTHER_LDFLAGS", config, buildSettings;
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        if (unquote(buildSettings["PRODUCT_NAME"]) != this.productName) {
          continue;
        }
        if (buildSettings[OTHER_LDFLAGS]) {
          var matches = buildSettings[OTHER_LDFLAGS].filter(function(p) {
            return p.indexOf(flag) > -1;
          });
          matches.forEach(function(m) {
            var idx = buildSettings[OTHER_LDFLAGS].indexOf(m);
            buildSettings[OTHER_LDFLAGS].splice(idx, 1);
          });
        }
      }
    };
    pbxProject.prototype.addToBuildSettings = function(buildSetting, value) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), config, buildSettings;
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        buildSettings[buildSetting] = value;
      }
    };
    pbxProject.prototype.removeFromBuildSettings = function(buildSetting) {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), config, buildSettings;
      for (config in configurations) {
        buildSettings = configurations[config].buildSettings;
        if (buildSettings[buildSetting]) {
          delete buildSettings[buildSetting];
        }
      }
    };
    pbxProject.prototype.__defineGetter__("productName", function() {
      var configurations = nonComments(this.pbxXCBuildConfigurationSection()), config, productName;
      for (config in configurations) {
        productName = configurations[config].buildSettings["PRODUCT_NAME"];
        if (productName) {
          return unquote(productName);
        }
      }
    });
    pbxProject.prototype.hasFile = function(filePath) {
      var files = nonComments(this.pbxFileReferenceSection()), file, id;
      for (id in files) {
        file = files[id];
        if (file.path == filePath || file.path == '"' + filePath + '"') {
          return file;
        }
      }
      return false;
    };
    pbxProject.prototype.addTarget = function(name, type, subfolder, bundleId) {
      var targetUuid = this.generateUuid(), targetType = type, targetSubfolder = subfolder || name, targetName = name.trim(), targetBundleId = bundleId;
      if (!targetName) {
        throw new Error("Target name missing.");
      }
      if (!targetType) {
        throw new Error("Target type missing.");
      }
      if (!producttypeForTargettype(targetType)) {
        throw new Error("Target type invalid: " + targetType);
      }
      var buildConfigurationsList = [
        {
          name: "Debug",
          isa: "XCBuildConfiguration",
          buildSettings: {
            GCC_PREPROCESSOR_DEFINITIONS: ['"DEBUG=1"', '"$(inherited)"'],
            INFOPLIST_FILE: '"' + path11.join(targetSubfolder, targetSubfolder + '-Info.plist"'),
            LD_RUNPATH_SEARCH_PATHS: '"$(inherited) @executable_path/Frameworks @executable_path/../../Frameworks"',
            PRODUCT_NAME: '"' + targetName + '"',
            SKIP_INSTALL: "YES"
          }
        },
        {
          name: "Release",
          isa: "XCBuildConfiguration",
          buildSettings: {
            INFOPLIST_FILE: '"' + path11.join(targetSubfolder, targetSubfolder + '-Info.plist"'),
            LD_RUNPATH_SEARCH_PATHS: '"$(inherited) @executable_path/Frameworks @executable_path/../../Frameworks"',
            PRODUCT_NAME: '"' + targetName + '"',
            SKIP_INSTALL: "YES"
          }
        }
      ];
      if (targetBundleId) {
        buildConfigurationsList = buildConfigurationsList.map((elem) => {
          elem.buildSettings.PRODUCT_BUNDLE_IDENTIFIER = '"' + targetBundleId + '"';
          return elem;
        });
      }
      var buildConfigurations = this.addXCConfigurationList(buildConfigurationsList, "Release", 'Build configuration list for PBXNativeTarget "' + targetName + '"');
      var productName = targetName, productType = producttypeForTargettype(targetType), productFileType = filetypeForProducttype(productType), productFile = this.addProductFile(productName, { group: "Copy Files", "target": targetUuid, "explicitFileType": productFileType }), productFileName = productFile.basename;
      this.addToPbxBuildFileSection(productFile);
      var target = {
        uuid: targetUuid,
        pbxNativeTarget: {
          isa: "PBXNativeTarget",
          name: '"' + targetName + '"',
          productName: '"' + targetName + '"',
          productReference: productFile.fileRef,
          productType: '"' + producttypeForTargettype(targetType) + '"',
          buildConfigurationList: buildConfigurations.uuid,
          buildPhases: [],
          buildRules: [],
          dependencies: []
        }
      };
      this.addToPbxNativeTargetSection(target);
      if (targetType === "app_extension") {
        this.addBuildPhase([], "PBXCopyFilesBuildPhase", "Copy Files", this.getFirstTarget().uuid, targetType);
        this.addToPbxCopyfilesBuildPhase(productFile);
      } else if (targetType === "watch2_app") {
        this.addBuildPhase(
          [targetName + ".app"],
          "PBXCopyFilesBuildPhase",
          "Embed Watch Content",
          this.getFirstTarget().uuid,
          targetType,
          '"$(CONTENTS_FOLDER_PATH)/Watch"'
        );
      } else if (targetType === "watch2_extension") {
        var watch2Target = this.getTarget(producttypeForTargettype("watch2_app"));
        if (watch2Target) {
          this.addBuildPhase(
            [targetName + ".appex"],
            "PBXCopyFilesBuildPhase",
            "Embed App Extensions",
            watch2Target.uuid,
            targetType
          );
        }
      }
      this.addToPbxProjectSection(target);
      if (targetType === "watch2_extension") {
        var watch2Target = this.getTarget(producttypeForTargettype("watch2_app"));
        if (watch2Target) {
          this.addTargetDependency(watch2Target.uuid, [target.uuid]);
        }
      } else {
        this.addTargetDependency(this.getFirstTarget().uuid, [target.uuid]);
      }
      return target;
    };
    function pbxBuildFileObj(file) {
      var obj = /* @__PURE__ */ Object.create(null);
      obj.isa = "PBXBuildFile";
      obj.fileRef = file.fileRef;
      obj.fileRef_comment = file.basename;
      if (file.settings) obj.settings = file.settings;
      return obj;
    }
    function pbxFileReferenceObj(file) {
      var fileObject = {
        isa: "PBXFileReference",
        name: '"' + file.basename + '"',
        path: '"' + file.path.replace(/\\/g, "/") + '"',
        sourceTree: file.sourceTree,
        fileEncoding: file.fileEncoding,
        lastKnownFileType: file.lastKnownFileType,
        explicitFileType: file.explicitFileType,
        includeInIndex: file.includeInIndex
      };
      return fileObject;
    }
    function pbxGroupChild(file) {
      var obj = /* @__PURE__ */ Object.create(null);
      obj.value = file.fileRef;
      obj.comment = file.basename;
      return obj;
    }
    function pbxBuildPhaseObj(file) {
      var obj = /* @__PURE__ */ Object.create(null);
      obj.value = file.uuid;
      obj.comment = longComment(file);
      return obj;
    }
    function pbxCopyFilesBuildPhaseObj(obj, folderType, subfolderPath, phaseName) {
      var DESTINATION_BY_TARGETTYPE = {
        application: "wrapper",
        app_extension: "plugins",
        bundle: "wrapper",
        command_line_tool: "wrapper",
        dynamic_library: "products_directory",
        framework: "shared_frameworks",
        frameworks: "frameworks",
        static_library: "products_directory",
        unit_test_bundle: "wrapper",
        watch_app: "wrapper",
        watch2_app: "products_directory",
        watch_extension: "plugins",
        watch2_extension: "plugins"
      };
      var SUBFOLDERSPEC_BY_DESTINATION = {
        absolute_path: 0,
        executables: 6,
        frameworks: 10,
        java_resources: 15,
        plugins: 13,
        products_directory: 16,
        resources: 7,
        shared_frameworks: 11,
        shared_support: 12,
        wrapper: 1,
        xpc_services: 0
      };
      obj.name = '"' + phaseName + '"';
      obj.dstPath = subfolderPath || '""';
      obj.dstSubfolderSpec = SUBFOLDERSPEC_BY_DESTINATION[DESTINATION_BY_TARGETTYPE[folderType]];
      return obj;
    }
    function pbxShellScriptBuildPhaseObj(obj, options, phaseName) {
      obj.name = '"' + phaseName + '"';
      obj.inputPaths = options.inputPaths || [];
      obj.outputPaths = options.outputPaths || [];
      obj.shellPath = options.shellPath;
      obj.shellScript = '"' + options.shellScript.replace(/"/g, '\\"') + '"';
      return obj;
    }
    function pbxBuildFileComment(file) {
      return longComment(file);
    }
    function pbxFileReferenceComment(file) {
      return file.basename || path11.basename(file.path);
    }
    function pbxNativeTargetComment(target) {
      return target.name;
    }
    function longComment(file) {
      return f("%s in %s", file.basename, file.group);
    }
    function correctForPluginsPath(file, project) {
      return correctForPath(file, project, "Plugins");
    }
    function correctForResourcesPath(file, project) {
      return correctForPath(file, project, "Resources");
    }
    function correctForPath(file, project, group) {
      var r_group_dir = new RegExp("^" + group + "[\\\\/]");
      if (project.pbxGroupByName(group).path)
        file.path = file.path.replace(r_group_dir, "");
      return file;
    }
    function searchPathForFile(file, proj) {
      var plugins = proj.pbxGroupByName("Plugins"), pluginsPath = plugins ? plugins.path : null, fileDir = path11.dirname(file.path);
      if (fileDir == ".") {
        fileDir = "";
      } else {
        fileDir = "/" + fileDir;
      }
      if (file.plugin && pluginsPath) {
        return '"\\"$(SRCROOT)/' + unquote(pluginsPath) + '\\""';
      } else if (file.customFramework && file.dirname) {
        return '"\\"' + file.dirname + '\\""';
      } else {
        return '"\\"$(SRCROOT)/' + proj.productName + fileDir + '\\""';
      }
    }
    function nonComments(obj) {
      var keys = Object.keys(obj), newObj = {}, i2 = 0;
      for (i2; i2 < keys.length; i2++) {
        if (!COMMENT_KEY.test(keys[i2])) {
          newObj[keys[i2]] = obj[keys[i2]];
        }
      }
      return newObj;
    }
    function unquote(str) {
      if (str) return str.replace(/^"(.*)"$/, "$1");
    }
    function producttypeForTargettype(targetType) {
      PRODUCTTYPE_BY_TARGETTYPE = {
        application: "com.apple.product-type.application",
        app_extension: "com.apple.product-type.app-extension",
        bundle: "com.apple.product-type.bundle",
        command_line_tool: "com.apple.product-type.tool",
        dynamic_library: "com.apple.product-type.library.dynamic",
        framework: "com.apple.product-type.framework",
        static_library: "com.apple.product-type.library.static",
        unit_test_bundle: "com.apple.product-type.bundle.unit-test",
        watch_app: "com.apple.product-type.application.watchapp",
        watch2_app: "com.apple.product-type.application.watchapp2",
        watch_extension: "com.apple.product-type.watchkit-extension",
        watch2_extension: "com.apple.product-type.watchkit2-extension"
      };
      return PRODUCTTYPE_BY_TARGETTYPE[targetType];
    }
    function filetypeForProducttype(productType) {
      FILETYPE_BY_PRODUCTTYPE = {
        "com.apple.product-type.application": '"wrapper.application"',
        "com.apple.product-type.app-extension": '"wrapper.app-extension"',
        "com.apple.product-type.bundle": '"wrapper.plug-in"',
        "com.apple.product-type.tool": '"compiled.mach-o.dylib"',
        "com.apple.product-type.library.dynamic": '"compiled.mach-o.dylib"',
        "com.apple.product-type.framework": '"wrapper.framework"',
        "com.apple.product-type.library.static": '"archive.ar"',
        "com.apple.product-type.bundle.unit-test": '"wrapper.cfbundle"',
        "com.apple.product-type.application.watchapp": '"wrapper.application"',
        "com.apple.product-type.application.watchapp2": '"wrapper.application"',
        "com.apple.product-type.watchkit-extension": '"wrapper.app-extension"',
        "com.apple.product-type.watchkit2-extension": '"wrapper.app-extension"'
      };
      return FILETYPE_BY_PRODUCTTYPE[productType];
    }
    pbxProject.prototype.getFirstProject = function() {
      var pbxProjectContainer = this.pbxProjectSection();
      var firstProjectUuid = Object.keys(pbxProjectContainer)[0];
      var firstProject = pbxProjectContainer[firstProjectUuid];
      return {
        uuid: firstProjectUuid,
        firstProject
      };
    };
    pbxProject.prototype.getFirstTarget = function() {
      var firstTargetUuid = this.getFirstProject()["firstProject"]["targets"][0].value;
      var firstTarget = this.pbxNativeTargetSection()[firstTargetUuid];
      return {
        uuid: firstTargetUuid,
        firstTarget
      };
    };
    pbxProject.prototype.getTarget = function(productType) {
      var targets = this.getFirstProject()["firstProject"]["targets"];
      var nativeTargets = this.pbxNativeTargetSection();
      for (var i2 = 0; i2 < targets.length; i2++) {
        var target = targets[i2];
        var targetUuid = target.value;
        if (nativeTargets[targetUuid]["productType"] === '"' + productType + '"') {
          var nativeTarget = this.pbxNativeTargetSection()[targetUuid];
          return {
            uuid: targetUuid,
            target: nativeTarget
          };
        }
      }
      return null;
    };
    pbxProject.prototype.addToPbxGroupType = function(file, groupKey, groupType) {
      var group = this.getPBXGroupByKeyAndType(groupKey, groupType);
      if (group && group.children !== void 0) {
        if (typeof file === "string") {
          var childGroup = {
            value: file
          };
          if (this.getPBXGroupByKey(file)) {
            childGroup.comment = this.getPBXGroupByKey(file).name;
          } else if (this.getPBXVariantGroupByKey(file)) {
            childGroup.comment = this.getPBXVariantGroupByKey(file).name;
          }
          group.children.push(childGroup);
        } else {
          group.children.push(pbxGroupChild(file));
        }
      }
    };
    pbxProject.prototype.addToPbxVariantGroup = function(file, groupKey) {
      this.addToPbxGroupType(file, groupKey, "PBXVariantGroup");
    };
    pbxProject.prototype.addToPbxGroup = function(file, groupKey) {
      this.addToPbxGroupType(file, groupKey, "PBXGroup");
    };
    pbxProject.prototype.pbxCreateGroupWithType = function(name, pathName, groupType) {
      var model = {
        isa: '"' + groupType + '"',
        children: [],
        name,
        sourceTree: '"<group>"'
      };
      if (pathName) model.path = pathName;
      var key3 = this.generateUuid();
      var commendId = key3 + "_comment";
      var groups = this.hash.project.objects[groupType];
      if (!groups) {
        groups = this.hash.project.objects[groupType] = new Object();
      }
      groups[commendId] = name;
      groups[key3] = model;
      return key3;
    };
    pbxProject.prototype.pbxCreateVariantGroup = function(name) {
      return this.pbxCreateGroupWithType(name, void 0, "PBXVariantGroup");
    };
    pbxProject.prototype.pbxCreateGroup = function(name, pathName) {
      return this.pbxCreateGroupWithType(name, pathName, "PBXGroup");
    };
    pbxProject.prototype.removeFromPbxGroupAndType = function(file, groupKey, groupType) {
      var group = this.getPBXGroupByKeyAndType(groupKey, groupType);
      if (group) {
        var groupChildren = group.children, i2;
        for (i2 in groupChildren) {
          if (pbxGroupChild(file).value == groupChildren[i2].value && pbxGroupChild(file).comment == groupChildren[i2].comment) {
            groupChildren.splice(i2, 1);
            break;
          }
        }
      }
    };
    pbxProject.prototype.removeFromPbxGroup = function(file, groupKey) {
      this.removeFromPbxGroupAndType(file, groupKey, "PBXGroup");
    };
    pbxProject.prototype.removeFromPbxVariantGroup = function(file, groupKey) {
      this.removeFromPbxGroupAndType(file, groupKey, "PBXVariantGroup");
    };
    pbxProject.prototype.getPBXGroupByKeyAndType = function(key3, groupType) {
      return this.hash.project.objects[groupType][key3];
    };
    pbxProject.prototype.getPBXGroupByKey = function(key3) {
      return this.hash.project.objects["PBXGroup"][key3];
    };
    pbxProject.prototype.getPBXVariantGroupByKey = function(key3) {
      return this.hash.project.objects["PBXVariantGroup"][key3];
    };
    pbxProject.prototype.findPBXGroupKeyAndType = function(criteria, groupType) {
      var groups = this.hash.project.objects[groupType];
      var target;
      for (var key3 in groups) {
        if (COMMENT_KEY.test(key3)) continue;
        var group = groups[key3];
        if (criteria && criteria.path && criteria.name) {
          if (criteria.path === group.path && criteria.name === group.name) {
            target = key3;
            break;
          }
        } else if (criteria && criteria.path) {
          if (criteria.path === group.path) {
            target = key3;
            break;
          }
        } else if (criteria && criteria.name) {
          if (criteria.name === group.name) {
            target = key3;
            break;
          }
        }
      }
      return target;
    };
    pbxProject.prototype.findPBXGroupKey = function(criteria) {
      return this.findPBXGroupKeyAndType(criteria, "PBXGroup");
    };
    pbxProject.prototype.findPBXVariantGroupKey = function(criteria) {
      return this.findPBXGroupKeyAndType(criteria, "PBXVariantGroup");
    };
    pbxProject.prototype.addLocalizationVariantGroup = function(name) {
      var groupKey = this.pbxCreateVariantGroup(name);
      var resourceGroupKey = this.findPBXGroupKey({ name: "Resources" });
      this.addToPbxGroup(groupKey, resourceGroupKey);
      var localizationVariantGroup = {
        uuid: this.generateUuid(),
        fileRef: groupKey,
        basename: name
      };
      this.addToPbxBuildFileSection(localizationVariantGroup);
      this.addToPbxResourcesBuildPhase(localizationVariantGroup);
      return localizationVariantGroup;
    };
    pbxProject.prototype.addKnownRegion = function(name) {
      if (!this.pbxProjectSection()[this.getFirstProject()["uuid"]]["knownRegions"]) {
        this.pbxProjectSection()[this.getFirstProject()["uuid"]]["knownRegions"] = [];
      }
      if (!this.hasKnownRegion(name)) {
        this.pbxProjectSection()[this.getFirstProject()["uuid"]]["knownRegions"].push(name);
      }
    };
    pbxProject.prototype.removeKnownRegion = function(name) {
      var regions = this.pbxProjectSection()[this.getFirstProject()["uuid"]]["knownRegions"];
      if (regions) {
        for (var i2 = 0; i2 < regions.length; i2++) {
          if (regions[i2] === name) {
            regions.splice(i2, 1);
            break;
          }
        }
        this.pbxProjectSection()[this.getFirstProject()["uuid"]]["knownRegions"] = regions;
      }
    };
    pbxProject.prototype.hasKnownRegion = function(name) {
      var regions = this.pbxProjectSection()[this.getFirstProject()["uuid"]]["knownRegions"];
      if (regions) {
        for (var i2 in regions) {
          if (regions[i2] === name) {
            return true;
          }
        }
      }
      return false;
    };
    pbxProject.prototype.getPBXObject = function(name) {
      return this.hash.project.objects[name];
    };
    pbxProject.prototype.addFile = function(path12, group, opt) {
      var file = new pbxFile(path12, opt);
      if (this.hasFile(file.path)) return null;
      file.fileRef = this.generateUuid();
      this.addToPbxFileReferenceSection(file);
      if (this.getPBXGroupByKey(group)) {
        this.addToPbxGroup(file, group);
      } else if (this.getPBXVariantGroupByKey(group)) {
        this.addToPbxVariantGroup(file, group);
      }
      return file;
    };
    pbxProject.prototype.removeFile = function(path12, group, opt) {
      var file = new pbxFile(path12, opt);
      this.removeFromPbxFileReferenceSection(file);
      if (this.getPBXGroupByKey(group)) {
        this.removeFromPbxGroup(file, group);
      } else if (this.getPBXVariantGroupByKey(group)) {
        this.removeFromPbxVariantGroup(file, group);
      }
      return file;
    };
    pbxProject.prototype.getBuildProperty = function(prop, build, targetName) {
      var target;
      let validConfigs = [];
      if (targetName) {
        const target2 = this.pbxTargetByName(targetName);
        const targetBuildConfigs = target2 && target2.buildConfigurationList;
        const xcConfigList = this.pbxXCConfigurationList();
        for (const configName2 in xcConfigList) {
          if (!COMMENT_KEY.test(configName2) && targetBuildConfigs === configName2) {
            const buildVariants = xcConfigList[configName2].buildConfigurations;
            for (const item of buildVariants) {
              validConfigs.push(item.value);
            }
            break;
          }
        }
      }
      var configs = this.pbxXCBuildConfigurationSection();
      for (var configName in configs) {
        if (!COMMENT_KEY.test(configName)) {
          if (targetName && !validConfigs.includes(configName)) continue;
          var config = configs[configName];
          if (build && config.name === build || build === void 0) {
            if (config.buildSettings[prop] !== void 0) {
              target = config.buildSettings[prop];
            }
          }
        }
      }
      return target;
    };
    pbxProject.prototype.getBuildConfigByName = function(name) {
      var target = {};
      var configs = this.pbxXCBuildConfigurationSection();
      for (var configName in configs) {
        if (!COMMENT_KEY.test(configName)) {
          var config = configs[configName];
          if (config.name === name) {
            target[configName] = config;
          }
        }
      }
      return target;
    };
    pbxProject.prototype.addDataModelDocument = function(filePath, group, opt) {
      if (!group) {
        group = "Resources";
      }
      if (!this.getPBXGroupByKey(group)) {
        group = this.findPBXGroupKey({ name: group });
      }
      var file = new pbxFile(filePath, opt);
      if (!file || this.hasFile(file.path)) return null;
      file.fileRef = this.generateUuid();
      this.addToPbxGroup(file, group);
      if (!file) return false;
      file.target = opt ? opt.target : void 0;
      file.uuid = this.generateUuid();
      this.addToPbxBuildFileSection(file);
      this.addToPbxSourcesBuildPhase(file);
      file.models = [];
      var currentVersionName;
      var modelFiles = fs7.readdirSync(file.path);
      for (var index in modelFiles) {
        var modelFileName = modelFiles[index];
        var modelFilePath = path11.join(filePath, modelFileName);
        if (modelFileName == ".xccurrentversion") {
          currentVersionName = plist.readFileSync(modelFilePath)._XCCurrentVersionName;
          continue;
        }
        var modelFile = new pbxFile(modelFilePath);
        modelFile.fileRef = this.generateUuid();
        this.addToPbxFileReferenceSection(modelFile);
        file.models.push(modelFile);
        if (currentVersionName && currentVersionName === modelFileName) {
          file.currentModel = modelFile;
        }
      }
      if (!file.currentModel) {
        file.currentModel = file.models[0];
      }
      this.addToXcVersionGroupSection(file);
      return file;
    };
    pbxProject.prototype.addTargetAttribute = function(prop, value, target) {
      var attributes = this.getFirstProject()["firstProject"]["attributes"];
      if (attributes["TargetAttributes"] === void 0) {
        attributes["TargetAttributes"] = {};
      }
      target = target || this.getFirstTarget();
      if (attributes["TargetAttributes"][target.uuid] === void 0) {
        attributes["TargetAttributes"][target.uuid] = {};
      }
      attributes["TargetAttributes"][target.uuid][prop] = value;
    };
    pbxProject.prototype.removeTargetAttribute = function(prop, target) {
      var attributes = this.getFirstProject()["firstProject"]["attributes"];
      target = target || this.getFirstTarget();
      if (attributes["TargetAttributes"] && attributes["TargetAttributes"][target.uuid]) {
        delete attributes["TargetAttributes"][target.uuid][prop];
      }
    };
    module2.exports = pbxProject;
  }
});

// node_modules/xcode/index.js
var require_xcode = __commonJS({
  "node_modules/xcode/index.js"(exports2) {
    "use strict";
    exports2.project = require_pbxProject();
  }
});

// node_modules/@expo/config-plugins/build/ios/utils/string.js
var require_string = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.trimQuotes = trimQuotes;
    function trimQuotes(s) {
      return s && s[0] === '"' && s[s.length - 1] === '"' ? s.slice(1, -1) : s;
    }
  }
});

// node_modules/slash/index.js
var require_slash = __commonJS({
  "node_modules/slash/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (path11) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path11);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path11);
      if (isExtendedLengthPath || hasNonAscii) {
        return path11;
      }
      return path11.replace(/\\/g, "/");
    };
  }
});

// node_modules/@expo/config-plugins/build/ios/BuildScheme.js
var require_BuildScheme = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/BuildScheme.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getApplicationTargetNameForSchemeAsync = getApplicationTargetNameForSchemeAsync;
    exports2.getArchiveBuildConfigurationForSchemeAsync = getArchiveBuildConfigurationForSchemeAsync;
    exports2.getRunnableSchemesFromXcodeproj = getRunnableSchemesFromXcodeproj;
    exports2.getSchemesFromXcodeproj = getSchemesFromXcodeproj;
    function _Paths() {
      const data = require_Paths2();
      _Paths = function() {
        return data;
      };
      return data;
    }
    function _Target() {
      const data = require_Target();
      _Target = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _XML() {
      const data = require_XML();
      _XML = function() {
        return data;
      };
      return data;
    }
    function getSchemesFromXcodeproj(projectRoot) {
      return (0, _Paths().findSchemeNames)(projectRoot);
    }
    function getRunnableSchemesFromXcodeproj(projectRoot, {
      configuration = "Debug"
    } = {}) {
      const project = (0, _Xcodeproj().getPbxproj)(projectRoot);
      return (0, _Target().findSignableTargets)(project).map(([, target]) => {
        let osType = "iOS";
        const type = (0, _Xcodeproj().unquote)(target.productType);
        if (type === _Target().TargetType.WATCH) {
          osType = "watchOS";
        } else if (
          // (apps) com.apple.product-type.application
          // (app clips) com.apple.product-type.application.on-demand-install-capable
          // NOTE(EvanBacon): This matches against `watchOS` as well so we check for watch first.
          type.startsWith(_Target().TargetType.APPLICATION)
        ) {
          const xcConfigurationList = project.hash.project.objects.XCConfigurationList[target.buildConfigurationList];
          if (xcConfigurationList) {
            const buildConfiguration = xcConfigurationList.buildConfigurations.find((value) => value.comment === configuration) || xcConfigurationList.buildConfigurations[0];
            if (buildConfiguration?.value) {
              const xcBuildConfiguration = project.hash.project.objects.XCBuildConfiguration?.[buildConfiguration.value];
              const buildSdkRoot = xcBuildConfiguration.buildSettings.SDKROOT;
              if (buildSdkRoot === "appletvos" || "TVOS_DEPLOYMENT_TARGET" in xcBuildConfiguration.buildSettings) {
                osType = "tvOS";
              } else if (buildSdkRoot === "iphoneos") {
                osType = "iOS";
              }
            }
          }
        }
        return {
          name: (0, _Xcodeproj().unquote)(target.name),
          osType,
          type: (0, _Xcodeproj().unquote)(target.productType)
        };
      });
    }
    async function readSchemeAsync(projectRoot, scheme) {
      const allSchemePaths = (0, _Paths().findSchemePaths)(projectRoot);
      const re = new RegExp(`[\\\\/]${scheme}.xcscheme`, "i");
      const schemePath = allSchemePaths.find((i2) => re.exec(i2));
      if (schemePath) {
        return await (0, _XML().readXMLAsync)({
          path: schemePath
        });
      } else {
        throw new Error(`scheme '${scheme}' does not exist, make sure it's marked as shared`);
      }
    }
    async function getApplicationTargetNameForSchemeAsync(projectRoot, scheme) {
      const schemeXML = await readSchemeAsync(projectRoot, scheme);
      const buildActionEntry = schemeXML?.Scheme?.BuildAction?.[0]?.BuildActionEntries?.[0]?.BuildActionEntry;
      const targetName = buildActionEntry?.length === 1 ? getBlueprintName(buildActionEntry[0]) : getBlueprintName(buildActionEntry?.find((entry) => {
        return entry.BuildableReference?.[0]?.["$"]?.BuildableName?.endsWith(".app");
      }));
      if (!targetName) {
        throw new Error(`${scheme}.xcscheme seems to be corrupted`);
      }
      return targetName;
    }
    async function getArchiveBuildConfigurationForSchemeAsync(projectRoot, scheme) {
      const schemeXML = await readSchemeAsync(projectRoot, scheme);
      const buildConfiguration = schemeXML?.Scheme?.ArchiveAction?.[0]?.["$"]?.buildConfiguration;
      if (!buildConfiguration) {
        throw new Error(`${scheme}.xcscheme seems to be corrupted`);
      }
      return buildConfiguration;
    }
    function getBlueprintName(entry) {
      return entry?.BuildableReference?.[0]?.["$"]?.BlueprintName;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/Target.js
var require_Target = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Target.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TargetType = void 0;
    exports2.findApplicationTargetWithDependenciesAsync = findApplicationTargetWithDependenciesAsync;
    exports2.findFirstNativeTarget = findFirstNativeTarget;
    exports2.findNativeTargetByName = findNativeTargetByName;
    exports2.findSignableTargets = findSignableTargets;
    exports2.getNativeTargets = getNativeTargets;
    exports2.getXCBuildConfigurationFromPbxproj = getXCBuildConfigurationFromPbxproj;
    exports2.isTargetOfType = isTargetOfType;
    function _BuildScheme() {
      const data = require_BuildScheme();
      _BuildScheme = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _string() {
      const data = require_string();
      _string = function() {
        return data;
      };
      return data;
    }
    var TargetType = exports2.TargetType = /* @__PURE__ */ function(TargetType2) {
      TargetType2["APPLICATION"] = "com.apple.product-type.application";
      TargetType2["EXTENSION"] = "com.apple.product-type.app-extension";
      TargetType2["WATCH"] = "com.apple.product-type.application.watchapp";
      TargetType2["APP_CLIP"] = "com.apple.product-type.application.on-demand-install-capable";
      TargetType2["STICKER_PACK_EXTENSION"] = "com.apple.product-type.app-extension.messages-sticker-pack";
      TargetType2["FRAMEWORK"] = "com.apple.product-type.framework";
      TargetType2["OTHER"] = "other";
      return TargetType2;
    }({});
    function getXCBuildConfigurationFromPbxproj(project, {
      targetName,
      buildConfiguration = "Release"
    } = {}) {
      const [, nativeTarget] = targetName ? findNativeTargetByName(project, targetName) : findFirstNativeTarget(project);
      const [, xcBuildConfiguration] = (0, _Xcodeproj().getBuildConfigurationForListIdAndName)(project, {
        configurationListId: nativeTarget.buildConfigurationList,
        buildConfiguration
      });
      return xcBuildConfiguration ?? null;
    }
    async function findApplicationTargetWithDependenciesAsync(projectRoot, scheme) {
      const applicationTargetName = await (0, _BuildScheme().getApplicationTargetNameForSchemeAsync)(projectRoot, scheme);
      const project = (0, _Xcodeproj().getPbxproj)(projectRoot);
      const [, applicationTarget] = findNativeTargetByName(project, applicationTargetName);
      const dependencies = getTargetDependencies(project, applicationTarget);
      return {
        name: (0, _string().trimQuotes)(applicationTarget.name),
        type: TargetType.APPLICATION,
        signable: true,
        dependencies
      };
    }
    function getTargetDependencies(project, parentTarget) {
      if (!parentTarget.dependencies || parentTarget.dependencies.length === 0) {
        return void 0;
      }
      const nonSignableTargetTypes = [TargetType.FRAMEWORK];
      return parentTarget.dependencies.map(({
        value
      }) => {
        const {
          target: targetId
        } = project.getPBXGroupByKeyAndType(value, "PBXTargetDependency");
        const [, target] = findNativeTargetById(project, targetId);
        const type = isTargetOfType(target, TargetType.EXTENSION) ? TargetType.EXTENSION : TargetType.OTHER;
        return {
          name: (0, _string().trimQuotes)(target.name),
          type,
          signable: !nonSignableTargetTypes.some((signableTargetType) => isTargetOfType(target, signableTargetType)),
          dependencies: getTargetDependencies(project, target)
        };
      });
    }
    function isTargetOfType(target, targetType) {
      return (0, _string().trimQuotes)(target.productType) === targetType;
    }
    function getNativeTargets(project) {
      const section = project.pbxNativeTargetSection();
      return Object.entries(section).filter(_Xcodeproj().isNotComment);
    }
    function findSignableTargets(project) {
      const targets = getNativeTargets(project);
      const signableTargetTypes = [TargetType.APPLICATION, TargetType.APP_CLIP, TargetType.EXTENSION, TargetType.WATCH, TargetType.STICKER_PACK_EXTENSION];
      const applicationTargets = targets.filter(([, target]) => {
        for (const targetType of signableTargetTypes) {
          if (isTargetOfType(target, targetType)) {
            return true;
          }
        }
        return false;
      });
      if (applicationTargets.length === 0) {
        throw new Error(`Could not find any signable targets in project.pbxproj`);
      }
      return applicationTargets;
    }
    function findFirstNativeTarget(project) {
      const targets = getNativeTargets(project);
      const applicationTargets = targets.filter(([, target]) => isTargetOfType(target, TargetType.APPLICATION));
      if (applicationTargets.length === 0) {
        throw new Error(`Could not find any application target in project.pbxproj`);
      }
      return applicationTargets[0];
    }
    function findNativeTargetByName(project, targetName) {
      const nativeTargets = getNativeTargets(project);
      const nativeTargetEntry = nativeTargets.find(([, i2]) => (0, _string().trimQuotes)(i2.name) === targetName);
      if (!nativeTargetEntry) {
        throw new Error(`Could not find target '${targetName}' in project.pbxproj`);
      }
      return nativeTargetEntry;
    }
    function findNativeTargetById(project, targetId) {
      const nativeTargets = getNativeTargets(project);
      const nativeTargetEntry = nativeTargets.find(([key3]) => key3 === targetId);
      if (!nativeTargetEntry) {
        throw new Error(`Could not find target with id '${targetId}' in project.pbxproj`);
      }
      return nativeTargetEntry;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/Entitlements.js
var require_Entitlements = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Entitlements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ensureApplicationTargetEntitlementsFileConfigured = ensureApplicationTargetEntitlementsFileConfigured;
    exports2.getEntitlementsPath = getEntitlementsPath;
    exports2.setAssociatedDomains = setAssociatedDomains;
    exports2.withAssociatedDomains = void 0;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _slash() {
      const data = _interopRequireDefault(require_slash());
      _slash = function() {
        return data;
      };
      return data;
    }
    function _Target() {
      const data = require_Target();
      _Target = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _string() {
      const data = require_string();
      _string = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var withAssociatedDomains = exports2.withAssociatedDomains = (0, _iosPlugins().createEntitlementsPlugin)(setAssociatedDomains, "withAssociatedDomains");
    function setAssociatedDomains(config, {
      "com.apple.developer.associated-domains": _,
      ...entitlementsPlist
    }) {
      if (config.ios?.associatedDomains) {
        return {
          ...entitlementsPlist,
          "com.apple.developer.associated-domains": config.ios.associatedDomains
        };
      }
      return entitlementsPlist;
    }
    function getEntitlementsPath(projectRoot, {
      targetName,
      buildConfiguration = "Release"
    } = {}) {
      const project = (0, _Xcodeproj().getPbxproj)(projectRoot);
      const xcBuildConfiguration = (0, _Target().getXCBuildConfigurationFromPbxproj)(project, {
        targetName,
        buildConfiguration
      });
      if (!xcBuildConfiguration) {
        return null;
      }
      const entitlementsPath = getEntitlementsPathFromBuildConfiguration(projectRoot, xcBuildConfiguration);
      return entitlementsPath && _fs().default.existsSync(entitlementsPath) ? entitlementsPath : null;
    }
    function getEntitlementsPathFromBuildConfiguration(projectRoot, xcBuildConfiguration) {
      const entitlementsPathRaw = xcBuildConfiguration?.buildSettings?.CODE_SIGN_ENTITLEMENTS;
      if (entitlementsPathRaw) {
        return _path().default.normalize(_path().default.join(projectRoot, "ios", (0, _string().trimQuotes)(entitlementsPathRaw)));
      } else {
        return null;
      }
    }
    function ensureApplicationTargetEntitlementsFileConfigured(projectRoot) {
      const project = (0, _Xcodeproj().getPbxproj)(projectRoot);
      const projectName = (0, _Xcodeproj().getProjectName)(projectRoot);
      const productName = (0, _Xcodeproj().getProductName)(project);
      const [, applicationTarget] = (0, _Target().findFirstNativeTarget)(project);
      const buildConfigurations = (0, _Xcodeproj().getBuildConfigurationsForListId)(project, applicationTarget.buildConfigurationList);
      let hasChangesToWrite = false;
      for (const [, xcBuildConfiguration] of buildConfigurations) {
        const oldEntitlementPath = getEntitlementsPathFromBuildConfiguration(projectRoot, xcBuildConfiguration);
        if (oldEntitlementPath && _fs().default.existsSync(oldEntitlementPath)) {
          return;
        }
        hasChangesToWrite = true;
        const entitlementsRelativePath = (0, _slash().default)(_path().default.join(projectName, `${productName}.entitlements`));
        const entitlementsPath = _path().default.normalize(_path().default.join(projectRoot, "ios", entitlementsRelativePath));
        _fs().default.mkdirSync(_path().default.dirname(entitlementsPath), {
          recursive: true
        });
        if (!_fs().default.existsSync(entitlementsPath)) {
          _fs().default.writeFileSync(entitlementsPath, ENTITLEMENTS_TEMPLATE);
        }
        xcBuildConfiguration.buildSettings.CODE_SIGN_ENTITLEMENTS = entitlementsRelativePath;
      }
      if (hasChangesToWrite) {
        _fs().default.writeFileSync(project.filepath, project.writeSync());
      }
    }
    var ENTITLEMENTS_TEMPLATE = `
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
</dict>
</plist>
`;
  }
});

// node_modules/@expo/config-plugins/build/utils/glob.js
var require_glob2 = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/glob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.withSortedGlobResult = withSortedGlobResult;
    function withSortedGlobResult(glob) {
      return glob.sort((a, b) => a.localeCompare(b));
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/Paths.js
var require_Paths2 = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Paths.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.findSchemeNames = findSchemeNames;
    exports2.findSchemePaths = findSchemePaths;
    exports2.getAllEntitlementsPaths = getAllEntitlementsPaths;
    exports2.getAllInfoPlistPaths = getAllInfoPlistPaths;
    exports2.getAllPBXProjectPaths = getAllPBXProjectPaths;
    exports2.getAllXcodeProjectPaths = getAllXcodeProjectPaths;
    exports2.getAppDelegate = getAppDelegate;
    exports2.getAppDelegateFilePath = getAppDelegateFilePath;
    exports2.getAppDelegateHeaderFilePath = getAppDelegateHeaderFilePath;
    exports2.getAppDelegateObjcHeaderFilePath = getAppDelegateObjcHeaderFilePath;
    exports2.getEntitlementsPath = getEntitlementsPath;
    exports2.getExpoPlistPath = getExpoPlistPath;
    exports2.getFileInfo = getFileInfo;
    exports2.getInfoPlistPath = getInfoPlistPath;
    exports2.getPBXProjectPath = getPBXProjectPath;
    exports2.getPodfilePath = getPodfilePath;
    exports2.getSourceRoot = getSourceRoot;
    exports2.getSupportingPath = getSupportingPath;
    exports2.getXcodeProjectPath = getXcodeProjectPath;
    function _fs() {
      const data = require("fs");
      _fs = function() {
        return data;
      };
      return data;
    }
    function _glob() {
      const data = require_commonjs5();
      _glob = function() {
        return data;
      };
      return data;
    }
    function path11() {
      const data = _interopRequireWildcard(require("path"));
      path11 = function() {
        return data;
      };
      return data;
    }
    function Entitlements() {
      const data = _interopRequireWildcard(require_Entitlements());
      Entitlements = function() {
        return data;
      };
      return data;
    }
    function _errors() {
      const data = require_errors();
      _errors = function() {
        return data;
      };
      return data;
    }
    function _glob2() {
      const data = require_glob2();
      _glob2 = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    var ignoredPaths = ["**/@(Carthage|Pods|vendor|node_modules)/**"];
    function getAppDelegateHeaderFilePath(projectRoot) {
      const [using, ...extra] = (0, _glob2().withSortedGlobResult)((0, _glob().globSync)("ios/*/AppDelegate.h", {
        absolute: true,
        cwd: projectRoot,
        ignore: ignoredPaths
      }));
      if (!using) {
        throw new (_errors()).UnexpectedError(`Could not locate a valid AppDelegate header at root: "${projectRoot}"`);
      }
      if (extra.length) {
        warnMultipleFiles({
          tag: "app-delegate-header",
          fileName: "AppDelegate",
          projectRoot,
          using,
          extra
        });
      }
      return using;
    }
    function getAppDelegateFilePath(projectRoot) {
      const [using, ...extra] = (0, _glob2().withSortedGlobResult)((0, _glob().globSync)("ios/*/AppDelegate.@(m|mm|swift)", {
        absolute: true,
        cwd: projectRoot,
        ignore: ignoredPaths
      }));
      if (!using) {
        throw new (_errors()).UnexpectedError(`Could not locate a valid AppDelegate at root: "${projectRoot}"`);
      }
      if (extra.length) {
        warnMultipleFiles({
          tag: "app-delegate",
          fileName: "AppDelegate",
          projectRoot,
          using,
          extra
        });
      }
      return using;
    }
    function getAppDelegateObjcHeaderFilePath(projectRoot) {
      const [using, ...extra] = (0, _glob2().withSortedGlobResult)((0, _glob().globSync)("ios/*/AppDelegate.h", {
        absolute: true,
        cwd: projectRoot,
        ignore: ignoredPaths
      }));
      if (!using) {
        throw new (_errors()).UnexpectedError(`Could not locate a valid AppDelegate.h at root: "${projectRoot}"`);
      }
      if (extra.length) {
        warnMultipleFiles({
          tag: "app-delegate-objc-header",
          fileName: "AppDelegate.h",
          projectRoot,
          using,
          extra
        });
      }
      return using;
    }
    function getPodfilePath(projectRoot) {
      const [using, ...extra] = (0, _glob2().withSortedGlobResult)((0, _glob().globSync)("ios/Podfile", {
        absolute: true,
        cwd: projectRoot,
        ignore: ignoredPaths
      }));
      if (!using) {
        throw new (_errors()).UnexpectedError(`Could not locate a valid Podfile at root: "${projectRoot}"`);
      }
      if (extra.length) {
        warnMultipleFiles({
          tag: "podfile",
          fileName: "Podfile",
          projectRoot,
          using,
          extra
        });
      }
      return using;
    }
    function getLanguage(filePath) {
      const extension = path11().extname(filePath);
      if (!extension && path11().basename(filePath) === "Podfile") {
        return "rb";
      }
      switch (extension) {
        case ".mm":
          return "objcpp";
        case ".m":
        case ".h":
          return "objc";
        case ".swift":
          return "swift";
        default:
          throw new (_errors()).UnexpectedError(`Unexpected iOS file extension: ${extension}`);
      }
    }
    function getFileInfo(filePath) {
      return {
        path: path11().normalize(filePath),
        contents: (0, _fs().readFileSync)(filePath, "utf8"),
        language: getLanguage(filePath)
      };
    }
    function getAppDelegate(projectRoot) {
      const filePath = getAppDelegateFilePath(projectRoot);
      return getFileInfo(filePath);
    }
    function getSourceRoot(projectRoot) {
      const appDelegate = getAppDelegate(projectRoot);
      return path11().dirname(appDelegate.path);
    }
    function findSchemePaths(projectRoot) {
      return (0, _glob2().withSortedGlobResult)((0, _glob().globSync)("ios/*.xcodeproj/xcshareddata/xcschemes/*.xcscheme", {
        absolute: true,
        cwd: projectRoot,
        ignore: ignoredPaths
      }));
    }
    function findSchemeNames(projectRoot) {
      const schemePaths = findSchemePaths(projectRoot);
      return schemePaths.map((schemePath) => path11().parse(schemePath).name);
    }
    function getAllXcodeProjectPaths(projectRoot) {
      const iosFolder = "ios";
      const pbxprojPaths = (0, _glob2().withSortedGlobResult)((0, _glob().globSync)("ios/**/*.xcodeproj", {
        cwd: projectRoot,
        ignore: ignoredPaths
      }).map((filePath) => filePath.replace(/^\//, "")).filter((project) => !/test|example|sample/i.test(project) || path11().dirname(project) === iosFolder)).sort((a, b) => {
        const isAInIos = path11().dirname(a) === iosFolder;
        const isBInIos = path11().dirname(b) === iosFolder;
        if (isAInIos && isBInIos || !isAInIos && !isBInIos) {
          return 0;
        }
        return isAInIos ? -1 : 1;
      });
      if (!pbxprojPaths.length) {
        throw new (_errors()).UnexpectedError(`Failed to locate the ios/*.xcodeproj files relative to path "${projectRoot}".`);
      }
      return pbxprojPaths.map((value) => path11().join(projectRoot, value));
    }
    function getXcodeProjectPath(projectRoot) {
      const [using, ...extra] = getAllXcodeProjectPaths(projectRoot);
      if (extra.length) {
        warnMultipleFiles({
          tag: "xcodeproj",
          fileName: "*.xcodeproj",
          projectRoot,
          using,
          extra
        });
      }
      return using;
    }
    function getAllPBXProjectPaths(projectRoot) {
      const projectPaths = getAllXcodeProjectPaths(projectRoot);
      const paths = projectPaths.map((value) => path11().join(value, "project.pbxproj")).filter((value) => (0, _fs().existsSync)(value));
      if (!paths.length) {
        throw new (_errors()).UnexpectedError(`Failed to locate the ios/*.xcodeproj/project.pbxproj files relative to path "${projectRoot}".`);
      }
      return paths;
    }
    function getPBXProjectPath(projectRoot) {
      const [using, ...extra] = getAllPBXProjectPaths(projectRoot);
      if (extra.length) {
        warnMultipleFiles({
          tag: "project-pbxproj",
          fileName: "project.pbxproj",
          projectRoot,
          using,
          extra
        });
      }
      return using;
    }
    function getAllInfoPlistPaths(projectRoot) {
      const paths = (0, _glob2().withSortedGlobResult)((0, _glob().globSync)("ios/*/Info.plist", {
        absolute: true,
        cwd: projectRoot,
        ignore: ignoredPaths
      })).sort(
        // longer name means more suffixes, we want the shortest possible one to be first.
        (a, b) => a.length - b.length
      );
      if (!paths.length) {
        throw new (_errors()).UnexpectedError(`Failed to locate Info.plist files relative to path "${projectRoot}".`);
      }
      return paths;
    }
    function getInfoPlistPath(projectRoot) {
      const [using, ...extra] = getAllInfoPlistPaths(projectRoot);
      if (extra.length) {
        warnMultipleFiles({
          tag: "info-plist",
          fileName: "Info.plist",
          projectRoot,
          using,
          extra
        });
      }
      return using;
    }
    function getAllEntitlementsPaths(projectRoot) {
      const paths = (0, _glob().globSync)("ios/*/*.entitlements", {
        absolute: true,
        cwd: projectRoot,
        ignore: ignoredPaths
      });
      return paths;
    }
    function getEntitlementsPath(projectRoot) {
      return Entitlements().getEntitlementsPath(projectRoot);
    }
    function getSupportingPath(projectRoot) {
      return path11().resolve(projectRoot, "ios", path11().basename(getSourceRoot(projectRoot)), "Supporting");
    }
    function getExpoPlistPath(projectRoot) {
      const supportingPath = getSupportingPath(projectRoot);
      return path11().join(supportingPath, "Expo.plist");
    }
    function warnMultipleFiles({
      tag,
      fileName,
      projectRoot,
      using,
      extra
    }) {
      const usingPath = projectRoot ? path11().relative(projectRoot, using) : using;
      const extraPaths = projectRoot ? extra.map((v) => path11().relative(projectRoot, v)) : extra;
      (0, _warnings().addWarningIOS)(`paths-${tag}`, `Found multiple ${fileName} file paths, using "${usingPath}". Ignored paths: ${JSON.stringify(extraPaths)}`);
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/utils/Xcodeproj.js
var require_Xcodeproj = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/utils/Xcodeproj.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addBuildSourceFileToGroup = addBuildSourceFileToGroup;
    exports2.addFileToGroupAndLink = addFileToGroupAndLink;
    exports2.addFramework = addFramework;
    exports2.addResourceFileToGroup = addResourceFileToGroup;
    exports2.ensureGroupRecursively = ensureGroupRecursively;
    exports2.getApplicationNativeTarget = getApplicationNativeTarget;
    exports2.getBuildConfigurationForListIdAndName = getBuildConfigurationForListIdAndName;
    exports2.getBuildConfigurationsForListId = getBuildConfigurationsForListId;
    exports2.getHackyProjectName = getHackyProjectName;
    exports2.getPbxproj = getPbxproj;
    exports2.getProductName = getProductName;
    exports2.getProjectName = getProjectName;
    exports2.getProjectSection = getProjectSection;
    exports2.getXCConfigurationListEntries = getXCConfigurationListEntries;
    exports2.isBuildConfig = isBuildConfig;
    exports2.isNotComment = isNotComment;
    exports2.isNotTestHost = isNotTestHost;
    exports2.resolvePathOrProject = resolvePathOrProject;
    exports2.resolveXcodeBuildSetting = resolveXcodeBuildSetting;
    exports2.sanitizedName = sanitizedName;
    exports2.unquote = unquote;
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _slugify() {
      const data = _interopRequireDefault(require_slugify());
      _slugify = function() {
        return data;
      };
      return data;
    }
    function _xcode() {
      const data = _interopRequireDefault(require_xcode());
      _xcode = function() {
        return data;
      };
      return data;
    }
    function _pbxFile() {
      const data = _interopRequireDefault(require_pbxFile());
      _pbxFile = function() {
        return data;
      };
      return data;
    }
    function _string() {
      const data = require_string();
      _string = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    function Paths() {
      const data = _interopRequireWildcard(require_Paths2());
      Paths = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function getProjectName(projectRoot) {
      const sourceRoot = Paths().getSourceRoot(projectRoot);
      return _path().default.basename(sourceRoot);
    }
    function resolvePathOrProject(projectRootOrProject) {
      if (typeof projectRootOrProject === "string") {
        try {
          return getPbxproj(projectRootOrProject);
        } catch {
          return null;
        }
      }
      return projectRootOrProject;
    }
    function sanitizedName(name) {
      return sanitizedNameForProjects(name) || sanitizedNameForProjects((0, _slugify().default)(name)) || "app";
    }
    function sanitizedNameForProjects(name) {
      return name.replace(/[\W_]+/g, "").normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }
    function getHackyProjectName(projectRoot, config) {
      try {
        return getProjectName(projectRoot);
      } catch {
        const projectName = config.name;
        (0, _assert().default)(projectName, "Your project needs a name in app.json/app.config.js.");
        return sanitizedName(projectName);
      }
    }
    function createProjectFileForGroup({
      filepath,
      group
    }) {
      const file = new (_pbxFile()).default(filepath);
      const conflictingFile = group.children.find((child) => child.comment === file.basename);
      if (conflictingFile) {
        return null;
      }
      return file;
    }
    function addResourceFileToGroup({
      filepath,
      groupName,
      // Should add to `PBXBuildFile Section`
      isBuildFile,
      project,
      verbose,
      targetUuid
    }) {
      return addFileToGroupAndLink({
        filepath,
        groupName,
        project,
        verbose,
        targetUuid,
        addFileToProject({
          project: project2,
          file
        }) {
          project2.addToPbxFileReferenceSection(file);
          if (isBuildFile) {
            project2.addToPbxBuildFileSection(file);
          }
          project2.addToPbxResourcesBuildPhase(file);
        }
      });
    }
    function addBuildSourceFileToGroup({
      filepath,
      groupName,
      project,
      verbose,
      targetUuid
    }) {
      return addFileToGroupAndLink({
        filepath,
        groupName,
        project,
        verbose,
        targetUuid,
        addFileToProject({
          project: project2,
          file
        }) {
          project2.addToPbxFileReferenceSection(file);
          project2.addToPbxBuildFileSection(file);
          project2.addToPbxSourcesBuildPhase(file);
        }
      });
    }
    function addFileToGroupAndLink({
      filepath,
      groupName,
      project,
      verbose,
      addFileToProject,
      targetUuid
    }) {
      const group = pbxGroupByPathOrAssert(project, groupName);
      const file = createProjectFileForGroup({
        filepath,
        group
      });
      if (!file) {
        if (verbose) {
          (0, _warnings().addWarningIOS)("ios-xcode-project", `Skipped adding duplicate file "${filepath}" to PBXGroup named "${groupName}"`);
        }
        return project;
      }
      if (targetUuid != null) {
        file.target = targetUuid;
      } else {
        const applicationNativeTarget = project.getTarget("com.apple.product-type.application");
        file.target = applicationNativeTarget?.uuid;
      }
      file.uuid = project.generateUuid();
      file.fileRef = project.generateUuid();
      addFileToProject({
        project,
        file
      });
      group.children.push({
        value: file.fileRef,
        comment: file.basename
      });
      return project;
    }
    function getApplicationNativeTarget({
      project,
      projectName
    }) {
      const applicationNativeTarget = project.getTarget("com.apple.product-type.application");
      (0, _assert().default)(applicationNativeTarget, `Couldn't locate application PBXNativeTarget in '.xcodeproj' file.`);
      (0, _assert().default)(String(applicationNativeTarget.target.name) === projectName, `Application native target name mismatch. Expected ${projectName}, but found ${applicationNativeTarget.target.name}.`);
      return applicationNativeTarget;
    }
    function addFramework({
      project,
      projectName,
      framework
    }) {
      const target = getApplicationNativeTarget({
        project,
        projectName
      });
      return project.addFramework(framework, {
        target: target.uuid
      });
    }
    function splitPath(path11) {
      return path11.split("/");
    }
    var findGroup = (group, name) => {
      if (!group) {
        return void 0;
      }
      return group.children.find((group2) => group2.comment === name);
    };
    function findGroupInsideGroup(project, group, name) {
      const foundGroup = findGroup(group, name);
      if (foundGroup) {
        return project.getPBXGroupByKey(foundGroup.value) ?? null;
      }
      return null;
    }
    function pbxGroupByPathOrAssert(project, path11) {
      const {
        firstProject
      } = project.getFirstProject();
      let group = project.getPBXGroupByKey(firstProject.mainGroup);
      const components = splitPath(path11);
      for (const name of components) {
        const nextGroup = findGroupInsideGroup(project, group, name);
        if (nextGroup) {
          group = nextGroup;
        } else {
          break;
        }
      }
      if (!group) {
        throw Error(`Xcode PBXGroup with name "${path11}" could not be found in the Xcode project.`);
      }
      return group;
    }
    function ensureGroupRecursively(project, filepath) {
      const components = splitPath(filepath);
      const hasChild = (group, name) => group.children.find(({
        comment
      }) => comment === name);
      const {
        firstProject
      } = project.getFirstProject();
      let topMostGroup = project.getPBXGroupByKey(firstProject.mainGroup);
      for (const pathComponent of components) {
        if (topMostGroup && !hasChild(topMostGroup, pathComponent)) {
          topMostGroup.children.push({
            comment: pathComponent,
            value: project.pbxCreateGroup(pathComponent, '""')
          });
        }
        topMostGroup = project.pbxGroupByName(pathComponent);
      }
      return topMostGroup ?? null;
    }
    function getPbxproj(projectRoot) {
      const projectPath = Paths().getPBXProjectPath(projectRoot);
      const project = _xcode().default.project(projectPath);
      project.parseSync();
      return project;
    }
    function getProductName(project) {
      let productName = "$(TARGET_NAME)";
      try {
        productName = project.productName;
      } catch {
      }
      if (productName === "$(TARGET_NAME)") {
        const targetName = project.getFirstTarget()?.firstTarget?.productName;
        productName = targetName ?? productName;
      }
      return productName;
    }
    function getProjectSection(project) {
      return project.pbxProjectSection();
    }
    function getXCConfigurationListEntries(project) {
      const lists = project.pbxXCConfigurationList();
      return Object.entries(lists).filter(isNotComment);
    }
    function getBuildConfigurationsForListId(project, configurationListId) {
      const configurationListEntries = getXCConfigurationListEntries(project);
      const [, configurationList] = configurationListEntries.find(([key3]) => key3 === configurationListId);
      const buildConfigurations = configurationList.buildConfigurations.map((i2) => i2.value);
      return Object.entries(project.pbxXCBuildConfigurationSection()).filter(isNotComment).filter(isBuildConfig).filter(([key3]) => buildConfigurations.includes(key3));
    }
    function getBuildConfigurationForListIdAndName(project, {
      configurationListId,
      buildConfiguration
    }) {
      const xcBuildConfigurationEntry = getBuildConfigurationsForListId(project, configurationListId).find((i2) => (0, _string().trimQuotes)(i2[1].name) === buildConfiguration);
      if (!xcBuildConfigurationEntry) {
        throw new Error(`Build configuration '${buildConfiguration}' does not exist in list with id '${configurationListId}'`);
      }
      return xcBuildConfigurationEntry;
    }
    function isBuildConfig([, sectionItem]) {
      return sectionItem.isa === "XCBuildConfiguration";
    }
    function isNotTestHost([, sectionItem]) {
      return !sectionItem.buildSettings.TEST_HOST;
    }
    function isNotComment([key3]) {
      return !key3.endsWith(`_comment`);
    }
    function unquote(value) {
      if (typeof value === "number") {
        value = String(value);
      }
      return value.match(/^"(.*)"$/)?.[1] ?? value;
    }
    function resolveXcodeBuildSetting(value, lookup) {
      const parsedValue = value?.replace(/\$\(([^()]*|\([^)]*\))\)/g, (match) => {
        const [variable, ...transformations] = match.slice(2, -1).split(":");
        let lookedUp = lookup(variable);
        if (lookedUp) {
          lookedUp = resolveXcodeBuildSetting(lookedUp, lookup);
        }
        let resolved = lookedUp;
        transformations.forEach((modifier) => {
          switch (modifier) {
            case "lower":
              resolved = resolved?.toLowerCase();
              break;
            case "upper":
              resolved = resolved?.toUpperCase();
              break;
            case "suffix":
              if (resolved) {
                resolved = _path().default.extname(resolved);
              }
              break;
            case "file":
              if (resolved) {
                resolved = _path().default.basename(resolved);
              }
              break;
            case "dir":
              if (resolved) {
                resolved = _path().default.dirname(resolved);
              }
              break;
            case "base":
              if (resolved) {
                const b = _path().default.basename(resolved);
                const extensionIndex = b.lastIndexOf(".");
                resolved = extensionIndex === -1 ? b : b.slice(0, extensionIndex);
              }
              break;
            case "rfc1034identifier":
              resolved = resolved?.replace(/[^a-zA-Z0-9]/g, "-");
              break;
            case "c99extidentifier":
              resolved = resolved?.replace(/[-\s]/g, "_");
              break;
            case "standardizepath":
              if (resolved) {
                resolved = _path().default.resolve(resolved);
              }
              break;
            default:
              resolved ||= modifier.match(/default=(.*)/)?.[1];
              break;
          }
        });
        return resolveXcodeBuildSetting(resolved ?? "", lookup);
      });
      if (parsedValue !== value) {
        return resolveXcodeBuildSetting(parsedValue, lookup);
      }
      return value;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/Bitcode.js
var require_Bitcode = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Bitcode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getBitcode = getBitcode;
    exports2.setBitcode = setBitcode;
    exports2.setBitcodeWithConfig = setBitcodeWithConfig;
    exports2.withCustomBitcode = exports2.withBitcode = void 0;
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    var withBitcode = (config) => {
      return (0, _iosPlugins().withXcodeProject)(config, async (config2) => {
        config2.modResults = await setBitcodeWithConfig(config2, {
          project: config2.modResults
        });
        return config2;
      });
    };
    exports2.withBitcode = withBitcode;
    var withCustomBitcode = (config, bitcode) => {
      return (0, _iosPlugins().withXcodeProject)(config, async (config2) => {
        config2.modResults = await setBitcode(bitcode, {
          project: config2.modResults
        });
        return config2;
      });
    };
    exports2.withCustomBitcode = withCustomBitcode;
    function getBitcode(config) {
      return config.ios?.bitcode;
    }
    function setBitcodeWithConfig(config, {
      project
    }) {
      const bitcode = getBitcode(config);
      return setBitcode(bitcode, {
        project
      });
    }
    function setBitcode(bitcode, {
      project
    }) {
      const isDefaultBehavior = bitcode == null;
      if (isDefaultBehavior) {
        return project;
      }
      const targetName = typeof bitcode === "string" ? bitcode : void 0;
      const isBitcodeEnabled = !!bitcode;
      if (targetName) {
        const configs = Object.entries(project.pbxXCBuildConfigurationSection()).filter(_Xcodeproj().isNotComment);
        const hasConfiguration = configs.find(([, configuration]) => configuration.name === targetName);
        if (hasConfiguration) {
          project.addBuildProperty("ENABLE_BITCODE", "NO");
        } else {
          const names = [
            // Remove duplicates, wrap in double quotes, and sort alphabetically.
            ...new Set(configs.map(([, configuration]) => `"${configuration.name}"`))
          ].sort();
          (0, _warnings().addWarningIOS)("ios.bitcode", `No configuration named "${targetName}". Expected one of: ${names.join(", ")}.`);
        }
      }
      project.addBuildProperty("ENABLE_BITCODE", isBitcodeEnabled ? "YES" : "NO", targetName);
      return project;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/BuildProperties.js
var require_BuildProperties2 = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/BuildProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createBuildPodfilePropsConfigPlugin = createBuildPodfilePropsConfigPlugin;
    exports2.updateIosBuildPropertiesFromConfig = updateIosBuildPropertiesFromConfig;
    exports2.updateIosBuildProperty = updateIosBuildProperty;
    exports2.withNewArchEnabledPodfileProps = exports2.withJsEnginePodfileProps = void 0;
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function createBuildPodfilePropsConfigPlugin(configToPropertyRules, name) {
      const withUnknown = (config, sourceConfig) => (0, _iosPlugins().withPodfileProperties)(config, (config2) => {
        config2.modResults = updateIosBuildPropertiesFromConfig(sourceConfig ?? config2, config2.modResults, configToPropertyRules);
        return config2;
      });
      if (name) {
        Object.defineProperty(withUnknown, "name", {
          value: name
        });
      }
      return withUnknown;
    }
    var withJsEnginePodfileProps = exports2.withJsEnginePodfileProps = createBuildPodfilePropsConfigPlugin([{
      propName: "expo.jsEngine",
      propValueGetter: (config) => config.ios?.jsEngine ?? config.jsEngine ?? "hermes"
    }], "withJsEnginePodfileProps");
    var withNewArchEnabledPodfileProps = exports2.withNewArchEnabledPodfileProps = createBuildPodfilePropsConfigPlugin([{
      propName: "newArchEnabled",
      propValueGetter: (config) => (config.ios?.newArchEnabled ?? config.newArchEnabled)?.toString()
    }], "withNewArchEnabledPodfileProps");
    function updateIosBuildPropertiesFromConfig(config, podfileProperties, configToPropertyRules) {
      for (const configToProperty of configToPropertyRules) {
        const value = configToProperty.propValueGetter(config);
        updateIosBuildProperty(podfileProperties, configToProperty.propName, value);
      }
      return podfileProperties;
    }
    function updateIosBuildProperty(podfileProperties, name, value, options) {
      if (value) {
        podfileProperties[name] = value;
      } else if (options?.removePropWhenValueIsNull) {
        delete podfileProperties[name];
      }
      return podfileProperties;
    }
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/Utility.js"(exports2, module2) {
    "use strict";
    (function() {
      var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, hasProp = {}.hasOwnProperty;
      assign = function(target, ...sources) {
        var i2, key3, len, source2;
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i2 = 0, len = sources.length; i2 < len; i2++) {
            source2 = sources[i2];
            if (source2 != null) {
              for (key3 in source2) {
                if (!hasProp.call(source2, key3)) continue;
                target[key3] = source2[key3];
              }
            }
          }
        }
        return target;
      };
      isFunction = function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      };
      isObject = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      };
      isArray = function(val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      };
      isEmpty = function(val) {
        var key3;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key3 in val) {
            if (!hasProp.call(val, key3)) continue;
            return false;
          }
          return true;
        }
      };
      isPlainObject = function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      };
      getValue = function(obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      };
      module2.exports.assign = assign;
      module2.exports.isFunction = isFunction;
      module2.exports.isObject = isObject;
      module2.exports.isArray = isArray;
      module2.exports.isEmpty = isEmpty;
      module2.exports.isPlainObject = isPlainObject;
      module2.exports.getValue = getValue;
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDOMImplementation.js"(exports2, module2) {
    "use strict";
    (function() {
      var XMLDOMImplementation;
      module2.exports = XMLDOMImplementation = class XMLDOMImplementation {
        // Tests if the DOM implementation implements a specific feature.
        // `feature` package name of the feature to test. In Level 1, the
        //           legal values are "HTML" and "XML" (case-insensitive).
        // `version` version number of the package name to test. 
        //           In Level 1, this is the string "1.0". If the version is 
        //           not specified, supporting any version of the feature will 
        //           cause the method to return true.
        hasFeature(feature, version) {
          return true;
        }
        // Creates a new document type declaration.
        // `qualifiedName` qualified name of the document type to be created
        // `publicId` public identifier of the external subset
        // `systemId` system identifier of the external subset
        createDocumentType(qualifiedName, publicId, systemId) {
          throw new Error("This DOM method is not implemented.");
        }
        // Creates a new document.
        // `namespaceURI` namespace URI of the document element to create
        // `qualifiedName` the qualified name of the document to be created
        // `doctype` the type of document to be created or null
        createDocument(namespaceURI, qualifiedName, doctype) {
          throw new Error("This DOM method is not implemented.");
        }
        // Creates a new HTML document.
        // `title` document title
        createHTMLDocument(title) {
          throw new Error("This DOM method is not implemented.");
        }
        // Returns a specialized object which implements the specialized APIs 
        // of the specified feature and version.
        // `feature` name of the feature requested.
        // `version` version number of the feature to test
        getFeature(feature, version) {
          throw new Error("This DOM method is not implemented.");
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js"(exports2, module2) {
    "use strict";
    (function() {
      var XMLDOMErrorHandler;
      module2.exports = XMLDOMErrorHandler = class XMLDOMErrorHandler {
        // Initializes a new instance of `XMLDOMErrorHandler`
        constructor() {
        }
        // Called on the error handler when an error occurs.
        // `error` the error message as a string
        handleError(error) {
          throw new Error(error);
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDOMStringList.js"(exports2, module2) {
    "use strict";
    (function() {
      var XMLDOMStringList;
      module2.exports = XMLDOMStringList = function() {
        class XMLDOMStringList2 {
          // Initializes a new instance of `XMLDOMStringList`
          // This is just a wrapper around an ordinary
          // JS array.
          // `arr` the array of string values
          constructor(arr) {
            this.arr = arr || [];
          }
          // Returns the indexth item in the collection.
          // `index` index into the collection
          item(index) {
            return this.arr[index] || null;
          }
          // Test if a string is part of this DOMStringList.
          // `str` the string to look for
          contains(str) {
            return this.arr.indexOf(str) !== -1;
          }
        }
        ;
        Object.defineProperty(XMLDOMStringList2.prototype, "length", {
          get: function() {
            return this.arr.length;
          }
        });
        return XMLDOMStringList2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDOMConfiguration.js"(exports2, module2) {
    "use strict";
    (function() {
      var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
      XMLDOMErrorHandler = require_XMLDOMErrorHandler();
      XMLDOMStringList = require_XMLDOMStringList();
      module2.exports = XMLDOMConfiguration = function() {
        class XMLDOMConfiguration2 {
          constructor() {
            var clonedSelf;
            this.defaultParams = {
              "canonical-form": false,
              "cdata-sections": false,
              "comments": false,
              "datatype-normalization": false,
              "element-content-whitespace": true,
              "entities": true,
              "error-handler": new XMLDOMErrorHandler(),
              "infoset": true,
              "validate-if-schema": false,
              "namespaces": true,
              "namespace-declarations": true,
              "normalize-characters": false,
              "schema-location": "",
              "schema-type": "",
              "split-cdata-sections": true,
              "validate": false,
              "well-formed": true
            };
            this.params = clonedSelf = Object.create(this.defaultParams);
          }
          // Gets the value of a parameter.
          // `name` name of the parameter
          getParameter(name) {
            if (this.params.hasOwnProperty(name)) {
              return this.params[name];
            } else {
              return null;
            }
          }
          // Checks if setting a parameter to a specific value is supported.
          // `name` name of the parameter
          // `value` parameter value
          canSetParameter(name, value) {
            return true;
          }
          // Sets the value of a parameter.
          // `name` name of the parameter
          // `value` new value or null if the user wishes to unset the parameter
          setParameter(name, value) {
            if (value != null) {
              return this.params[name] = value;
            } else {
              return delete this.params[name];
            }
          }
        }
        ;
        Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
          get: function() {
            return new XMLDOMStringList(Object.keys(this.defaultParams));
          }
        });
        return XMLDOMConfiguration2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/NodeType.js"(exports2, module2) {
    "use strict";
    (function() {
      module2.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        // Numeric codes up to 200 are reserved to W3C for possible future use.
        // Following are types internal to this library:
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLAttribute.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLAttribute, XMLNode;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLAttribute = function() {
        class XMLAttribute2 {
          // Initializes a new instance of `XMLAttribute`
          // `parent` the parent node
          // `name` attribute target
          // `value` attribute value
          constructor(parent, name, value) {
            this.parent = parent;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            if (name == null) {
              throw new Error("Missing attribute name. " + this.debugInfo(name));
            }
            this.name = this.stringify.name(name);
            this.value = this.stringify.attValue(value);
            this.type = NodeType.Attribute;
            this.isId = false;
            this.schemaTypeInfo = null;
          }
          // Creates and returns a deep clone of `this`
          clone() {
            return Object.create(this);
          }
          // Converts the XML fragment to string
          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
          }
          // Returns debug string for this node
          debugInfo(name) {
            name = name || this.name;
            if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else {
              return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
            }
          }
          isEqualNode(node) {
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.value !== this.value) {
              return false;
            }
            return true;
          }
        }
        ;
        Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "specified", {
          get: function() {
            return true;
          }
        });
        return XMLAttribute2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js"(exports2, module2) {
    "use strict";
    (function() {
      var XMLNamedNodeMap;
      module2.exports = XMLNamedNodeMap = function() {
        class XMLNamedNodeMap2 {
          // Initializes a new instance of `XMLNamedNodeMap`
          // This is just a wrapper around an ordinary
          // JS object.
          // `nodes` the object containing nodes.
          constructor(nodes) {
            this.nodes = nodes;
          }
          // Creates and returns a deep clone of `this`
          clone() {
            return this.nodes = null;
          }
          // DOM Level 1
          getNamedItem(name) {
            return this.nodes[name];
          }
          setNamedItem(node) {
            var oldNode;
            oldNode = this.nodes[node.nodeName];
            this.nodes[node.nodeName] = node;
            return oldNode || null;
          }
          removeNamedItem(name) {
            var oldNode;
            oldNode = this.nodes[name];
            delete this.nodes[name];
            return oldNode || null;
          }
          item(index) {
            return this.nodes[Object.keys(this.nodes)[index]] || null;
          }
          // DOM level 2 functions to be implemented later
          getNamedItemNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          }
          setNamedItemNS(node) {
            throw new Error("This DOM method is not implemented.");
          }
          removeNamedItemNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          }
        }
        ;
        Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
          get: function() {
            return Object.keys(this.nodes).length || 0;
          }
        });
        return XMLNamedNodeMap2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLElement.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, hasProp = {}.hasOwnProperty;
      ({ isObject, isFunction, getValue } = require_Utility());
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLAttribute = require_XMLAttribute();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLElement = function() {
        class XMLElement2 extends XMLNode {
          // Initializes a new instance of `XMLElement`
          // `parent` the parent node
          // `name` element name
          // `attributes` an object containing name/value pairs of attributes
          constructor(parent, name, attributes) {
            var child, j, len, ref;
            super(parent);
            if (name == null) {
              throw new Error("Missing element name. " + this.debugInfo());
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.Element;
            this.attribs = {};
            this.schemaTypeInfo = null;
            if (attributes != null) {
              this.attribute(attributes);
            }
            if (parent.type === NodeType.Document) {
              this.isRoot = true;
              this.documentObject = parent;
              parent.rootObject = this;
              if (parent.children) {
                ref = parent.children;
                for (j = 0, len = ref.length; j < len; j++) {
                  child = ref[j];
                  if (child.type === NodeType.DocType) {
                    child.name = this.name;
                    break;
                  }
                }
              }
            }
          }
          // Creates and returns a deep clone of `this`
          clone() {
            var att, attName, clonedSelf, ref;
            clonedSelf = Object.create(this);
            if (clonedSelf.isRoot) {
              clonedSelf.documentObject = null;
            }
            clonedSelf.attribs = {};
            ref = this.attribs;
            for (attName in ref) {
              if (!hasProp.call(ref, attName)) continue;
              att = ref[attName];
              clonedSelf.attribs[attName] = att.clone();
            }
            clonedSelf.children = [];
            this.children.forEach(function(child) {
              var clonedChild;
              clonedChild = child.clone();
              clonedChild.parent = clonedSelf;
              return clonedSelf.children.push(clonedChild);
            });
            return clonedSelf;
          }
          // Adds or modifies an attribute
          // `name` attribute name
          // `value` attribute value
          attribute(name, value) {
            var attName, attValue;
            if (name != null) {
              name = getValue(name);
            }
            if (isObject(name)) {
              for (attName in name) {
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              if (this.options.keepNullAttributes && value == null) {
                this.attribs[name] = new XMLAttribute(this, name, "");
              } else if (value != null) {
                this.attribs[name] = new XMLAttribute(this, name, value);
              }
            }
            return this;
          }
          // Removes an attribute
          // `name` attribute name
          removeAttribute(name) {
            var attName, j, len;
            if (name == null) {
              throw new Error("Missing attribute name. " + this.debugInfo());
            }
            name = getValue(name);
            if (Array.isArray(name)) {
              for (j = 0, len = name.length; j < len; j++) {
                attName = name[j];
                delete this.attribs[attName];
              }
            } else {
              delete this.attribs[name];
            }
            return this;
          }
          // Converts the XML fragment to string
          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          // `options.allowEmpty` do not self close empty element tags
          toString(options) {
            return this.options.writer.element(this, this.options.writer.filterOptions(options));
          }
          // Aliases
          att(name, value) {
            return this.attribute(name, value);
          }
          a(name, value) {
            return this.attribute(name, value);
          }
          // DOM Level 1
          getAttribute(name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].value;
            } else {
              return null;
            }
          }
          setAttribute(name, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getAttributeNode(name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name];
            } else {
              return null;
            }
          }
          setAttributeNode(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          removeAttributeNode(oldAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getElementsByTagName(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          // DOM Level 2
          getAttributeNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          setAttributeNS(namespaceURI, qualifiedName, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          removeAttributeNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getAttributeNodeNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          setAttributeNodeNS(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getElementsByTagNameNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          hasAttribute(name) {
            return this.attribs.hasOwnProperty(name);
          }
          hasAttributeNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          // DOM Level 3
          setIdAttribute(name, isId) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].isId;
            } else {
              return isId;
            }
          }
          setIdAttributeNS(namespaceURI, localName, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          setIdAttributeNode(idAttr, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          // DOM Level 4
          getElementsByTagName(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getElementsByTagNameNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getElementsByClassName(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          isEqualNode(node) {
            var i2, j, ref;
            if (!super.isEqualNode(node)) {
              return false;
            }
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.attribs.length !== this.attribs.length) {
              return false;
            }
            for (i2 = j = 0, ref = this.attribs.length - 1; 0 <= ref ? j <= ref : j >= ref; i2 = 0 <= ref ? ++j : --j) {
              if (!this.attribs[i2].isEqualNode(node.attribs[i2])) {
                return false;
              }
            }
            return true;
          }
        }
        ;
        Object.defineProperty(XMLElement2.prototype, "tagName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "id", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "className", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "classList", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "attributes", {
          get: function() {
            if (!this.attributeMap || !this.attributeMap.nodes) {
              this.attributeMap = new XMLNamedNodeMap(this.attribs);
            }
            return this.attributeMap;
          }
        });
        return XMLElement2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLCharacterData.js"(exports2, module2) {
    "use strict";
    (function() {
      var XMLCharacterData, XMLNode;
      XMLNode = require_XMLNode();
      module2.exports = XMLCharacterData = function() {
        class XMLCharacterData2 extends XMLNode {
          // Initializes a new instance of `XMLCharacterData`
          constructor(parent) {
            super(parent);
            this.value = "";
          }
          // Creates and returns a deep clone of `this`
          clone() {
            return Object.create(this);
          }
          // DOM level 1 functions to be implemented later
          substringData(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          appendData(arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          insertData(offset, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          deleteData(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          replaceData(offset, count, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          isEqualNode(node) {
            if (!super.isEqualNode(node)) {
              return false;
            }
            if (node.data !== this.data) {
              return false;
            }
            return true;
          }
        }
        ;
        Object.defineProperty(XMLCharacterData2.prototype, "data", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "length", {
          get: function() {
            return this.value.length;
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        return XMLCharacterData2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLCData.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLCData, XMLCharacterData;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLCData = class XMLCData extends XMLCharacterData {
        // Initializes a new instance of `XMLCData`
        // `text` CDATA text
        constructor(parent, text) {
          super(parent);
          if (text == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.name = "#cdata-section";
          this.type = NodeType.CData;
          this.value = this.stringify.cdata(text);
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLComment.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLCharacterData, XMLComment;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLComment = class XMLComment extends XMLCharacterData {
        // Initializes a new instance of `XMLComment`
        // `text` comment text
        constructor(parent, text) {
          super(parent);
          if (text == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.name = "#comment";
          this.type = NodeType.Comment;
          this.value = this.stringify.comment(text);
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLDeclaration, XMLNode, isObject;
      ({ isObject } = require_Utility());
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDeclaration = class XMLDeclaration extends XMLNode {
        // Initializes a new instance of `XMLDeclaration`
        // `parent` the document object
        // `version` A version number string, e.g. 1.0
        // `encoding` Encoding declaration, e.g. UTF-8
        // `standalone` standalone document declaration: true or false
        constructor(parent, version, encoding, standalone) {
          super(parent);
          if (isObject(version)) {
            ({ version, encoding, standalone } = version);
          }
          if (!version) {
            version = "1.0";
          }
          this.type = NodeType.Declaration;
          this.version = this.stringify.xmlVersion(version);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        // Converts to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLDTDAttList, XMLNode;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDAttList = class XMLDTDAttList extends XMLNode {
        // Initializes a new instance of `XMLDTDAttList`
        // `parent` the parent `XMLDocType` element
        // `elementName` the name of the element containing this attribute
        // `attributeName` attribute name
        // `attributeType` type of the attribute
        // `defaultValueType` default value type (either #REQUIRED, #IMPLIED,
        //                    #FIXED or #DEFAULT)
        // `defaultValue` default value of the attribute
        //                (only used for #FIXED or #DEFAULT)
        constructor(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          super(parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.name(elementName);
          this.type = NodeType.AttributeDeclaration;
          this.attributeName = this.stringify.name(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          if (defaultValue) {
            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          }
          this.defaultValueType = defaultValueType;
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLDTDEntity, XMLNode, isObject;
      ({ isObject } = require_Utility());
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDEntity = function() {
        class XMLDTDEntity2 extends XMLNode {
          // Initializes a new instance of `XMLDTDEntity`
          // `parent` the parent `XMLDocType` element
          // `pe` whether this is a parameter entity or a general entity
          //      defaults to `false` (general entity)
          // `name` the name of the entity
          // `value` internal entity value or an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          // `value.nData` notation declaration
          constructor(parent, pe, name, value) {
            super(parent);
            if (name == null) {
              throw new Error("Missing DTD entity name. " + this.debugInfo(name));
            }
            if (value == null) {
              throw new Error("Missing DTD entity value. " + this.debugInfo(name));
            }
            this.pe = !!pe;
            this.name = this.stringify.name(name);
            this.type = NodeType.EntityDeclaration;
            if (!isObject(value)) {
              this.value = this.stringify.dtdEntityValue(value);
              this.internal = true;
            } else {
              if (!value.pubID && !value.sysID) {
                throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
              }
              if (value.pubID && !value.sysID) {
                throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
              }
              this.internal = false;
              if (value.pubID != null) {
                this.pubID = this.stringify.dtdPubID(value.pubID);
              }
              if (value.sysID != null) {
                this.sysID = this.stringify.dtdSysID(value.sysID);
              }
              if (value.nData != null) {
                this.nData = this.stringify.dtdNData(value.nData);
              }
              if (this.pe && this.nData) {
                throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
              }
            }
          }
          // Converts the XML fragment to string
          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
          }
        }
        ;
        Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
          get: function() {
            return this.nData || null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
          get: function() {
            return null;
          }
        });
        return XMLDTDEntity2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLDTDElement, XMLNode;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDElement = class XMLDTDElement extends XMLNode {
        // Initializes a new instance of `XMLDTDElement`
        // `parent` the parent `XMLDocType` element
        // `name` element name
        // `value` element content (defaults to #PCDATA)
        constructor(parent, name, value) {
          super(parent);
          if (name == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.ElementDeclaration;
          this.value = this.stringify.dtdElementValue(value);
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLDTDNotation, XMLNode;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDNotation = function() {
        class XMLDTDNotation2 extends XMLNode {
          // Initializes a new instance of `XMLDTDNotation`
          // `parent` the parent `XMLDocType` element
          // `name` the name of the notation
          // `value` an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          constructor(parent, name, value) {
            super(parent);
            if (name == null) {
              throw new Error("Missing DTD notation name. " + this.debugInfo(name));
            }
            if (!value.pubID && !value.sysID) {
              throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.NotationDeclaration;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
          }
          // Converts the XML fragment to string
          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
          }
        }
        ;
        Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        return XMLDTDNotation2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDocType.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject;
      ({ isObject } = require_Utility());
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLDocType = function() {
        class XMLDocType2 extends XMLNode {
          // Initializes a new instance of `XMLDocType`
          // `parent` the document object
          // `pubID` public identifier of the external subset
          // `sysID` system identifier of the external subset
          constructor(parent, pubID, sysID) {
            var child, i2, len, ref;
            super(parent);
            this.type = NodeType.DocType;
            if (parent.children) {
              ref = parent.children;
              for (i2 = 0, len = ref.length; i2 < len; i2++) {
                child = ref[i2];
                if (child.type === NodeType.Element) {
                  this.name = child.name;
                  break;
                }
              }
            }
            this.documentObject = parent;
            if (isObject(pubID)) {
              ({ pubID, sysID } = pubID);
            }
            if (sysID == null) {
              [sysID, pubID] = [pubID, sysID];
            }
            if (pubID != null) {
              this.pubID = this.stringify.dtdPubID(pubID);
            }
            if (sysID != null) {
              this.sysID = this.stringify.dtdSysID(sysID);
            }
          }
          // Creates an element type declaration
          // `name` element name
          // `value` element content (defaults to #PCDATA)
          element(name, value) {
            var child;
            child = new XMLDTDElement(this, name, value);
            this.children.push(child);
            return this;
          }
          // Creates an attribute declaration
          // `elementName` the name of the element containing this attribute
          // `attributeName` attribute name
          // `attributeType` type of the attribute (defaults to CDATA)
          // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or
          //                    #DEFAULT) (defaults to #IMPLIED)
          // `defaultValue` default value of the attribute
          //                (only used for #FIXED or #DEFAULT)
          attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var child;
            child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.children.push(child);
            return this;
          }
          // Creates a general entity declaration
          // `name` the name of the entity
          // `value` internal entity value or an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          // `value.nData` notation declaration
          entity(name, value) {
            var child;
            child = new XMLDTDEntity(this, false, name, value);
            this.children.push(child);
            return this;
          }
          // Creates a parameter entity declaration
          // `name` the name of the entity
          // `value` internal entity value or an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          pEntity(name, value) {
            var child;
            child = new XMLDTDEntity(this, true, name, value);
            this.children.push(child);
            return this;
          }
          // Creates a NOTATION declaration
          // `name` the name of the notation
          // `value` an object with external entity details
          // `value.pubID` public identifier
          // `value.sysID` system identifier
          notation(name, value) {
            var child;
            child = new XMLDTDNotation(this, name, value);
            this.children.push(child);
            return this;
          }
          // Converts to string
          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.docType(this, this.options.writer.filterOptions(options));
          }
          // Aliases
          ele(name, value) {
            return this.element(name, value);
          }
          att(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
          }
          ent(name, value) {
            return this.entity(name, value);
          }
          pent(name, value) {
            return this.pEntity(name, value);
          }
          not(name, value) {
            return this.notation(name, value);
          }
          up() {
            return this.root() || this.documentObject;
          }
          isEqualNode(node) {
            if (!super.isEqualNode(node)) {
              return false;
            }
            if (node.name !== this.name) {
              return false;
            }
            if (node.publicId !== this.publicId) {
              return false;
            }
            if (node.systemId !== this.systemId) {
              return false;
            }
            return true;
          }
        }
        ;
        Object.defineProperty(XMLDocType2.prototype, "entities", {
          get: function() {
            var child, i2, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.EntityDeclaration && !child.pe) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "notations", {
          get: function() {
            var child, i2, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.NotationDeclaration) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        return XMLDocType2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLRaw.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLNode, XMLRaw;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLRaw = class XMLRaw extends XMLNode {
        // Initializes a new instance of `XMLRaw`
        // `text` raw text
        constructor(parent, text) {
          super(parent);
          if (text == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.type = NodeType.Raw;
          this.value = this.stringify.raw(text);
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLText.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLCharacterData, XMLText;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLText = function() {
        class XMLText2 extends XMLCharacterData {
          // Initializes a new instance of `XMLText`
          // `text` element text
          constructor(parent, text) {
            super(parent);
            if (text == null) {
              throw new Error("Missing element text. " + this.debugInfo());
            }
            this.name = "#text";
            this.type = NodeType.Text;
            this.value = this.stringify.text(text);
          }
          // Creates and returns a deep clone of `this`
          clone() {
            return Object.create(this);
          }
          // Converts the XML fragment to string
          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.text(this, this.options.writer.filterOptions(options));
          }
          // DOM level 1 functions to be implemented later
          splitText(offset) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          // DOM level 3 functions to be implemented later
          replaceWholeText(content) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        }
        ;
        Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLText2.prototype, "wholeText", {
          get: function() {
            var next, prev, str;
            str = "";
            prev = this.previousSibling;
            while (prev) {
              str = prev.data + str;
              prev = prev.previousSibling;
            }
            str += this.data;
            next = this.nextSibling;
            while (next) {
              str = str + next.data;
              next = next.nextSibling;
            }
            return str;
          }
        });
        return XMLText2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLCharacterData, XMLProcessingInstruction;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLProcessingInstruction = class XMLProcessingInstruction extends XMLCharacterData {
        // Initializes a new instance of `XMLProcessingInstruction`
        // `parent` the parent node
        // `target` instruction target
        // `value` instruction value
        constructor(parent, target, value) {
          super(parent);
          if (target == null) {
            throw new Error("Missing instruction target. " + this.debugInfo());
          }
          this.type = NodeType.ProcessingInstruction;
          this.target = this.stringify.insTarget(target);
          this.name = this.target;
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        }
        isEqualNode(node) {
          if (!super.isEqualNode(node)) {
            return false;
          }
          if (node.target !== this.target) {
            return false;
          }
          return true;
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDummy.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLDummy, XMLNode;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDummy = class XMLDummy extends XMLNode {
        // Initializes a new instance of `XMLDummy`
        // `XMLDummy` is a special node representing a node with 
        // a null value. Dummy nodes are created while recursively
        // building the XML tree. Simply skipping null values doesn't
        // work because that would break the recursive chain.
        constructor(parent) {
          super(parent);
          this.type = NodeType.Dummy;
        }
        // Creates and returns a deep clone of `this`
        clone() {
          return Object.create(this);
        }
        // Converts the XML fragment to string
        // `options.pretty` pretty prints the result
        // `options.indent` indentation for pretty print
        // `options.offset` how many indentations to add to every line for pretty print
        // `options.newline` newline sequence for pretty print
        toString(options) {
          return "";
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLNodeList.js"(exports2, module2) {
    "use strict";
    (function() {
      var XMLNodeList;
      module2.exports = XMLNodeList = function() {
        class XMLNodeList2 {
          // Initializes a new instance of `XMLNodeList`
          // This is just a wrapper around an ordinary
          // JS array.
          // `nodes` the array containing nodes.
          constructor(nodes) {
            this.nodes = nodes;
          }
          // Creates and returns a deep clone of `this`
          clone() {
            return this.nodes = null;
          }
          // DOM Level 1
          item(index) {
            return this.nodes[index] || null;
          }
        }
        ;
        Object.defineProperty(XMLNodeList2.prototype, "length", {
          get: function() {
            return this.nodes.length || 0;
          }
        });
        return XMLNodeList2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/DocumentPosition.js"(exports2, module2) {
    "use strict";
    (function() {
      module2.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLNode.js"(exports2, module2) {
    "use strict";
    (function() {
      var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, hasProp = {}.hasOwnProperty, splice = [].splice;
      ({ isObject, isFunction, isEmpty, getValue } = require_Utility());
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      NodeType = null;
      XMLNodeList = null;
      XMLNamedNodeMap = null;
      DocumentPosition = null;
      module2.exports = XMLNode = function() {
        class XMLNode2 {
          // Initializes a new instance of `XMLNode`
          // `parent` the parent node
          constructor(parent1) {
            this.parent = parent1;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            this.value = null;
            this.children = [];
            this.baseURI = null;
            if (!XMLElement) {
              XMLElement = require_XMLElement();
              XMLCData = require_XMLCData();
              XMLComment = require_XMLComment();
              XMLDeclaration = require_XMLDeclaration();
              XMLDocType = require_XMLDocType();
              XMLRaw = require_XMLRaw();
              XMLText = require_XMLText();
              XMLProcessingInstruction = require_XMLProcessingInstruction();
              XMLDummy = require_XMLDummy();
              NodeType = require_NodeType();
              XMLNodeList = require_XMLNodeList();
              XMLNamedNodeMap = require_XMLNamedNodeMap();
              DocumentPosition = require_DocumentPosition();
            }
          }
          // Sets the parent node of this node and its children recursively
          // `parent` the parent node
          setParent(parent) {
            var child, j, len, ref1, results;
            this.parent = parent;
            if (parent) {
              this.options = parent.options;
              this.stringify = parent.stringify;
            }
            ref1 = this.children;
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              results.push(child.setParent(this));
            }
            return results;
          }
          // Creates a child element node
          // `name` node name or an object describing the XML tree
          // `attributes` an object containing name/value pairs of attributes
          // `text` element text
          element(name, attributes, text) {
            var childNode, item, j, k, key3, lastChild, len, len1, val;
            lastChild = null;
            if (attributes === null && text == null) {
              [attributes, text] = [{}, null];
            }
            if (attributes == null) {
              attributes = {};
            }
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              [text, attributes] = [attributes, text];
            }
            if (name != null) {
              name = getValue(name);
            }
            if (Array.isArray(name)) {
              for (j = 0, len = name.length; j < len; j++) {
                item = name[j];
                lastChild = this.element(item);
              }
            } else if (isFunction(name)) {
              lastChild = this.element(name.apply());
            } else if (isObject(name)) {
              for (key3 in name) {
                if (!hasProp.call(name, key3)) continue;
                val = name[key3];
                if (isFunction(val)) {
                  val = val.apply();
                }
                if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key3.indexOf(this.stringify.convertAttKey) === 0) {
                  lastChild = this.attribute(key3.substr(this.stringify.convertAttKey.length), val);
                } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                  lastChild = this.dummy();
                } else if (isObject(val) && isEmpty(val)) {
                  lastChild = this.element(key3);
                } else if (!this.options.keepNullNodes && val == null) {
                  lastChild = this.dummy();
                } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                  for (k = 0, len1 = val.length; k < len1; k++) {
                    item = val[k];
                    childNode = {};
                    childNode[key3] = item;
                    lastChild = this.element(childNode);
                  }
                } else if (isObject(val)) {
                  if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key3.indexOf(this.stringify.convertTextKey) === 0) {
                    lastChild = this.element(val);
                  } else {
                    lastChild = this.element(key3);
                    lastChild.element(val);
                  }
                } else {
                  lastChild = this.element(key3, val);
                }
              }
            } else if (!this.options.keepNullNodes && text === null) {
              lastChild = this.dummy();
            } else {
              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
                lastChild = this.text(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
                lastChild = this.cdata(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
                lastChild = this.comment(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
                lastChild = this.raw(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
                lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
              } else {
                lastChild = this.node(name, attributes, text);
              }
            }
            if (lastChild == null) {
              throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
            }
            return lastChild;
          }
          // Creates a child element node before the current node
          // `name` node name or an object describing the XML tree
          // `attributes` an object containing name/value pairs of attributes
          // `text` element text
          insertBefore(name, attributes, text) {
            var child, i2, newChild, refChild, removed;
            if (name != null ? name.type : void 0) {
              newChild = name;
              refChild = attributes;
              newChild.setParent(this);
              if (refChild) {
                i2 = children.indexOf(refChild);
                removed = children.splice(i2);
                children.push(newChild);
                Array.prototype.push.apply(children, removed);
              } else {
                children.push(newChild);
              }
              return newChild;
            } else {
              if (this.isRoot) {
                throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
              }
              i2 = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i2);
              child = this.parent.element(name, attributes, text);
              Array.prototype.push.apply(this.parent.children, removed);
              return child;
            }
          }
          // Creates a child element node after the current node
          // `name` node name or an object describing the XML tree
          // `attributes` an object containing name/value pairs of attributes
          // `text` element text
          insertAfter(name, attributes, text) {
            var child, i2, removed;
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            }
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2 + 1);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          }
          // Deletes a child element node
          remove() {
            var i2, ref1;
            if (this.isRoot) {
              throw new Error("Cannot remove the root element. " + this.debugInfo());
            }
            i2 = this.parent.children.indexOf(this);
            splice.apply(this.parent.children, [i2, i2 - i2 + 1].concat(ref1 = [])), ref1;
            return this.parent;
          }
          // Creates a node
          // `name` name of the node
          // `attributes` an object containing name/value pairs of attributes
          // `text` element text
          node(name, attributes, text) {
            var child;
            if (name != null) {
              name = getValue(name);
            }
            attributes || (attributes = {});
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              [text, attributes] = [attributes, text];
            }
            child = new XMLElement(this, name, attributes);
            if (text != null) {
              child.text(text);
            }
            this.children.push(child);
            return child;
          }
          // Creates a text node
          // `value` element text
          text(value) {
            var child;
            if (isObject(value)) {
              this.element(value);
            }
            child = new XMLText(this, value);
            this.children.push(child);
            return this;
          }
          // Creates a CDATA node
          // `value` element text without CDATA delimiters
          cdata(value) {
            var child;
            child = new XMLCData(this, value);
            this.children.push(child);
            return this;
          }
          // Creates a comment node
          // `value` comment text
          comment(value) {
            var child;
            child = new XMLComment(this, value);
            this.children.push(child);
            return this;
          }
          // Creates a comment node before the current node
          // `value` comment text
          commentBefore(value) {
            var child, i2, removed;
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          }
          // Creates a comment node after the current node
          // `value` comment text
          commentAfter(value) {
            var child, i2, removed;
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2 + 1);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          }
          // Adds unescaped raw text
          // `value` text
          raw(value) {
            var child;
            child = new XMLRaw(this, value);
            this.children.push(child);
            return this;
          }
          // Adds a dummy node
          dummy() {
            var child;
            child = new XMLDummy(this);
            return child;
          }
          // Adds a processing instruction
          // `target` instruction target
          // `value` instruction value
          instruction(target, value) {
            var insTarget, insValue, instruction, j, len;
            if (target != null) {
              target = getValue(target);
            }
            if (value != null) {
              value = getValue(value);
            }
            if (Array.isArray(target)) {
              for (j = 0, len = target.length; j < len; j++) {
                insTarget = target[j];
                this.instruction(insTarget);
              }
            } else if (isObject(target)) {
              for (insTarget in target) {
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              instruction = new XMLProcessingInstruction(this, target, value);
              this.children.push(instruction);
            }
            return this;
          }
          // Creates a processing instruction node before the current node
          // `target` instruction target
          // `value` instruction value
          instructionBefore(target, value) {
            var child, i2, removed;
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          }
          // Creates a processing instruction node after the current node
          // `target` instruction target
          // `value` instruction value
          instructionAfter(target, value) {
            var child, i2, removed;
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2 + 1);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          }
          // Creates the xml declaration
          // `version` A version number string, e.g. 1.0
          // `encoding` Encoding declaration, e.g. UTF-8
          // `standalone` standalone document declaration: true or false
          declaration(version, encoding, standalone) {
            var doc, xmldec;
            doc = this.document();
            xmldec = new XMLDeclaration(doc, version, encoding, standalone);
            if (doc.children.length === 0) {
              doc.children.unshift(xmldec);
            } else if (doc.children[0].type === NodeType.Declaration) {
              doc.children[0] = xmldec;
            } else {
              doc.children.unshift(xmldec);
            }
            return doc.root() || doc;
          }
          // Creates the document type declaration
          // `pubID` the public identifier of the external subset
          // `sysID` the system identifier of the external subset
          dtd(pubID, sysID) {
            var child, doc, doctype, i2, j, k, len, len1, ref1, ref2;
            doc = this.document();
            doctype = new XMLDocType(doc, pubID, sysID);
            ref1 = doc.children;
            for (i2 = j = 0, len = ref1.length; j < len; i2 = ++j) {
              child = ref1[i2];
              if (child.type === NodeType.DocType) {
                doc.children[i2] = doctype;
                return doctype;
              }
            }
            ref2 = doc.children;
            for (i2 = k = 0, len1 = ref2.length; k < len1; i2 = ++k) {
              child = ref2[i2];
              if (child.isRoot) {
                doc.children.splice(i2, 0, doctype);
                return doctype;
              }
            }
            doc.children.push(doctype);
            return doctype;
          }
          // Gets the parent node
          up() {
            if (this.isRoot) {
              throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            }
            return this.parent;
          }
          // Gets the root node
          root() {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType.Document) {
                return node.rootObject;
              } else if (node.isRoot) {
                return node;
              } else {
                node = node.parent;
              }
            }
          }
          // Gets the node representing the XML document
          document() {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType.Document) {
                return node;
              } else {
                node = node.parent;
              }
            }
          }
          // Ends the document and converts string
          end(options) {
            return this.document().end(options);
          }
          // Gets the previous node
          prev() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            if (i2 < 1) {
              throw new Error("Already at the first node. " + this.debugInfo());
            }
            return this.parent.children[i2 - 1];
          }
          // Gets the next node
          next() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            if (i2 === -1 || i2 === this.parent.children.length - 1) {
              throw new Error("Already at the last node. " + this.debugInfo());
            }
            return this.parent.children[i2 + 1];
          }
          // Imports cloned root from another XML document
          // `doc` the XML document to insert nodes from
          importDocument(doc) {
            var child, clonedRoot, j, len, ref1;
            clonedRoot = doc.root().clone();
            clonedRoot.parent = this;
            clonedRoot.isRoot = false;
            this.children.push(clonedRoot);
            if (this.type === NodeType.Document) {
              clonedRoot.isRoot = true;
              clonedRoot.documentObject = this;
              this.rootObject = clonedRoot;
              if (this.children) {
                ref1 = this.children;
                for (j = 0, len = ref1.length; j < len; j++) {
                  child = ref1[j];
                  if (child.type === NodeType.DocType) {
                    child.name = clonedRoot.name;
                    break;
                  }
                }
              }
            }
            return this;
          }
          // Returns debug string for this node
          debugInfo(name) {
            var ref1, ref2;
            name = name || this.name;
            if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {
              return "";
            } else if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {
              return "node: <" + name + ">";
            } else {
              return "node: <" + name + ">, parent: <" + this.parent.name + ">";
            }
          }
          // Aliases
          ele(name, attributes, text) {
            return this.element(name, attributes, text);
          }
          nod(name, attributes, text) {
            return this.node(name, attributes, text);
          }
          txt(value) {
            return this.text(value);
          }
          dat(value) {
            return this.cdata(value);
          }
          com(value) {
            return this.comment(value);
          }
          ins(target, value) {
            return this.instruction(target, value);
          }
          doc() {
            return this.document();
          }
          dec(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
          }
          e(name, attributes, text) {
            return this.element(name, attributes, text);
          }
          n(name, attributes, text) {
            return this.node(name, attributes, text);
          }
          t(value) {
            return this.text(value);
          }
          d(value) {
            return this.cdata(value);
          }
          c(value) {
            return this.comment(value);
          }
          r(value) {
            return this.raw(value);
          }
          i(target, value) {
            return this.instruction(target, value);
          }
          u() {
            return this.up();
          }
          // can be deprecated in a future release
          importXMLBuilder(doc) {
            return this.importDocument(doc);
          }
          // Adds or modifies an attribute.
          // `name` attribute name
          // `value` attribute value
          attribute(name, value) {
            throw new Error("attribute() applies to element nodes only.");
          }
          att(name, value) {
            return this.attribute(name, value);
          }
          a(name, value) {
            return this.attribute(name, value);
          }
          // Removes an attribute
          // `name` attribute name
          removeAttribute(name) {
            throw new Error("attribute() applies to element nodes only.");
          }
          // DOM level 1 functions to be implemented later
          replaceChild(newChild, oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          removeChild(oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          appendChild(newChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          hasChildNodes() {
            return this.children.length !== 0;
          }
          cloneNode(deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          normalize() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          // DOM level 2
          isSupported(feature, version) {
            return true;
          }
          hasAttributes() {
            return this.attribs.length !== 0;
          }
          // DOM level 3 functions to be implemented later
          compareDocumentPosition(other) {
            var ref, res;
            ref = this;
            if (ref === other) {
              return 0;
            } else if (this.document() !== other.document()) {
              res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
              if (Math.random() < 0.5) {
                res |= DocumentPosition.Preceding;
              } else {
                res |= DocumentPosition.Following;
              }
              return res;
            } else if (ref.isAncestor(other)) {
              return DocumentPosition.Contains | DocumentPosition.Preceding;
            } else if (ref.isDescendant(other)) {
              return DocumentPosition.Contains | DocumentPosition.Following;
            } else if (ref.isPreceding(other)) {
              return DocumentPosition.Preceding;
            } else {
              return DocumentPosition.Following;
            }
          }
          isSameNode(other) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          lookupPrefix(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          isDefaultNamespace(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          lookupNamespaceURI(prefix) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          isEqualNode(node) {
            var i2, j, ref1;
            if (node.nodeType !== this.nodeType) {
              return false;
            }
            if (node.children.length !== this.children.length) {
              return false;
            }
            for (i2 = j = 0, ref1 = this.children.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i2 = 0 <= ref1 ? ++j : --j) {
              if (!this.children[i2].isEqualNode(node.children[i2])) {
                return false;
              }
            }
            return true;
          }
          getFeature(feature, version) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          setUserData(key3, data, handler) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getUserData(key3) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          // Returns true if other is an inclusive descendant of node,
          // and false otherwise.
          contains(other) {
            if (!other) {
              return false;
            }
            return other === this || this.isDescendant(other);
          }
          // An object A is called a descendant of an object B, if either A is 
          // a child of B or A is a child of an object C that is a descendant of B.
          isDescendant(node) {
            var child, isDescendantChild, j, len, ref1;
            ref1 = this.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              if (node === child) {
                return true;
              }
              isDescendantChild = child.isDescendant(node);
              if (isDescendantChild) {
                return true;
              }
            }
            return false;
          }
          // An object A is called an ancestor of an object B if and only if
          // B is a descendant of A.
          isAncestor(node) {
            return node.isDescendant(this);
          }
          // An object A is preceding an object B if A and B are in the 
          // same tree and A comes before B in tree order.
          isPreceding(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos < thisPos;
            }
          }
          // An object A is folllowing an object B if A and B are in the 
          // same tree and A comes after B in tree order.
          isFollowing(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos > thisPos;
            }
          }
          // Returns the preorder position of the given node in the tree, or -1
          // if the node is not in the tree.
          treePosition(node) {
            var found, pos2;
            pos2 = 0;
            found = false;
            this.foreachTreeNode(this.document(), function(childNode) {
              pos2++;
              if (!found && childNode === node) {
                return found = true;
              }
            });
            if (found) {
              return pos2;
            } else {
              return -1;
            }
          }
          // Depth-first preorder traversal through the XML tree
          foreachTreeNode(node, func) {
            var child, j, len, ref1, res;
            node || (node = this.document());
            ref1 = node.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              if (res = func(child)) {
                return res;
              } else {
                res = this.foreachTreeNode(child, func);
                if (res) {
                  return res;
                }
              }
            }
          }
        }
        ;
        Object.defineProperty(XMLNode2.prototype, "nodeName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeValue", {
          get: function() {
            return this.value;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "parentNode", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "childNodes", {
          get: function() {
            if (!this.childNodeList || !this.childNodeList.nodes) {
              this.childNodeList = new XMLNodeList(this.children);
            }
            return this.childNodeList;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "firstChild", {
          get: function() {
            return this.children[0] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "lastChild", {
          get: function() {
            return this.children[this.children.length - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "previousSibling", {
          get: function() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            return this.parent.children[i2 - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nextSibling", {
          get: function() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            return this.parent.children[i2 + 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
          get: function() {
            return this.document() || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "textContent", {
          get: function() {
            var child, j, len, ref1, str;
            if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
              str = "";
              ref1 = this.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                if (child.textContent) {
                  str += child.textContent;
                }
              }
              return str;
            } else {
              return null;
            }
          },
          set: function(value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        return XMLNode2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLStringifier.js"(exports2, module2) {
    "use strict";
    (function() {
      var XMLStringifier, hasProp = {}.hasOwnProperty;
      module2.exports = XMLStringifier = function() {
        class XMLStringifier2 {
          // Initializes a new instance of `XMLStringifier`
          // `options.version` The version number string of the XML spec to validate against, e.g. 1.0
          // `options.noDoubleEncoding` whether existing html entities are encoded: true or false
          // `options.stringify` a set of functions to use for converting values to strings
          // `options.noValidation` whether values will be validated and escaped or returned as is
          // `options.invalidCharReplacement` a character to replace invalid characters and disable character validation
          constructor(options) {
            var key3, ref, value;
            this.assertLegalChar = this.assertLegalChar.bind(this);
            this.assertLegalName = this.assertLegalName.bind(this);
            options || (options = {});
            this.options = options;
            if (!this.options.version) {
              this.options.version = "1.0";
            }
            ref = options.stringify || {};
            for (key3 in ref) {
              if (!hasProp.call(ref, key3)) continue;
              value = ref[key3];
              this[key3] = value;
            }
          }
          // Defaults
          name(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalName("" + val || "");
          }
          text(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.textEscape("" + val || ""));
          }
          cdata(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            val = val.replace("]]>", "]]]]><![CDATA[>");
            return this.assertLegalChar(val);
          }
          comment(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/--/)) {
              throw new Error("Comment text cannot contain double-hypen: " + val);
            }
            return this.assertLegalChar(val);
          }
          raw(val) {
            if (this.options.noValidation) {
              return val;
            }
            return "" + val || "";
          }
          attValue(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.attEscape(val = "" + val || ""));
          }
          insTarget(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }
          insValue(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/\?>/)) {
              throw new Error("Invalid processing instruction value: " + val);
            }
            return this.assertLegalChar(val);
          }
          xmlVersion(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/1\.[0-9]+/)) {
              throw new Error("Invalid version number: " + val);
            }
            return val;
          }
          xmlEncoding(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
              throw new Error("Invalid encoding: " + val);
            }
            return this.assertLegalChar(val);
          }
          xmlStandalone(val) {
            if (this.options.noValidation) {
              return val;
            }
            if (val) {
              return "yes";
            } else {
              return "no";
            }
          }
          dtdPubID(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }
          dtdSysID(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }
          dtdElementValue(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }
          dtdAttType(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }
          dtdAttDefault(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }
          dtdEntityValue(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }
          dtdNData(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          }
          assertLegalChar(str) {
            var regex, res;
            if (this.options.noValidation) {
              return str;
            }
            if (this.options.version === "1.0") {
              regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g;
              if (this.options.invalidCharReplacement !== void 0) {
                str = str.replace(regex, this.options.invalidCharReplacement);
              } else if (res = str.match(regex)) {
                throw new Error(`Invalid character in string: ${str} at index ${res.index}`);
              }
            } else if (this.options.version === "1.1") {
              regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g;
              if (this.options.invalidCharReplacement !== void 0) {
                str = str.replace(regex, this.options.invalidCharReplacement);
              } else if (res = str.match(regex)) {
                throw new Error(`Invalid character in string: ${str} at index ${res.index}`);
              }
            }
            return str;
          }
          assertLegalName(str) {
            var regex;
            if (this.options.noValidation) {
              return str;
            }
            str = this.assertLegalChar(str);
            regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
            if (!str.match(regex)) {
              throw new Error(`Invalid character in name: ${str}`);
            }
            return str;
          }
          // Escapes special characters in text
          // See http://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping
          // `str` the string to escape
          textEscape(str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding ? /(?!&(lt|gt|amp|apos|quot);)&/g : /&/g;
            return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
          }
          // Escapes special characters in attribute values
          // See http://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping
          // `str` the string to escape
          attEscape(str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding ? /(?!&(lt|gt|amp|apos|quot);)&/g : /&/g;
            return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
          }
        }
        ;
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        return XMLStringifier2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/WriterState.js"(exports2, module2) {
    "use strict";
    (function() {
      module2.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
      ({ assign } = require_Utility());
      NodeType = require_NodeType();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      WriterState = require_WriterState();
      module2.exports = XMLWriterBase = class XMLWriterBase {
        // Initializes a new instance of `XMLWriterBase`
        // `options.pretty` pretty prints the result
        // `options.indent` indentation string
        // `options.newline` newline sequence
        // `options.offset` a fixed number of indentations to add to every line
        // `options.width` maximum column width
        // `options.allowEmpty` do not self close empty element tags
        // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
        // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
        constructor(options) {
          var key3, ref, value;
          options || (options = {});
          this.options = options;
          ref = options.writer || {};
          for (key3 in ref) {
            if (!hasProp.call(ref, key3)) continue;
            value = ref[key3];
            this["_" + key3] = this[key3];
            this[key3] = value;
          }
        }
        // Filters writer options and provides defaults
        // `options` writer options
        filterOptions(options) {
          var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
          options || (options = {});
          options = assign({}, this.options, options);
          filteredOptions = {
            writer: this
          };
          filteredOptions.pretty = options.pretty || false;
          filteredOptions.allowEmpty = options.allowEmpty || false;
          filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
          filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
          filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
          filteredOptions.width = (ref3 = options.width) != null ? ref3 : 0;
          filteredOptions.dontPrettyTextNodes = (ref4 = (ref5 = options.dontPrettyTextNodes) != null ? ref5 : options.dontprettytextnodes) != null ? ref4 : 0;
          filteredOptions.spaceBeforeSlash = (ref6 = (ref7 = options.spaceBeforeSlash) != null ? ref7 : options.spacebeforeslash) != null ? ref6 : "";
          if (filteredOptions.spaceBeforeSlash === true) {
            filteredOptions.spaceBeforeSlash = " ";
          }
          filteredOptions.suppressPrettyCount = 0;
          filteredOptions.user = {};
          filteredOptions.state = WriterState.None;
          return filteredOptions;
        }
        // Returns the indentation string for the current level
        // `node` current node
        // `options` writer options
        // `level` current indentation level
        indent(node, options, level) {
          var indentLevel;
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else if (options.pretty) {
            indentLevel = (level || 0) + options.offset + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options.indent);
            }
          }
          return "";
        }
        // Returns the newline string
        // `node` current node
        // `options` writer options
        // `level` current indentation level
        endline(node, options, level) {
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else {
            return options.newline;
          }
        }
        attribute(att, options, level) {
          var r;
          this.openAttribute(att, options, level);
          if (options.pretty && options.width > 0) {
            r = att.name + '="' + att.value + '"';
          } else {
            r = " " + att.name + '="' + att.value + '"';
          }
          this.closeAttribute(att, options, level);
          return r;
        }
        cdata(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<![CDATA[";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += "]]>" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        comment(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!-- ";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += " -->" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        declaration(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?xml";
          options.state = WriterState.InsideTag;
          r += ' version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        docType(node, options, level) {
          var child, i2, len1, r, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          r += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r += " [";
            r += this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (i2 = 0, len1 = ref.length; i2 < len1; i2++) {
              child = ref[i2];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += "]";
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        element(node, options, level) {
          var att, attLen, child, childNodeCount, firstChildNode, i2, j, len, len1, len2, name, prettySuppressed, r, ratt, ref, ref1, ref2, ref3, rline;
          level || (level = 0);
          prettySuppressed = false;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<" + node.name;
          if (options.pretty && options.width > 0) {
            len = r.length;
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name)) continue;
              att = ref[name];
              ratt = this.attribute(att, options, level);
              attLen = ratt.length;
              if (len + attLen > options.width) {
                rline = this.indent(node, options, level + 1) + ratt;
                r += this.endline(node, options, level) + rline;
                len = rline.length;
              } else {
                rline = " " + ratt;
                r += rline;
                len += rline.length;
              }
            }
          } else {
            ref1 = node.attribs;
            for (name in ref1) {
              if (!hasProp.call(ref1, name)) continue;
              att = ref1[name];
              r += this.attribute(att, options, level);
            }
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw || e.type === NodeType.CData) && e.value === "";
          })) {
            if (options.allowEmpty) {
              r += ">";
              options.state = WriterState.CloseTag;
              r += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw || firstChildNode.type === NodeType.CData) && firstChildNode.value != null) {
            r += ">";
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            r += this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            if (options.dontPrettyTextNodes) {
              ref2 = node.children;
              for (i2 = 0, len1 = ref2.length; i2 < len1; i2++) {
                child = ref2[i2];
                if ((child.type === NodeType.Text || child.type === NodeType.Raw || child.type === NodeType.CData) && child.value != null) {
                  options.suppressPrettyCount++;
                  prettySuppressed = true;
                  break;
                }
              }
            }
            r += ">" + this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref3 = node.children;
            for (j = 0, len2 = ref3.length; j < len2; j++) {
              child = ref3[j];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += this.indent(node, options, level) + "</" + node.name + ">";
            if (prettySuppressed) {
              options.suppressPrettyCount--;
            }
            r += this.endline(node, options, level);
            options.state = WriterState.None;
          }
          this.closeNode(node, options, level);
          return r;
        }
        writeChildNode(node, options, level) {
          switch (node.type) {
            case NodeType.CData:
              return this.cdata(node, options, level);
            case NodeType.Comment:
              return this.comment(node, options, level);
            case NodeType.Element:
              return this.element(node, options, level);
            case NodeType.Raw:
              return this.raw(node, options, level);
            case NodeType.Text:
              return this.text(node, options, level);
            case NodeType.ProcessingInstruction:
              return this.processingInstruction(node, options, level);
            case NodeType.Dummy:
              return "";
            case NodeType.Declaration:
              return this.declaration(node, options, level);
            case NodeType.DocType:
              return this.docType(node, options, level);
            case NodeType.AttributeDeclaration:
              return this.dtdAttList(node, options, level);
            case NodeType.ElementDeclaration:
              return this.dtdElement(node, options, level);
            case NodeType.EntityDeclaration:
              return this.dtdEntity(node, options, level);
            case NodeType.NotationDeclaration:
              return this.dtdNotation(node, options, level);
            default:
              throw new Error("Unknown XML node type: " + node.constructor.name);
          }
        }
        processingInstruction(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?";
          options.state = WriterState.InsideTag;
          r += node.target;
          if (node.value) {
            r += " " + node.value;
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        raw(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        text(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        dtdAttList(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ATTLIST";
          options.state = WriterState.InsideTag;
          r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        dtdElement(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ELEMENT";
          options.state = WriterState.InsideTag;
          r += " " + node.name + " " + node.value;
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        dtdEntity(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ENTITY";
          options.state = WriterState.InsideTag;
          if (node.pe) {
            r += " %";
          }
          r += " " + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += " NDATA " + node.nData;
            }
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        dtdNotation(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!NOTATION";
          options.state = WriterState.InsideTag;
          r += " " + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        }
        openNode(node, options, level) {
        }
        closeNode(node, options, level) {
        }
        openAttribute(att, options, level) {
        }
        closeAttribute(att, options, level) {
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports2, module2) {
    "use strict";
    (function() {
      var XMLStringWriter, XMLWriterBase;
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStringWriter = class XMLStringWriter extends XMLWriterBase {
        // Initializes a new instance of `XMLStringWriter`
        // `options.pretty` pretty prints the result
        // `options.indent` indentation string
        // `options.newline` newline sequence
        // `options.offset` a fixed number of indentations to add to every line
        // `options.allowEmpty` do not self close empty element tags
        // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
        // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
        constructor(options) {
          super(options);
        }
        document(doc, options) {
          var child, i2, len, r, ref;
          options = this.filterOptions(options);
          r = "";
          ref = doc.children;
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            child = ref[i2];
            r += this.writeChildNode(child, options, 0);
          }
          if (options.pretty && r.slice(-options.newline.length) === options.newline) {
            r = r.slice(0, -options.newline.length);
          }
          return r;
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDocument.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject;
      ({ isPlainObject } = require_Utility());
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDOMConfiguration = require_XMLDOMConfiguration();
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocument = function() {
        class XMLDocument2 extends XMLNode {
          // Initializes a new instance of `XMLDocument`
          // `options.keepNullNodes` whether nodes with null values will be kept
          //     or ignored: true or false
          // `options.keepNullAttributes` whether attributes with null values will be
          //     kept or ignored: true or false
          // `options.ignoreDecorators` whether decorator strings will be ignored when
          //     converting JS objects: true or false
          // `options.separateArrayItems` whether array items are created as separate
          //     nodes when passed as an object value: true or false
          // `options.noDoubleEncoding` whether existing html entities are encoded:
          //     true or false
          // `options.stringify` a set of functions to use for converting values to
          //     strings
          // `options.writer` the default XML writer to use for converting nodes to
          //     string. If the default writer is not set, the built-in XMLStringWriter
          //     will be used instead.
          constructor(options) {
            super(null);
            this.name = "#document";
            this.type = NodeType.Document;
            this.documentURI = null;
            this.domConfig = new XMLDOMConfiguration();
            options || (options = {});
            if (!options.writer) {
              options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.stringify = new XMLStringifier(options);
          }
          // Ends the document and passes it to the given XML writer
          // `writer` is either an XML writer or a plain object to pass to the
          // constructor of the default XML writer. The default writer is assigned when
          // creating the XML document. Following flags are recognized by the
          // built-in XMLStringWriter:
          //   `writer.pretty` pretty prints the result
          //   `writer.indent` indentation for pretty print
          //   `writer.offset` how many indentations to add to every line for pretty print
          //   `writer.newline` newline sequence for pretty print
          end(writer) {
            var writerOptions;
            writerOptions = {};
            if (!writer) {
              writer = this.options.writer;
            } else if (isPlainObject(writer)) {
              writerOptions = writer;
              writer = this.options.writer;
            }
            return writer.document(this, writer.filterOptions(writerOptions));
          }
          // Converts the XML document to string
          // `options.pretty` pretty prints the result
          // `options.indent` indentation for pretty print
          // `options.offset` how many indentations to add to every line for pretty print
          // `options.newline` newline sequence for pretty print
          toString(options) {
            return this.options.writer.document(this, this.options.writer.filterOptions(options));
          }
          // DOM level 1 functions to be implemented later
          createElement(tagName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createDocumentFragment() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createTextNode(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createComment(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createCDATASection(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createProcessingInstruction(target, data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createAttribute(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createEntityReference(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getElementsByTagName(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          // DOM level 2 functions to be implemented later
          importNode(importedNode, deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createElementNS(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createAttributeNS(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getElementsByTagNameNS(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          getElementById(elementId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          // DOM level 3 functions to be implemented later
          adoptNode(source2) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          normalizeDocument() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          renameNode(node, namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          // DOM level 4 functions to be implemented later
          getElementsByClassName(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createEvent(eventInterface) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createRange() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createNodeIterator(root2, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
          createTreeWalker(root2, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        }
        ;
        Object.defineProperty(XMLDocument2.prototype, "implementation", {
          value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument2.prototype, "doctype", {
          get: function() {
            var child, i2, len, ref;
            ref = this.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.DocType) {
                return child;
              }
            }
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "documentElement", {
          get: function() {
            return this.rootObject || null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
          get: function() {
            return false;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].encoding;
            } else {
              return null;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].standalone === "yes";
            } else {
              return false;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].version;
            } else {
              return "1.0";
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "URL", {
          get: function() {
            return this.documentURI;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "origin", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "compatMode", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "characterSet", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "contentType", {
          get: function() {
            return null;
          }
        });
        return XMLDocument2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, hasProp = {}.hasOwnProperty;
      ({ isObject, isFunction, isPlainObject, getValue } = require_Utility());
      NodeType = require_NodeType();
      XMLDocument = require_XMLDocument();
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      WriterState = require_WriterState();
      module2.exports = XMLDocumentCB = class XMLDocumentCB {
        // Initializes a new instance of `XMLDocumentCB`
        // `options.keepNullNodes` whether nodes with null values will be kept
        //     or ignored: true or false
        // `options.keepNullAttributes` whether attributes with null values will be
        //     kept or ignored: true or false
        // `options.ignoreDecorators` whether decorator strings will be ignored when
        //     converting JS objects: true or false
        // `options.separateArrayItems` whether array items are created as separate
        //     nodes when passed as an object value: true or false
        // `options.noDoubleEncoding` whether existing html entities are encoded:
        //     true or false
        // `options.stringify` a set of functions to use for converting values to
        //     strings
        // `options.writer` the default XML writer to use for converting nodes to
        //     string. If the default writer is not set, the built-in XMLStringWriter
        //     will be used instead.
        // `onData` the function to be called when a new chunk of XML is output. The
        //          string containing the XML chunk is passed to `onData` as its first
        //          argument, and the current indentation level as its second argument.
        // `onEnd`  the function to be called when the XML document is completed with
        //          `end`. `onEnd` does not receive any arguments.
        constructor(options, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          this.type = NodeType.Document;
          options || (options = {});
          writerOptions = {};
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.writer = options.writer;
          this.writerOptions = this.writer.filterOptions(writerOptions);
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        // Creates a child element node from the given XMLNode
        // `node` the child node
        createChildNode(node) {
          var att, attName, attributes, child, i2, len, ref, ref1;
          switch (node.type) {
            case NodeType.CData:
              this.cdata(node.value);
              break;
            case NodeType.Comment:
              this.comment(node.value);
              break;
            case NodeType.Element:
              attributes = {};
              ref = node.attribs;
              for (attName in ref) {
                if (!hasProp.call(ref, attName)) continue;
                att = ref[attName];
                attributes[attName] = att.value;
              }
              this.node(node.name, attributes);
              break;
            case NodeType.Dummy:
              this.dummy();
              break;
            case NodeType.Raw:
              this.raw(node.value);
              break;
            case NodeType.Text:
              this.text(node.value);
              break;
            case NodeType.ProcessingInstruction:
              this.instruction(node.target, node.value);
              break;
            default:
              throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
          }
          ref1 = node.children;
          for (i2 = 0, len = ref1.length; i2 < len; i2++) {
            child = ref1[i2];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
          return this;
        }
        // Creates a dummy node
        dummy() {
          return this;
        }
        // Creates a node
        // `name` name of the node
        // `attributes` an object containing name/value pairs of attributes
        // `text` element text
        node(name, attributes, text) {
          if (name == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node. " + this.debugInfo(name));
          }
          this.openCurrent();
          name = getValue(name);
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            [text, attributes] = [attributes, text];
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        }
        // Creates a child element node or an element type declaration when called
        // inside the DTD
        // `name` name of the node
        // `attributes` an object containing name/value pairs of attributes
        // `text` element text
        element(name, attributes, text) {
          var child, i2, len, oldValidationFlag, ref, root2;
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            this.dtdElement(...arguments);
          } else {
            if (Array.isArray(name) || isObject(name) || isFunction(name)) {
              oldValidationFlag = this.options.noValidation;
              this.options.noValidation = true;
              root2 = new XMLDocument(this.options).element("TEMP_ROOT");
              root2.element(name);
              this.options.noValidation = oldValidationFlag;
              ref = root2.children;
              for (i2 = 0, len = ref.length; i2 < len; i2++) {
                child = ref[i2];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
            } else {
              this.node(name, attributes, text);
            }
          }
          return this;
        }
        // Adds or modifies an attribute
        // `name` attribute name
        // `value` attribute value
        attribute(name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
          }
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName)) continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value != null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        }
        // Creates a text node
        // `value` element text
        text(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Creates a CDATA node
        // `value` element text without CDATA delimiters
        cdata(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Creates a comment node
        // `value` comment text
        comment(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Adds unescaped raw text
        // `value` text
        raw(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Adds a processing instruction
        // `target` instruction target
        // `value` instruction value
        instruction(target, value) {
          var i2, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (i2 = 0, len = target.length; i2 < len; i2++) {
              insTarget = target[i2];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          }
          return this;
        }
        // Creates the xml declaration
        // `version` A version number string, e.g. 1.0
        // `encoding` Encoding declaration, e.g. UTF-8
        // `standalone` standalone document declaration: true or false
        declaration(version, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version, encoding, standalone);
          this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Creates the document type declaration
        // `root`  the name of the root node
        // `pubID` the public identifier of the external subset
        // `sysID` the system identifier of the external subset
        doctype(root2, pubID, sysID) {
          this.openCurrent();
          if (root2 == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root2;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        }
        // Creates an element type declaration
        // `name` element name
        // `value` element content (defaults to #PCDATA)
        dtdElement(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Creates an attribute declaration
        // `elementName` the name of the element containing this attribute
        // `attributeName` attribute name
        // `attributeType` type of the attribute (defaults to CDATA)
        // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or
        //                    #DEFAULT) (defaults to #IMPLIED)
        // `defaultValue` default value of the attribute
        //                (only used for #FIXED or #DEFAULT)
        attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Creates a general entity declaration
        // `name` the name of the entity
        // `value` internal entity value or an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        // `value.nData` notation declaration
        entity(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Creates a parameter entity declaration
        // `name` the name of the entity
        // `value` internal entity value or an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        pEntity(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Creates a NOTATION declaration
        // `name` the name of the notation
        // `value` an object with external entity details
        // `value.pubID` public identifier
        // `value.sysID` system identifier
        notation(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }
        // Gets the parent node
        up() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        }
        // Ends the document
        end() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        }
        // Opens the current parent node
        openCurrent() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        }
        // Writes the opening tag of the current node or the entire node if it has
        // no child nodes
        openNode(node) {
          var att, chunk, name, ref;
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
              this.root = node;
            }
            chunk = "";
            if (node.type === NodeType.Element) {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
              ref = node.attribs;
              for (name in ref) {
                if (!hasProp.call(ref, name)) continue;
                att = ref[name];
                chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
              }
              chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
              if (node.pubID && node.sysID) {
                chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                chunk += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children) {
                chunk += " [";
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.CloseTag;
                chunk += ">";
              }
              chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.onData(chunk, this.currentLevel);
            return node.isOpen = true;
          }
        }
        // Writes the closing tag of the current node
        closeNode(node) {
          var chunk;
          if (!node.isClosed) {
            chunk = "";
            this.writerOptions.state = WriterState.CloseTag;
            if (node.type === NodeType.Element) {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            } else {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.writerOptions.state = WriterState.None;
            this.onData(chunk, this.currentLevel);
            return node.isClosed = true;
          }
        }
        // Called when a new chunk of XML is output
        // `chunk` a string containing the XML chunk
        // `level` current indentation level
        onData(chunk, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk, level + 1);
        }
        // Called when the XML document is completed
        onEnd() {
          this.documentCompleted = true;
          return this.onEndCallback();
        }
        // Returns debug string
        debugInfo(name) {
          if (name == null) {
            return "";
          } else {
            return "node: <" + name + ">";
          }
        }
        // Node aliases
        ele() {
          return this.element(...arguments);
        }
        nod(name, attributes, text) {
          return this.node(name, attributes, text);
        }
        txt(value) {
          return this.text(value);
        }
        dat(value) {
          return this.cdata(value);
        }
        com(value) {
          return this.comment(value);
        }
        ins(target, value) {
          return this.instruction(target, value);
        }
        dec(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        }
        dtd(root2, pubID, sysID) {
          return this.doctype(root2, pubID, sysID);
        }
        e(name, attributes, text) {
          return this.element(name, attributes, text);
        }
        n(name, attributes, text) {
          return this.node(name, attributes, text);
        }
        t(value) {
          return this.text(value);
        }
        d(value) {
          return this.cdata(value);
        }
        c(value) {
          return this.comment(value);
        }
        r(value) {
          return this.raw(value);
        }
        i(target, value) {
          return this.instruction(target, value);
        }
        // Attribute aliases
        att() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList(...arguments);
          } else {
            return this.attribute(...arguments);
          }
        }
        a() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList(...arguments);
          } else {
            return this.attribute(...arguments);
          }
        }
        // DTD aliases
        // att() and ele() are defined above
        ent(name, value) {
          return this.entity(name, value);
        }
        pent(name, value) {
          return this.pEntity(name, value);
        }
        not(name, value) {
          return this.notation(name, value);
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLWriterBase = require_XMLWriterBase();
      WriterState = require_WriterState();
      module2.exports = XMLStreamWriter = class XMLStreamWriter extends XMLWriterBase {
        // Initializes a new instance of `XMLStreamWriter`
        // `stream` output stream
        // `options.pretty` pretty prints the result
        // `options.indent` indentation string
        // `options.newline` newline sequence
        // `options.offset` a fixed number of indentations to add to every line
        // `options.allowEmpty` do not self close empty element tags
        // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
        // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
        constructor(stream, options) {
          super(options);
          this.stream = stream;
        }
        endline(node, options, level) {
          if (node.isLastRootNode && options.state === WriterState.CloseTag) {
            return "";
          } else {
            return super.endline(node, options, level);
          }
        }
        document(doc, options) {
          var child, i2, j, k, len1, len2, ref, ref1, results;
          ref = doc.children;
          for (i2 = j = 0, len1 = ref.length; j < len1; i2 = ++j) {
            child = ref[i2];
            child.isLastRootNode = i2 === doc.children.length - 1;
          }
          options = this.filterOptions(options);
          ref1 = doc.children;
          results = [];
          for (k = 0, len2 = ref1.length; k < len2; k++) {
            child = ref1[k];
            results.push(this.writeChildNode(child, options, 0));
          }
          return results;
        }
        cdata(node, options, level) {
          return this.stream.write(super.cdata(node, options, level));
        }
        comment(node, options, level) {
          return this.stream.write(super.comment(node, options, level));
        }
        declaration(node, options, level) {
          return this.stream.write(super.declaration(node, options, level));
        }
        docType(node, options, level) {
          var child, j, len1, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (j = 0, len1 = ref.length; j < len1; j++) {
              child = ref[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write("]");
          }
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + ">");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        }
        element(node, options, level) {
          var att, attLen, child, childNodeCount, firstChildNode, j, len, len1, name, prettySuppressed, r, ratt, ref, ref1, ref2, rline;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<" + node.name;
          if (options.pretty && options.width > 0) {
            len = r.length;
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name)) continue;
              att = ref[name];
              ratt = this.attribute(att, options, level);
              attLen = ratt.length;
              if (len + attLen > options.width) {
                rline = this.indent(node, options, level + 1) + ratt;
                r += this.endline(node, options, level) + rline;
                len = rline.length;
              } else {
                rline = " " + ratt;
                r += rline;
                len += rline.length;
              }
            }
          } else {
            ref1 = node.attribs;
            for (name in ref1) {
              if (!hasProp.call(ref1, name)) continue;
              att = ref1[name];
              r += this.attribute(att, options, level);
            }
          }
          this.stream.write(r);
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw || e.type === NodeType.CData) && e.value === "";
          })) {
            if (options.allowEmpty) {
              this.stream.write(">");
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + "/>");
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw || firstChildNode.type === NodeType.CData) && firstChildNode.value != null) {
            this.stream.write(">");
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
          }
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        }
        processingInstruction(node, options, level) {
          return this.stream.write(super.processingInstruction(node, options, level));
        }
        raw(node, options, level) {
          return this.stream.write(super.raw(node, options, level));
        }
        text(node, options, level) {
          return this.stream.write(super.text(node, options, level));
        }
        dtdAttList(node, options, level) {
          return this.stream.write(super.dtdAttList(node, options, level));
        }
        dtdElement(node, options, level) {
          return this.stream.write(super.dtdElement(node, options, level));
        }
        dtdEntity(node, options, level) {
          return this.stream.write(super.dtdEntity(node, options, level));
        }
        dtdNotation(node, options, level) {
          return this.stream.write(super.dtdNotation(node, options, level));
        }
      };
    }).call(exports2);
  }
});

// node_modules/@expo/plist/node_modules/xmlbuilder/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@expo/plist/node_modules/xmlbuilder/lib/index.js"(exports2, module2) {
    "use strict";
    (function() {
      var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction;
      ({ assign, isFunction } = require_Utility());
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      NodeType = require_NodeType();
      WriterState = require_WriterState();
      module2.exports.create = function(name, xmldec, doctype, options) {
        var doc, root2;
        if (name == null) {
          throw new Error("Root element needs a name.");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root2 = doc.element(name);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.dtd(options);
          }
        }
        return root2;
      };
      module2.exports.begin = function(options, onData, onEnd) {
        if (isFunction(options)) {
          [onData, onEnd] = [options, onData];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module2.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module2.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
      };
      module2.exports.implementation = new XMLDOMImplementation();
      module2.exports.nodeType = NodeType;
      module2.exports.writerState = WriterState;
    }).call(exports2);
  }
});

// node_modules/@expo/plist/build/build.js
var require_build2 = __commonJS({
  "node_modules/@expo/plist/build/build.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.build = build;
    var base64_js_1 = __importDefault(require_base64_js());
    var xmlbuilder_1 = __importDefault(require_lib4());
    function ISODateString(d) {
      function pad(n) {
        return n < 10 ? "0" + n : n;
      }
      return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "Z";
    }
    var toString = Object.prototype.toString;
    function type(obj) {
      const m = toString.call(obj).match(/\[object (.*)\]/);
      return m ? m[1] : m;
    }
    function build(obj, opts) {
      const XMLHDR = {
        version: "1.0",
        encoding: "UTF-8"
      };
      const XMLDTD = {
        pubid: "-//Apple//DTD PLIST 1.0//EN",
        sysid: "http://www.apple.com/DTDs/PropertyList-1.0.dtd"
      };
      const doc = xmlbuilder_1.default.create("plist");
      doc.dec(XMLHDR.version, XMLHDR.encoding, XMLHDR.standalone);
      doc.dtd(XMLDTD.pubid, XMLDTD.sysid);
      doc.att("version", "1.0");
      walk_obj(obj, doc);
      if (!opts)
        opts = {};
      opts.pretty = opts.pretty !== false;
      return doc.end(opts);
    }
    function walk_obj(next, next_child) {
      let tag_type, i2, prop;
      const name = type(next);
      if (name === "Undefined") {
      } else if (Array.isArray(next)) {
        next_child = next_child.ele("array");
        for (i2 = 0; i2 < next.length; i2++) {
          walk_obj(next[i2], next_child);
        }
      } else if (Buffer.isBuffer(next)) {
        next_child.ele("data").raw(next.toString("base64"));
      } else if (name === "Object") {
        next_child = next_child.ele("dict");
        for (prop in next) {
          if (next.hasOwnProperty(prop) && next[prop] !== void 0) {
            next_child.ele("key").txt(prop);
            walk_obj(next[prop], next_child);
          }
        }
      } else if (name === "Number") {
        tag_type = next % 1 === 0 ? "integer" : "real";
        next_child.ele(tag_type).txt(next.toString());
      } else if (name === "Date") {
        next_child.ele("date").txt(ISODateString(new Date(next)));
      } else if (name === "Boolean") {
        next_child.ele(next ? "true" : "false");
      } else if (name === "String") {
        next_child.ele("string").txt(next);
      } else if (name === "ArrayBuffer") {
        next_child.ele("data").raw(base64_js_1.default.fromByteArray(next));
      } else if (next && next.buffer && type(next.buffer) === "ArrayBuffer") {
        next_child.ele("data").raw(base64_js_1.default.fromByteArray(new Uint8Array(next.buffer)));
      }
    }
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports2) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i2 = 0; i2 < list.length; i2++) {
        if (Object.prototype.hasOwnProperty.call(list, i2)) {
          var item = list[i2];
          if (predicate.call(void 0, item, i2, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source2) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key3 in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key3)) {
          target[key3] = source2[key3];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports2.assign = assign;
    exports2.find = find;
    exports2.freeze = freeze;
    exports2.MIME_TYPE = MIME_TYPE;
    exports2.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports2) {
    "use strict";
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t2 = function() {
        };
        var t = t2;
        ;
        t2.prototype = Super.prototype;
        t2 = new t2();
        copy(pt, t2);
        Class.prototype = pt = t2;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i2 = 0; i2 < this.length; i2++) {
          serializeToString(this[i2], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i2 = ls.length; i2 in list; i2++) {
            if (Object.prototype.hasOwnProperty.call(list, i2)) {
              delete list[i2];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i2) {
      _updateLiveList(this);
      return this[i2] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i2 = list.length;
      while (i2--) {
        if (list[i2] === node) {
          return i2;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i2 = _findNodeIndex(list, attr);
      if (i2 >= 0) {
        var lastIndex = list.length - 1;
        while (i2 < lastIndex) {
          list[i2] = list[++i2];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key3) {
        var i2 = this.length;
        while (i2--) {
          var attr = this[i2];
          if (attr.nodeName == key3) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key3) {
        var attr = this.getNamedItem(key3);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i2 = this.length;
        while (i2--) {
          var node = this[i2];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root2 = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root2);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c2) {
      return c2 == "<" && "&lt;" || c2 == ">" && "&gt;" || c2 == "&" && "&amp;" || c2 == '"' && "&quot;" || "&#" + c2.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i2 = 0;
          while (child) {
            cs[i2++] = child;
            child = child.nextSibling;
          }
          cs.length = i2;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i2 = visibleNamespaces.length;
      while (i2--) {
        var ns = visibleNamespaces[i2];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i2 = 0; i2 < len; i2++) {
            var attr = attrs.item(i2);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i2 = 0; i2 < len; i2++) {
            var attr = attrs.item(i2);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        //case ENTITY_NODE:
        //case NOTATION_NODE:
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        //var attrs = node2.attributes;
        //var len = attrs.length;
        //for(var i=0;i<len;i++){
        //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
        //}
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i2 = 0; i2 < len; i2++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i2), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key3, value) {
      object[key3] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key3, value) {
          object["$$" + key3] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports2.DocumentType = DocumentType;
    exports2.DOMException = DOMException;
    exports2.DOMImplementation = DOMImplementation;
    exports2.Element = Element;
    exports2.Node = Node;
    exports2.NodeList = NodeList;
    exports2.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports2) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports2.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports2.HTML_ENTITIES = freeze({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports2.entityMap = exports2.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports2) {
    "use strict";
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source2, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse3(
          source2,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse3(source2, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source2.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source2))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source2.indexOf("<", start);
          if (tagStart < 0) {
            if (!source2.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source2.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source2.charAt(tagStart + 1)) {
            case "/":
              var end = source2.indexOf(">", tagStart + 3);
              var tagName = source2.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source2.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            // end elment
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source2, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source2, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source2, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source2, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i2 = 0; i2 < len; i2++) {
                  var a = el[i2];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source2, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source2, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c2 = source2.charAt(p);
        switch (c2) {
          case "=":
            if (s === S_ATTR) {
              attrName = source2.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source2.slice(start, p);
              }
              start = p + 1;
              p = source2.indexOf(c2, start);
              if (p > 0) {
                value = source2.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c2 + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source2.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c2 + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source2.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              //case S_EQ:
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source2.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source2.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              //normal
              case S_ATTR_NOQUOT_VALUE:
              //Compatible state
              case S_ATTR:
                value = source2.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          /*xml space '\x20' | #x9 | #xD | #xA; */
          case "\x80":
            c2 = " ";
          default:
            if (c2 <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source2.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source2.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source2.slice(start, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                //case S_TAG:void();break;
                //case S_ATTR:void();break;
                //case S_ATTR_NOQUOT_VALUE:void();break;
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i2 = el.length;
      while (i2--) {
        var a = el[i2];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i2 = el.length;
      while (i2--) {
        a = el[i2];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source2, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source2.indexOf("</" + tagName + ">", elStartEnd);
        var text = source2.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source2, elStartEnd, tagName, closeMap) {
      var pos2 = closeMap[tagName];
      if (pos2 == null) {
        pos2 = source2.lastIndexOf("</" + tagName + ">");
        if (pos2 < elStartEnd) {
          pos2 = source2.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos2;
      }
      return pos2 < elStartEnd;
    }
    function _copy(source2, target) {
      for (var n in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, n)) {
          target[n] = source2[n];
        }
      }
    }
    function parseDCC(source2, start, domBuilder, errorHandler) {
      var next = source2.charAt(start + 2);
      switch (next) {
        case "-":
          if (source2.charAt(start + 3) === "-") {
            var end = source2.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source2, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source2.substr(start + 3, 6) == "CDATA[") {
            var end = source2.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source2, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source2, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source2, start, domBuilder) {
      var end = source2.indexOf("?>", start);
      if (end) {
        var match = source2.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i2) {
        return this[i2].localName;
      },
      getLocator: function(i2) {
        return this[i2].locator;
      },
      getQName: function(i2) {
        return this[i2].qName;
      },
      getURI: function(i2) {
        return this[i2].uri;
      },
      getValue: function(i2) {
        return this[i2].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source2, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source2);
      while (match = reg.exec(source2)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports2.XMLReader = XMLReader;
    exports2.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports2) {
    "use strict";
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser(options) {
      this.options = options || { locator: {} };
    }
    DOMParser.prototype.parseFromString = function(source2, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source2 && typeof source2 === "string") {
        sax2.parse(
          normalize(source2),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key3) {
        var fn = errorImpl[key3];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key3, msg);
          } : errorImpl;
        }
        errorHandler[key3] = fn && function(msg) {
          fn("[xmldom " + key3 + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i2 = 0; i2 < len; i2++) {
          var namespaceURI = attrs.getURI(i2);
          var value = attrs.getValue(i2);
          var qName = attrs.getQName(i2);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i2), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key3) {
      DOMHandler.prototype[key3] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports2.__DOMHandler = DOMHandler;
    exports2.normalizeLineEndings = normalizeLineEndings;
    exports2.DOMParser = DOMParser;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports2) {
    "use strict";
    var dom = require_dom();
    exports2.DOMImplementation = dom.DOMImplementation;
    exports2.XMLSerializer = dom.XMLSerializer;
    exports2.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/@expo/plist/build/parse.js
var require_parse2 = __commonJS({
  "node_modules/@expo/plist/build/parse.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = parse3;
    var xmldom_1 = require_lib5();
    var assert_1 = __importDefault(require("assert"));
    var TEXT_NODE = 3;
    var CDATA_NODE = 4;
    var COMMENT_NODE = 8;
    function shouldIgnoreNode(node) {
      return node.nodeType === TEXT_NODE || node.nodeType === COMMENT_NODE || node.nodeType === CDATA_NODE;
    }
    function isEmptyNode(node) {
      return !node.childNodes || node.childNodes.length === 0;
    }
    function parse3(xml) {
      const doc = new xmldom_1.DOMParser({ errorHandler() {
      } }).parseFromString(xml);
      (0, assert_1.default)(doc.documentElement.nodeName === "plist", "malformed document. First element should be <plist>");
      let plist = parsePlistXML(doc.documentElement);
      if (plist.length === 1)
        plist = plist[0];
      return plist;
    }
    function parsePlistXML(node) {
      let i2, new_obj, key3, new_arr, res, counter;
      if (!node)
        return null;
      if (node.nodeName === "plist") {
        new_arr = [];
        if (isEmptyNode(node)) {
          return new_arr;
        }
        for (i2 = 0; i2 < node.childNodes.length; i2++) {
          if (!shouldIgnoreNode(node.childNodes[i2])) {
            new_arr.push(parsePlistXML(node.childNodes[i2]));
          }
        }
        return new_arr;
      } else if (node.nodeName === "dict") {
        new_obj = {};
        key3 = null;
        counter = 0;
        if (isEmptyNode(node)) {
          return new_obj;
        }
        for (i2 = 0; i2 < node.childNodes.length; i2++) {
          if (shouldIgnoreNode(node.childNodes[i2]))
            continue;
          if (counter % 2 === 0) {
            (0, assert_1.default)(node.childNodes[i2].nodeName === "key", "Missing key while parsing <dict/>.");
            key3 = parsePlistXML(node.childNodes[i2]);
          } else {
            (0, assert_1.default)(node.childNodes[i2].nodeName !== "key", 'Unexpected key "' + parsePlistXML(node.childNodes[i2]) + '" while parsing <dict/>.');
            new_obj[key3] = parsePlistXML(node.childNodes[i2]);
          }
          counter += 1;
        }
        if (counter % 2 === 1) {
          throw new Error('Missing value for "' + key3 + '" while parsing <dict/>');
        }
        return new_obj;
      } else if (node.nodeName === "array") {
        new_arr = [];
        if (isEmptyNode(node)) {
          return new_arr;
        }
        for (i2 = 0; i2 < node.childNodes.length; i2++) {
          if (!shouldIgnoreNode(node.childNodes[i2])) {
            res = parsePlistXML(node.childNodes[i2]);
            if (res != null)
              new_arr.push(res);
          }
        }
        return new_arr;
      } else if (node.nodeName === "#text") {
      } else if (node.nodeName === "key") {
        if (isEmptyNode(node)) {
          return "";
        }
        return node.childNodes[0].nodeValue;
      } else if (node.nodeName === "string") {
        res = "";
        if (isEmptyNode(node)) {
          return res;
        }
        for (i2 = 0; i2 < node.childNodes.length; i2++) {
          const type = node.childNodes[i2].nodeType;
          if (type === TEXT_NODE || type === CDATA_NODE) {
            res += node.childNodes[i2].nodeValue;
          }
        }
        return res;
      } else if (node.nodeName === "integer") {
        (0, assert_1.default)(!isEmptyNode(node), 'Cannot parse "" as integer.');
        return parseInt(node.childNodes[0].nodeValue, 10);
      } else if (node.nodeName === "real") {
        (0, assert_1.default)(!isEmptyNode(node), 'Cannot parse "" as real.');
        res = "";
        for (i2 = 0; i2 < node.childNodes.length; i2++) {
          if (node.childNodes[i2].nodeType === TEXT_NODE) {
            res += node.childNodes[i2].nodeValue;
          }
        }
        return parseFloat(res);
      } else if (node.nodeName === "data") {
        res = "";
        if (isEmptyNode(node)) {
          return Buffer.from(res, "base64");
        }
        for (i2 = 0; i2 < node.childNodes.length; i2++) {
          if (node.childNodes[i2].nodeType === TEXT_NODE) {
            res += node.childNodes[i2].nodeValue.replace(/\s+/g, "");
          }
        }
        return Buffer.from(res, "base64");
      } else if (node.nodeName === "date") {
        (0, assert_1.default)(!isEmptyNode(node), 'Cannot parse "" as Date.');
        return new Date(node.childNodes[0].nodeValue);
      } else if (node.nodeName === "true") {
        return true;
      } else if (node.nodeName === "false") {
        return false;
      }
    }
  }
});

// node_modules/@expo/plist/build/index.js
var require_build3 = __commonJS({
  "node_modules/@expo/plist/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var build_1 = require_build2();
    var parse_1 = require_parse2();
    exports2.default = { parse: parse_1.parse, build: build_1.build };
  }
});

// node_modules/@expo/config-plugins/build/ios/BundleIdentifier.js
var require_BundleIdentifier = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/BundleIdentifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getBundleIdentifier = getBundleIdentifier;
    exports2.getBundleIdentifierFromPbxproj = getBundleIdentifierFromPbxproj;
    exports2.resetAllPlistBundleIdentifiers = resetAllPlistBundleIdentifiers;
    exports2.resetPlistBundleIdentifier = resetPlistBundleIdentifier;
    exports2.setBundleIdentifier = setBundleIdentifier;
    exports2.setBundleIdentifierForPbxproj = setBundleIdentifierForPbxproj;
    exports2.updateBundleIdentifierForPbxproj = updateBundleIdentifierForPbxproj;
    exports2.withBundleIdentifier = void 0;
    function _plist() {
      const data = _interopRequireDefault(require_build3());
      _plist = function() {
        return data;
      };
      return data;
    }
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _xcode() {
      const data = _interopRequireDefault(require_xcode());
      _xcode = function() {
        return data;
      };
      return data;
    }
    function _Paths() {
      const data = require_Paths2();
      _Paths = function() {
        return data;
      };
      return data;
    }
    function _Target() {
      const data = require_Target();
      _Target = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _string() {
      const data = require_string();
      _string = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var withBundleIdentifier = (config, {
      bundleIdentifier
    }) => {
      return (0, _iosPlugins().withXcodeProject)(config, async (config2) => {
        const bundleId = bundleIdentifier ?? config2.ios?.bundleIdentifier;
        (0, _assert().default)(bundleId, "`bundleIdentifier` must be defined in the app config (`ios.bundleIdentifier`) or passed to the plugin `withBundleIdentifier`.");
        config2.modResults = updateBundleIdentifierForPbxprojObject(config2.modResults, bundleId, false);
        return config2;
      });
    };
    exports2.withBundleIdentifier = withBundleIdentifier;
    function getBundleIdentifier(config) {
      return config.ios?.bundleIdentifier ?? null;
    }
    function setBundleIdentifier(config, infoPlist) {
      const bundleIdentifier = getBundleIdentifier(config);
      if (!bundleIdentifier) {
        return infoPlist;
      }
      return {
        ...infoPlist,
        CFBundleIdentifier: bundleIdentifier
      };
    }
    function getBundleIdentifierFromPbxproj(projectRoot, {
      targetName,
      buildConfiguration = "Release"
    } = {}) {
      let pbxprojPath;
      try {
        pbxprojPath = (0, _Paths().getPBXProjectPath)(projectRoot);
      } catch {
        return null;
      }
      const project = _xcode().default.project(pbxprojPath);
      project.parseSync();
      const xcBuildConfiguration = (0, _Target().getXCBuildConfigurationFromPbxproj)(project, {
        targetName,
        buildConfiguration
      });
      if (!xcBuildConfiguration) {
        return null;
      }
      return getProductBundleIdentifierFromBuildConfiguration(xcBuildConfiguration);
    }
    function getProductBundleIdentifierFromBuildConfiguration(xcBuildConfiguration) {
      const bundleIdentifierRaw = xcBuildConfiguration.buildSettings.PRODUCT_BUNDLE_IDENTIFIER;
      if (bundleIdentifierRaw) {
        const bundleIdentifier = (0, _string().trimQuotes)(bundleIdentifierRaw);
        return (0, _Xcodeproj().resolveXcodeBuildSetting)(bundleIdentifier, (setting) => xcBuildConfiguration.buildSettings[setting]);
      } else {
        return null;
      }
    }
    function updateBundleIdentifierForPbxproj(pbxprojPath, bundleIdentifier, updateProductName = true) {
      const project = _xcode().default.project(pbxprojPath);
      project.parseSync();
      _fs().default.writeFileSync(pbxprojPath, updateBundleIdentifierForPbxprojObject(project, bundleIdentifier, updateProductName).writeSync());
    }
    function updateBundleIdentifierForPbxprojObject(project, bundleIdentifier, updateProductName = true) {
      const [, nativeTarget] = (0, _Target().findFirstNativeTarget)(project);
      (0, _Xcodeproj().getBuildConfigurationsForListId)(project, nativeTarget.buildConfigurationList).forEach(([, item]) => {
        if (item.buildSettings.PRODUCT_BUNDLE_IDENTIFIER === bundleIdentifier) {
          return;
        }
        item.buildSettings.PRODUCT_BUNDLE_IDENTIFIER = `"${bundleIdentifier}"`;
        if (updateProductName) {
          const productName = bundleIdentifier.split(".").pop();
          if (!productName?.includes("$")) {
            item.buildSettings.PRODUCT_NAME = productName;
          }
        }
      });
      return project;
    }
    function setBundleIdentifierForPbxproj(projectRoot, bundleIdentifier, updateProductName = true) {
      let pbxprojPaths = [];
      try {
        pbxprojPaths = (0, _Paths().getAllPBXProjectPaths)(projectRoot);
      } catch {
      }
      for (const pbxprojPath of pbxprojPaths) {
        updateBundleIdentifierForPbxproj(pbxprojPath, bundleIdentifier, updateProductName);
      }
    }
    var defaultBundleId = "$(PRODUCT_BUNDLE_IDENTIFIER)";
    function resetAllPlistBundleIdentifiers(projectRoot) {
      const infoPlistPaths = (0, _Paths().getAllInfoPlistPaths)(projectRoot);
      for (const plistPath of infoPlistPaths) {
        resetPlistBundleIdentifier(plistPath);
      }
    }
    function resetPlistBundleIdentifier(plistPath) {
      const rawPlist = _fs().default.readFileSync(plistPath, "utf8");
      const plistObject = _plist().default.parse(rawPlist);
      if (plistObject.CFBundleIdentifier) {
        if (plistObject.CFBundleIdentifier === defaultBundleId) return;
        const format = {
          pretty: true,
          indent: `	`
        };
        const xml = _plist().default.build({
          ...plistObject,
          CFBundleIdentifier: defaultBundleId
        }, format);
        if (xml !== rawPlist) {
          _fs().default.writeFileSync(plistPath, xml);
        }
      }
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/DevelopmentTeam.js
var require_DevelopmentTeam = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/DevelopmentTeam.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getDevelopmentTeam = getDevelopmentTeam;
    exports2.setDevelopmentTeamForBuildConfiguration = setDevelopmentTeamForBuildConfiguration;
    exports2.setDevelopmentTeamForPbxproj = setDevelopmentTeamForPbxproj;
    exports2.updateDevelopmentTeamForPbxproj = updateDevelopmentTeamForPbxproj;
    exports2.withDevelopmentTeam = void 0;
    function _nodeFs() {
      const data = _interopRequireDefault(require("fs"));
      _nodeFs = function() {
        return data;
      };
      return data;
    }
    function _xcode() {
      const data = _interopRequireDefault(require_xcode());
      _xcode = function() {
        return data;
      };
      return data;
    }
    function _Paths() {
      const data = require_Paths2();
      _Paths = function() {
        return data;
      };
      return data;
    }
    function _Target() {
      const data = require_Target();
      _Target = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _string() {
      const data = require_string();
      _string = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var withDevelopmentTeam = (config, {
      appleTeamId
    } = {}) => {
      return (0, _iosPlugins().withXcodeProject)(config, (config2) => {
        const teamId = appleTeamId ?? getDevelopmentTeam(config2);
        if (teamId) {
          config2.modResults = updateDevelopmentTeamForPbxproj(config2.modResults, teamId);
        }
        return config2;
      });
    };
    exports2.withDevelopmentTeam = withDevelopmentTeam;
    function getDevelopmentTeam(config) {
      return config.ios?.appleTeamId ?? null;
    }
    function setDevelopmentTeamForBuildConfiguration(xcBuildConfiguration, developmentTeam) {
      if (developmentTeam) {
        xcBuildConfiguration.buildSettings.DEVELOPMENT_TEAM = (0, _string().trimQuotes)(developmentTeam);
      } else {
        delete xcBuildConfiguration.buildSettings.DEVELOPMENT_TEAM;
      }
    }
    function updateDevelopmentTeamForPbxproj(project, appleTeamId) {
      const nativeTargets = (0, _Target().getNativeTargets)(project);
      nativeTargets.forEach(([, nativeTarget]) => {
        (0, _Xcodeproj().getBuildConfigurationsForListId)(project, nativeTarget.buildConfigurationList).forEach(([, buildConfig]) => setDevelopmentTeamForBuildConfiguration(buildConfig, appleTeamId));
      });
      return project;
    }
    function setDevelopmentTeamForPbxproj(projectRoot, appleTeamId) {
      const pbxprojPaths = (0, _Paths().getAllPBXProjectPaths)(projectRoot);
      for (const pbxprojPath of pbxprojPaths) {
        let project = _xcode().default.project(pbxprojPath);
        project.parseSync();
        project = updateDevelopmentTeamForPbxproj(project, appleTeamId);
        _nodeFs().default.writeFileSync(pbxprojPath, project.writeSync());
      }
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/DeviceFamily.js
var require_DeviceFamily = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/DeviceFamily.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.formatDeviceFamilies = formatDeviceFamilies;
    exports2.getDeviceFamilies = getDeviceFamilies;
    exports2.getIsTabletOnly = getIsTabletOnly;
    exports2.getSupportsTablet = getSupportsTablet;
    exports2.setDeviceFamily = setDeviceFamily;
    exports2.withDeviceFamily = void 0;
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    var withDeviceFamily = (config) => {
      return (0, _iosPlugins().withXcodeProject)(config, async (config2) => {
        config2.modResults = await setDeviceFamily(config2, {
          project: config2.modResults
        });
        return config2;
      });
    };
    exports2.withDeviceFamily = withDeviceFamily;
    function getSupportsTablet(config) {
      return !!config.ios?.supportsTablet;
    }
    function getIsTabletOnly(config) {
      return !!config?.ios?.isTabletOnly;
    }
    function getDeviceFamilies(config) {
      const supportsTablet = getSupportsTablet(config);
      const isTabletOnly = getIsTabletOnly(config);
      if (isTabletOnly && config.ios?.supportsTablet === false) {
        (0, _warnings().addWarningIOS)("ios.supportsTablet", `Found contradictory values: \`{ ios: { isTabletOnly: true, supportsTablet: false } }\`. Using \`{ isTabletOnly: true }\`.`);
      }
      if (isTabletOnly) {
        return [2];
      } else if (supportsTablet) {
        return [1, 2];
      } else {
        return [1];
      }
    }
    function formatDeviceFamilies(deviceFamilies) {
      return `"${deviceFamilies.join(",")}"`;
    }
    function setDeviceFamily(config, {
      project
    }) {
      const deviceFamilies = formatDeviceFamilies(getDeviceFamilies(config));
      const configurations = project.pbxXCBuildConfigurationSection();
      for (const {
        buildSettings
      } of Object.values(configurations || {})) {
        if (typeof buildSettings?.PRODUCT_NAME !== "undefined") {
          if (typeof buildSettings?.TVOS_DEPLOYMENT_TARGET !== "undefined") {
            buildSettings.TARGETED_DEVICE_FAMILY = "3";
          } else {
            buildSettings.TARGETED_DEVICE_FAMILY = deviceFamilies;
          }
        }
      }
      return project;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/Scheme.js
var require_Scheme2 = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Scheme.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.appendScheme = appendScheme;
    exports2.getScheme = getScheme;
    exports2.getSchemesFromPlist = getSchemesFromPlist;
    exports2.hasScheme = hasScheme;
    exports2.removeScheme = removeScheme;
    exports2.setScheme = setScheme;
    exports2.withScheme = void 0;
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    var withScheme = exports2.withScheme = (0, _iosPlugins().createInfoPlistPluginWithPropertyGuard)(setScheme, {
      infoPlistProperty: "CFBundleURLTypes",
      expoConfigProperty: "scheme"
    }, "withScheme");
    function getScheme(config) {
      if (Array.isArray(config.scheme)) {
        const validate = (value) => {
          return typeof value === "string";
        };
        return config.scheme.filter(validate);
      } else if (typeof config.scheme === "string") {
        return [config.scheme];
      }
      return [];
    }
    function setScheme(config, infoPlist) {
      const scheme = [...getScheme(config), ...getScheme(config.ios ?? {})];
      if (config.ios?.bundleIdentifier) {
        scheme.push(config.ios.bundleIdentifier);
      }
      if (scheme.length === 0) {
        return infoPlist;
      }
      return {
        ...infoPlist,
        CFBundleURLTypes: [{
          CFBundleURLSchemes: scheme
        }]
      };
    }
    function appendScheme(scheme, infoPlist) {
      if (!scheme) {
        return infoPlist;
      }
      const existingSchemes = infoPlist.CFBundleURLTypes ?? [];
      if (existingSchemes?.some(({
        CFBundleURLSchemes
      }) => CFBundleURLSchemes.includes(scheme))) {
        return infoPlist;
      }
      return {
        ...infoPlist,
        CFBundleURLTypes: [...existingSchemes, {
          CFBundleURLSchemes: [scheme]
        }]
      };
    }
    function removeScheme(scheme, infoPlist) {
      if (!scheme) {
        return infoPlist;
      }
      if (!infoPlist.CFBundleURLTypes) {
        return infoPlist;
      }
      infoPlist.CFBundleURLTypes = infoPlist.CFBundleURLTypes.map((bundleUrlType) => {
        const index = bundleUrlType.CFBundleURLSchemes.indexOf(scheme);
        if (index > -1) {
          bundleUrlType.CFBundleURLSchemes.splice(index, 1);
          if (bundleUrlType.CFBundleURLSchemes.length === 0) {
            return void 0;
          }
        }
        return bundleUrlType;
      }).filter(Boolean);
      return infoPlist;
    }
    function hasScheme(scheme, infoPlist) {
      const existingSchemes = infoPlist.CFBundleURLTypes;
      if (!Array.isArray(existingSchemes)) return false;
      return existingSchemes?.some(({
        CFBundleURLSchemes: schemes
      }) => Array.isArray(schemes) ? schemes.includes(scheme) : false);
    }
    function getSchemesFromPlist(infoPlist) {
      if (Array.isArray(infoPlist.CFBundleURLTypes)) {
        return infoPlist.CFBundleURLTypes.reduce((schemes, {
          CFBundleURLSchemes
        }) => {
          if (Array.isArray(CFBundleURLSchemes)) {
            return [...schemes, ...CFBundleURLSchemes];
          }
          return schemes;
        }, []);
      }
      return [];
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/Google.js
var require_Google = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Google.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getGoogleServicesFile = getGoogleServicesFile;
    exports2.getGoogleSignInReversedClientId = getGoogleSignInReversedClientId;
    exports2.setGoogleConfig = setGoogleConfig;
    exports2.setGoogleServicesFile = setGoogleServicesFile;
    exports2.setGoogleSignInReversedClientId = setGoogleSignInReversedClientId;
    exports2.withGoogleServicesFile = exports2.withGoogle = void 0;
    function _plist() {
      const data = _interopRequireDefault(require_build3());
      _plist = function() {
        return data;
      };
      return data;
    }
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _Paths() {
      const data = require_Paths2();
      _Paths = function() {
        return data;
      };
      return data;
    }
    function _Scheme() {
      const data = require_Scheme2();
      _Scheme = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var withGoogle = (config) => {
      return (0, _iosPlugins().withInfoPlist)(config, (config2) => {
        config2.modResults = setGoogleConfig(config2, config2.modResults, config2.modRequest);
        return config2;
      });
    };
    exports2.withGoogle = withGoogle;
    var withGoogleServicesFile = (config) => {
      return (0, _iosPlugins().withXcodeProject)(config, (config2) => {
        config2.modResults = setGoogleServicesFile(config2, {
          projectRoot: config2.modRequest.projectRoot,
          project: config2.modResults
        });
        return config2;
      });
    };
    exports2.withGoogleServicesFile = withGoogleServicesFile;
    function readGoogleServicesInfoPlist(relativePath, {
      projectRoot
    }) {
      const googleServiceFilePath = _path().default.resolve(projectRoot, relativePath);
      const contents = _fs().default.readFileSync(googleServiceFilePath, "utf8");
      (0, _assert().default)(contents, "GoogleService-Info.plist is empty");
      return _plist().default.parse(contents);
    }
    function getGoogleSignInReversedClientId(config, modRequest) {
      const googleServicesFileRelativePath = getGoogleServicesFile(config);
      if (googleServicesFileRelativePath === null) {
        return null;
      }
      const infoPlist = readGoogleServicesInfoPlist(googleServicesFileRelativePath, modRequest);
      return infoPlist.REVERSED_CLIENT_ID ?? null;
    }
    function getGoogleServicesFile(config) {
      return config.ios?.googleServicesFile ?? null;
    }
    function setGoogleSignInReversedClientId(config, infoPlist, modRequest) {
      const reversedClientId = getGoogleSignInReversedClientId(config, modRequest);
      if (reversedClientId === null) {
        return infoPlist;
      }
      return (0, _Scheme().appendScheme)(reversedClientId, infoPlist);
    }
    function setGoogleConfig(config, infoPlist, modRequest) {
      infoPlist = setGoogleSignInReversedClientId(config, infoPlist, modRequest);
      return infoPlist;
    }
    function setGoogleServicesFile(config, {
      projectRoot,
      project
    }) {
      const googleServicesFileRelativePath = getGoogleServicesFile(config);
      if (googleServicesFileRelativePath === null) {
        return project;
      }
      const googleServiceFilePath = _path().default.resolve(projectRoot, googleServicesFileRelativePath);
      _fs().default.copyFileSync(googleServiceFilePath, _path().default.join((0, _Paths().getSourceRoot)(projectRoot), "GoogleService-Info.plist"));
      const projectName = (0, _Xcodeproj().getProjectName)(projectRoot);
      const plistFilePath = `${projectName}/GoogleService-Info.plist`;
      if (!project.hasFile(plistFilePath)) {
        project = (0, _Xcodeproj().addResourceFileToGroup)({
          filepath: plistFilePath,
          groupName: projectName,
          project,
          isBuildFile: true,
          verbose: true
        });
      }
      return project;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/IosConfig.types.js
var require_IosConfig_types = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/IosConfig.types.js"() {
    "use strict";
  }
});

// node_modules/@expo/config-plugins/build/ios/Locales.js
var require_Locales2 = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Locales.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getLocales = getLocales;
    exports2.setLocalesAsync = setLocalesAsync;
    exports2.withLocales = void 0;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _locales() {
      const data = require_locales();
      _locales = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var withLocales = (config) => {
      return (0, _iosPlugins().withXcodeProject)(config, async (config2) => {
        config2.modResults = await setLocalesAsync(config2, {
          projectRoot: config2.modRequest.projectRoot,
          project: config2.modResults
        });
        return config2;
      });
    };
    exports2.withLocales = withLocales;
    function getLocales(config) {
      return config.locales ?? null;
    }
    async function setLocalesAsync(config, {
      projectRoot,
      project
    }) {
      const locales = getLocales(config);
      if (!locales) {
        return project;
      }
      const localesMap = await (0, _locales().getResolvedLocalesAsync)(projectRoot, locales, "ios");
      const projectName = (0, _Xcodeproj().getProjectName)(projectRoot);
      const supportingDirectory = _path().default.join(projectRoot, "ios", projectName, "Supporting");
      const stringName = "InfoPlist.strings";
      for (const [lang, localizationObj] of Object.entries(localesMap)) {
        const dir = _path().default.join(supportingDirectory, `${lang}.lproj`);
        await _fs().default.promises.mkdir(dir, {
          recursive: true
        });
        const strings = _path().default.join(dir, stringName);
        const buffer2 = [];
        for (const [plistKey, localVersion] of Object.entries(localizationObj)) {
          buffer2.push(`${plistKey} = "${localVersion}";`);
        }
        await _fs().default.promises.writeFile(strings, buffer2.join("\n"));
        const groupName = `${projectName}/Supporting/${lang}.lproj`;
        const group = (0, _Xcodeproj().ensureGroupRecursively)(project, groupName);
        if (!group?.children.some(({
          comment
        }) => comment === stringName)) {
          project = (0, _Xcodeproj().addResourceFileToGroup)({
            filepath: _path().default.relative(supportingDirectory, strings),
            groupName,
            project,
            isBuildFile: true,
            verbose: true
          });
        }
      }
      return project;
    }
  }
});

// node_modules/@expo/config-plugins/build/utils/generateCode.js
var require_generateCode = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/generateCode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createGeneratedHeaderComment = createGeneratedHeaderComment;
    exports2.createHash = createHash;
    exports2.mergeContents = mergeContents;
    exports2.removeContents = removeContents;
    exports2.removeGeneratedContents = removeGeneratedContents;
    function _crypto() {
      const data = _interopRequireDefault(require("crypto"));
      _crypto = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function getGeneratedSectionIndexes(src, tag) {
      const contents = src.split("\n");
      const start = contents.findIndex((line2) => new RegExp(`@generated begin ${tag} -`).test(line2));
      const end = contents.findIndex((line2) => new RegExp(`@generated end ${tag}$`).test(line2));
      return {
        contents,
        start,
        end
      };
    }
    function mergeContents({
      src,
      newSrc,
      tag,
      anchor,
      offset,
      comment
    }) {
      const header = createGeneratedHeaderComment(newSrc, tag, comment);
      if (!src.includes(header)) {
        const sanitizedTarget = removeGeneratedContents(src, tag);
        return {
          contents: addLines(sanitizedTarget ?? src, anchor, offset, [header, ...newSrc.split("\n"), `${comment} @generated end ${tag}`]),
          didMerge: true,
          didClear: !!sanitizedTarget
        };
      }
      return {
        contents: src,
        didClear: false,
        didMerge: false
      };
    }
    function removeContents({
      src,
      tag
    }) {
      const sanitizedTarget = removeGeneratedContents(src, tag);
      return {
        contents: sanitizedTarget ?? src,
        didMerge: false,
        didClear: !!sanitizedTarget
      };
    }
    function addLines(content, find, offset, toAdd) {
      const lines = content.split("\n");
      let lineIndex = lines.findIndex((line2) => line2.match(find));
      if (lineIndex < 0) {
        const error = new Error(`Failed to match "${find}" in contents:
${content}`);
        error.code = "ERR_NO_MATCH";
        throw error;
      }
      for (const newLine of toAdd) {
        lines.splice(lineIndex + offset, 0, newLine);
        lineIndex++;
      }
      return lines.join("\n");
    }
    function removeGeneratedContents(src, tag) {
      const {
        contents,
        start,
        end
      } = getGeneratedSectionIndexes(src, tag);
      if (start > -1 && end > -1 && start < end) {
        contents.splice(start, end - start + 1);
        return contents.join("\n");
      }
      return null;
    }
    function createGeneratedHeaderComment(contents, tag, comment) {
      const hashKey = createHash(contents);
      return `${comment} @generated begin ${tag} - expo prebuild (DO NOT MODIFY) ${hashKey}`;
    }
    function createHash(src) {
      const hash = _crypto().default.createHash("sha1").update(src).digest("hex");
      return `sync-${hash}`;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/Maps.js
var require_Maps = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Maps.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MATCH_INIT = void 0;
    exports2.addGoogleMapsAppDelegateImport = addGoogleMapsAppDelegateImport;
    exports2.addGoogleMapsAppDelegateInit = addGoogleMapsAppDelegateInit;
    exports2.addMapsCocoaPods = addMapsCocoaPods;
    exports2.getGoogleMapsApiKey = getGoogleMapsApiKey;
    exports2.removeGoogleMapsAppDelegateImport = removeGoogleMapsAppDelegateImport;
    exports2.removeGoogleMapsAppDelegateInit = removeGoogleMapsAppDelegateInit;
    exports2.removeMapsCocoaPods = removeMapsCocoaPods;
    exports2.setGoogleMapsApiKey = setGoogleMapsApiKey;
    exports2.withMaps = void 0;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _resolveFrom() {
      const data = _interopRequireDefault(require_resolve_from());
      _resolveFrom = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _generateCode() {
      const data = require_generateCode();
      _generateCode = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var debug = require_src()("expo:config-plugins:ios:maps");
    var MATCH_INIT = exports2.MATCH_INIT = /\bsuper\.application\(\w+?, didFinishLaunchingWithOptions: \w+?\)/g;
    var withGoogleMapsKey = (0, _iosPlugins().createInfoPlistPlugin)(setGoogleMapsApiKey, "withGoogleMapsKey");
    var withMaps = (config) => {
      config = withGoogleMapsKey(config);
      const apiKey = getGoogleMapsApiKey(config);
      debug("Google Maps API Key:", apiKey);
      config = withMapsCocoaPods(config, {
        useGoogleMaps: !!apiKey
      });
      config = withGoogleMapsAppDelegate(config, {
        apiKey
      });
      return config;
    };
    exports2.withMaps = withMaps;
    function getGoogleMapsApiKey(config) {
      return config.ios?.config?.googleMapsApiKey ?? null;
    }
    function setGoogleMapsApiKey(config, {
      GMSApiKey,
      ...infoPlist
    }) {
      const apiKey = getGoogleMapsApiKey(config);
      if (apiKey === null) {
        return infoPlist;
      }
      return {
        ...infoPlist,
        GMSApiKey: apiKey
      };
    }
    function addGoogleMapsAppDelegateImport(src) {
      const newSrc = ["#if canImport(GoogleMaps)", "import GoogleMaps", "#endif"];
      return (0, _generateCode().mergeContents)({
        tag: "react-native-maps-import",
        src,
        newSrc: newSrc.join("\n"),
        anchor: /@UIApplicationMain/,
        offset: 0,
        comment: "//"
      });
    }
    function removeGoogleMapsAppDelegateImport(src) {
      return (0, _generateCode().removeContents)({
        tag: "react-native-maps-import",
        src
      });
    }
    function addGoogleMapsAppDelegateInit(src, apiKey) {
      const newSrc = ["#if canImport(GoogleMaps)", `GMSServices.provideAPIKey("${apiKey}")`, "#endif"];
      return (0, _generateCode().mergeContents)({
        tag: "react-native-maps-init",
        src,
        newSrc: newSrc.join("\n"),
        anchor: MATCH_INIT,
        offset: 0,
        comment: "//"
      });
    }
    function removeGoogleMapsAppDelegateInit(src) {
      return (0, _generateCode().removeContents)({
        tag: "react-native-maps-init",
        src
      });
    }
    function addMapsCocoaPods(src) {
      return (0, _generateCode().mergeContents)({
        tag: "react-native-maps",
        src,
        newSrc: `  pod 'react-native-google-maps', path: File.dirname(\`node --print "require.resolve('react-native-maps/package.json')"\`)`,
        anchor: /use_native_modules/,
        offset: 0,
        comment: "#"
      });
    }
    function removeMapsCocoaPods(src) {
      return (0, _generateCode().removeContents)({
        tag: "react-native-maps",
        src
      });
    }
    function isReactNativeMapsInstalled(projectRoot) {
      const resolved = _resolveFrom().default.silent(projectRoot, "react-native-maps/package.json");
      return resolved ? _path().default.dirname(resolved) : null;
    }
    function isReactNativeMapsAutolinked(config) {
      return true;
    }
    var withMapsCocoaPods = (config, {
      useGoogleMaps
    }) => {
      return (0, _iosPlugins().withPodfile)(config, async (config2) => {
        const googleMapsPath = isReactNativeMapsInstalled(config2.modRequest.projectRoot);
        const isLinked = isReactNativeMapsAutolinked(config2);
        debug("Is Expo Autolinked:", isLinked);
        debug("react-native-maps path:", googleMapsPath);
        let results;
        if (isLinked && googleMapsPath && useGoogleMaps) {
          try {
            results = addMapsCocoaPods(config2.modResults.contents);
          } catch (error) {
            if (error.code === "ERR_NO_MATCH") {
              throw new Error(`Cannot add react-native-maps to the project's ios/Podfile because it's malformed. Report this with a copy of your project Podfile: https://github.com/expo/expo/issues`);
            }
            throw error;
          }
        } else {
          results = removeMapsCocoaPods(config2.modResults.contents);
        }
        if (results.didMerge || results.didClear) {
          config2.modResults.contents = results.contents;
        }
        return config2;
      });
    };
    var withGoogleMapsAppDelegate = (config, {
      apiKey
    }) => {
      return (0, _iosPlugins().withAppDelegate)(config, (config2) => {
        if (!apiKey || !isReactNativeMapsAutolinked(config2) || !isReactNativeMapsInstalled(config2.modRequest.projectRoot)) {
          config2.modResults.contents = removeGoogleMapsAppDelegateImport(config2.modResults.contents).contents;
          config2.modResults.contents = removeGoogleMapsAppDelegateInit(config2.modResults.contents).contents;
          return config2;
        }
        if (config2.modResults.language !== "swift") {
          throw new Error(`Cannot setup Google Maps because the project AppDelegate is not a supported language: ${config2.modResults.language}`);
        }
        try {
          config2.modResults.contents = addGoogleMapsAppDelegateImport(config2.modResults.contents).contents;
          config2.modResults.contents = addGoogleMapsAppDelegateInit(config2.modResults.contents, apiKey).contents;
        } catch (error) {
          if (error.code === "ERR_NO_MATCH") {
            throw new Error(`Cannot add Google Maps to the project's AppDelegate because it's malformed. Report this with a copy of your project AppDelegate: https://github.com/expo/expo/issues`);
          }
          throw error;
        }
        return config2;
      });
    };
  }
});

// node_modules/@expo/config-plugins/build/ios/Name.js
var require_Name2 = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Name.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getName = getName;
    exports2.setDisplayName = setDisplayName;
    exports2.setName = setName;
    exports2.setProductName = setProductName;
    exports2.withProductName = exports2.withName = exports2.withDisplayName = void 0;
    function _Target() {
      const data = require_Target();
      _Target = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    var withDisplayName = exports2.withDisplayName = (0, _iosPlugins().createInfoPlistPluginWithPropertyGuard)(setDisplayName, {
      infoPlistProperty: "CFBundleDisplayName",
      expoConfigProperty: "name"
    }, "withDisplayName");
    var withName = exports2.withName = (0, _iosPlugins().createInfoPlistPluginWithPropertyGuard)(setName, {
      infoPlistProperty: "CFBundleName",
      expoConfigProperty: "name"
    }, "withName");
    var withProductName = (config) => {
      return (0, _iosPlugins().withXcodeProject)(config, (config2) => {
        config2.modResults = setProductName(config2, config2.modResults);
        return config2;
      });
    };
    exports2.withProductName = withProductName;
    function getName(config) {
      return typeof config.name === "string" ? config.name : null;
    }
    function setDisplayName(configOrName, {
      CFBundleDisplayName,
      ...infoPlist
    }) {
      let name = null;
      if (typeof configOrName === "string") {
        name = configOrName;
      } else {
        name = getName(configOrName);
      }
      if (!name) {
        return infoPlist;
      }
      return {
        ...infoPlist,
        CFBundleDisplayName: name
      };
    }
    function setName(config, {
      CFBundleName,
      ...infoPlist
    }) {
      const name = getName(config);
      if (!name) {
        return infoPlist;
      }
      return {
        ...infoPlist,
        CFBundleName: name
      };
    }
    function setProductName(config, project) {
      const name = (0, _Xcodeproj().sanitizedName)(getName(config) ?? "");
      if (!name) {
        return project;
      }
      const quotedName = ensureQuotes(name);
      const [, nativeTarget] = (0, _Target().findFirstNativeTarget)(project);
      (0, _Xcodeproj().getBuildConfigurationsForListId)(project, nativeTarget.buildConfigurationList).forEach(([, item]) => {
        item.buildSettings.PRODUCT_NAME = quotedName;
      });
      return project;
    }
    var ensureQuotes = (value) => {
      if (!value.match(/^['"]/)) {
        return `"${value}"`;
      }
      return value;
    };
  }
});

// node_modules/@expo/config-plugins/build/ios/Orientation.js
var require_Orientation2 = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Orientation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PORTRAIT_ORIENTATIONS = exports2.LANDSCAPE_ORIENTATIONS = void 0;
    exports2.getOrientation = getOrientation;
    exports2.setOrientation = setOrientation;
    exports2.withOrientation = void 0;
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    var withOrientation = exports2.withOrientation = (0, _iosPlugins().createInfoPlistPluginWithPropertyGuard)(setOrientation, {
      infoPlistProperty: "UISupportedInterfaceOrientations",
      expoConfigProperty: "orientation"
    }, "withOrientation");
    function getOrientation(config) {
      return config.orientation ?? null;
    }
    var PORTRAIT_ORIENTATIONS = exports2.PORTRAIT_ORIENTATIONS = ["UIInterfaceOrientationPortrait", "UIInterfaceOrientationPortraitUpsideDown"];
    var LANDSCAPE_ORIENTATIONS = exports2.LANDSCAPE_ORIENTATIONS = ["UIInterfaceOrientationLandscapeLeft", "UIInterfaceOrientationLandscapeRight"];
    function getUISupportedInterfaceOrientations(orientation) {
      if (orientation === "portrait") {
        return PORTRAIT_ORIENTATIONS;
      } else if (orientation === "landscape") {
        return LANDSCAPE_ORIENTATIONS;
      } else {
        return [...PORTRAIT_ORIENTATIONS, ...LANDSCAPE_ORIENTATIONS];
      }
    }
    function setOrientation(config, infoPlist) {
      const orientation = getOrientation(config);
      return {
        ...infoPlist,
        UISupportedInterfaceOrientations: getUISupportedInterfaceOrientations(orientation)
      };
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/Permissions.js
var require_Permissions2 = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.applyPermissions = applyPermissions;
    exports2.createPermissionsPlugin = createPermissionsPlugin;
    function _debug() {
      const data = _interopRequireDefault(require_src());
      _debug = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var debug = (0, _debug().default)("expo:config-plugins:ios:permissions");
    function applyPermissions(defaults, permissions, infoPlist) {
      const entries = Object.entries(defaults);
      if (entries.length === 0) {
        debug(`No defaults provided: ${JSON.stringify(permissions)}`);
      }
      for (const [permission, description] of entries) {
        if (permissions[permission] === false) {
          debug(`Deleting "${permission}"`);
          delete infoPlist[permission];
        } else {
          infoPlist[permission] = permissions[permission] || infoPlist[permission] || description;
          debug(`Setting "${permission}" to "${infoPlist[permission]}"`);
        }
      }
      return infoPlist;
    }
    function createPermissionsPlugin(defaults, name) {
      const withIosPermissions = (config, permissions) => (0, _iosPlugins().withInfoPlist)(config, async (config2) => {
        config2.modResults = applyPermissions(defaults, permissions, config2.modResults);
        return config2;
      });
      if (name) {
        Object.defineProperty(withIosPermissions, "name", {
          value: name
        });
      }
      return withIosPermissions;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/PrivacyInfo.js
var require_PrivacyInfo = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/PrivacyInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mergePrivacyInfo = mergePrivacyInfo;
    exports2.setPrivacyInfo = setPrivacyInfo;
    exports2.withPrivacyInfo = withPrivacyInfo;
    function _plist() {
      const data = _interopRequireDefault(require_build3());
      _plist = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function withPrivacyInfo(config) {
      const privacyManifests = config.ios?.privacyManifests;
      if (!privacyManifests) {
        return config;
      }
      return (0, _iosPlugins().withXcodeProject)(config, (projectConfig) => {
        return setPrivacyInfo(projectConfig, privacyManifests);
      });
    }
    function setPrivacyInfo(projectConfig, privacyManifests) {
      const {
        projectRoot,
        platformProjectRoot
      } = projectConfig.modRequest;
      const projectName = (0, _Xcodeproj().getProjectName)(projectRoot);
      const privacyFilePath = _path().default.join(platformProjectRoot, projectName, "PrivacyInfo.xcprivacy");
      const existingFileContent = getFileContents(privacyFilePath);
      const parsedContent = existingFileContent ? _plist().default.parse(existingFileContent) : {};
      const mergedContent = mergePrivacyInfo(parsedContent, privacyManifests);
      const contents = _plist().default.build(mergedContent);
      ensureFileExists(privacyFilePath, contents);
      if (!projectConfig.modResults.hasFile(privacyFilePath)) {
        projectConfig.modResults = (0, _Xcodeproj().addResourceFileToGroup)({
          filepath: _path().default.join(projectName, "PrivacyInfo.xcprivacy"),
          groupName: projectName,
          project: projectConfig.modResults,
          isBuildFile: true,
          verbose: true
        });
      }
      return projectConfig;
    }
    function getFileContents(filePath) {
      if (!_fs().default.existsSync(filePath)) {
        return null;
      }
      return _fs().default.readFileSync(filePath, {
        encoding: "utf8"
      });
    }
    function ensureFileExists(filePath, contents) {
      if (!_fs().default.existsSync(_path().default.dirname(filePath))) {
        _fs().default.mkdirSync(_path().default.dirname(filePath), {
          recursive: true
        });
      }
      _fs().default.writeFileSync(filePath, contents);
    }
    function mergePrivacyInfo(existing, privacyManifests) {
      let {
        NSPrivacyAccessedAPITypes = [],
        NSPrivacyCollectedDataTypes = [],
        NSPrivacyTracking = false,
        NSPrivacyTrackingDomains = []
      } = structuredClone(existing);
      NSPrivacyTracking = privacyManifests.NSPrivacyTracking ?? existing.NSPrivacyTracking ?? false;
      privacyManifests.NSPrivacyAccessedAPITypes?.forEach((newType) => {
        const existingType = NSPrivacyAccessedAPITypes.find((t) => t.NSPrivacyAccessedAPIType === newType.NSPrivacyAccessedAPIType);
        if (!existingType) {
          NSPrivacyAccessedAPITypes.push(newType);
        } else {
          existingType.NSPrivacyAccessedAPITypeReasons = [...new Set(existingType?.NSPrivacyAccessedAPITypeReasons?.concat(...newType.NSPrivacyAccessedAPITypeReasons))];
        }
      });
      privacyManifests.NSPrivacyCollectedDataTypes?.forEach((newType) => {
        const existingType = NSPrivacyCollectedDataTypes.find((t) => t.NSPrivacyCollectedDataType === newType.NSPrivacyCollectedDataType);
        if (!existingType) {
          NSPrivacyCollectedDataTypes.push(newType);
        } else {
          existingType.NSPrivacyCollectedDataTypePurposes = [...new Set(existingType?.NSPrivacyCollectedDataTypePurposes?.concat(...newType.NSPrivacyCollectedDataTypePurposes))];
        }
      });
      NSPrivacyTrackingDomains = [...new Set(NSPrivacyTrackingDomains.concat(privacyManifests.NSPrivacyTrackingDomains ?? []))];
      return {
        NSPrivacyAccessedAPITypes,
        NSPrivacyCollectedDataTypes,
        NSPrivacyTracking,
        NSPrivacyTrackingDomains
      };
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/ProvisioningProfile.js
var require_ProvisioningProfile = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/ProvisioningProfile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.setProvisioningProfileForPbxproj = setProvisioningProfileForPbxproj;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _Target() {
      const data = require_Target();
      _Target = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _string() {
      const data = require_string();
      _string = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function setProvisioningProfileForPbxproj(projectRoot, {
      targetName,
      profileName,
      appleTeamId,
      buildConfiguration = "Release"
    }) {
      const project = (0, _Xcodeproj().getPbxproj)(projectRoot);
      const nativeTargetEntry = targetName ? (0, _Target().findNativeTargetByName)(project, targetName) : (0, _Target().findFirstNativeTarget)(project);
      const [nativeTargetId, nativeTarget] = nativeTargetEntry;
      const quotedAppleTeamId = ensureQuotes(appleTeamId);
      (0, _Xcodeproj().getBuildConfigurationsForListId)(project, nativeTarget.buildConfigurationList).filter(([, item]) => (0, _string().trimQuotes)(item.name) === buildConfiguration).forEach(([, item]) => {
        item.buildSettings.PROVISIONING_PROFILE_SPECIFIER = `"${profileName}"`;
        item.buildSettings.DEVELOPMENT_TEAM = quotedAppleTeamId;
        item.buildSettings.CODE_SIGN_IDENTITY = '"iPhone Distribution"';
        item.buildSettings.CODE_SIGN_STYLE = "Manual";
      });
      Object.entries((0, _Xcodeproj().getProjectSection)(project)).filter(_Xcodeproj().isNotComment).forEach(([, item]) => {
        if (!item.attributes.TargetAttributes[nativeTargetId]) {
          item.attributes.TargetAttributes[nativeTargetId] = {};
        }
        item.attributes.TargetAttributes[nativeTargetId].DevelopmentTeam = quotedAppleTeamId;
        item.attributes.TargetAttributes[nativeTargetId].ProvisioningStyle = "Manual";
      });
      _fs().default.writeFileSync(project.filepath, project.writeSync());
    }
    var ensureQuotes = (value) => {
      if (!value.match(/^['"]/)) {
        return `"${value}"`;
      }
      return value;
    };
  }
});

// node_modules/@expo/config-plugins/build/ios/RequiresFullScreen.js
var require_RequiresFullScreen = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/RequiresFullScreen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.setRequiresFullScreen = setRequiresFullScreen;
    exports2.withRequiresFullScreen = void 0;
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    var withRequiresFullScreen = exports2.withRequiresFullScreen = (0, _iosPlugins().createInfoPlistPlugin)(setRequiresFullScreen, "withRequiresFullScreen");
    var iPadInterfaceKey = "UISupportedInterfaceOrientations~ipad";
    var requiredIPadInterface = ["UIInterfaceOrientationPortrait", "UIInterfaceOrientationPortraitUpsideDown", "UIInterfaceOrientationLandscapeLeft", "UIInterfaceOrientationLandscapeRight"];
    function isStringArray(value) {
      return Array.isArray(value) && value.every((value2) => typeof value2 === "string");
    }
    function hasMinimumOrientations(masks) {
      return requiredIPadInterface.every((mask) => masks.includes(mask));
    }
    function resolveExistingIpadInterfaceOrientations(interfaceOrientations) {
      if (
        // Ensure type.
        isStringArray(interfaceOrientations) && // Don't warn if it's an empty array, this is invalid regardless.
        interfaceOrientations.length && // Check if the minimum requirements are met.
        !hasMinimumOrientations(interfaceOrientations)
      ) {
        const existingList = interfaceOrientations.join(", ");
        (0, _warnings().addWarningIOS)("ios.requireFullScreen", `iPad multitasking requires all \`${iPadInterfaceKey}\` orientations to be defined in the Info.plist. The Info.plist currently defines values that are incompatible with multitasking, these will be overwritten to prevent submission failure. Existing: ${existingList}`);
        return interfaceOrientations;
      }
      return [];
    }
    function setRequiresFullScreen(config, infoPlist) {
      const requiresFullScreen = !!config.ios?.requireFullScreen;
      const isTabletEnabled = config.ios?.supportsTablet || config.ios?.isTabletOnly;
      if (isTabletEnabled && !requiresFullScreen) {
        const existing = resolveExistingIpadInterfaceOrientations(infoPlist[iPadInterfaceKey]);
        infoPlist[iPadInterfaceKey] = [...new Set(existing.concat(requiredIPadInterface))];
      }
      return {
        ...infoPlist,
        UIRequiresFullScreen: requiresFullScreen
      };
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/Updates.js
var require_Updates3 = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/Updates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Config = void 0;
    exports2.setUpdatesConfigAsync = setUpdatesConfigAsync;
    exports2.setVersionsConfigAsync = setVersionsConfigAsync;
    exports2.withUpdatesNativeDebugPodfileProps = exports2.withUpdates = void 0;
    function _BuildProperties() {
      const data = require_BuildProperties2();
      _BuildProperties = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _withPlugins() {
      const data = require_withPlugins();
      _withPlugins = function() {
        return data;
      };
      return data;
    }
    function _Updates() {
      const data = require_Updates();
      _Updates = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    var Config = exports2.Config = /* @__PURE__ */ function(Config2) {
      Config2["ENABLED"] = "EXUpdatesEnabled";
      Config2["CHECK_ON_LAUNCH"] = "EXUpdatesCheckOnLaunch";
      Config2["LAUNCH_WAIT_MS"] = "EXUpdatesLaunchWaitMs";
      Config2["RUNTIME_VERSION"] = "EXUpdatesRuntimeVersion";
      Config2["UPDATE_URL"] = "EXUpdatesURL";
      Config2["UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY"] = "EXUpdatesRequestHeaders";
      Config2["UPDATES_HAS_EMBEDDED_UPDATE"] = "EXUpdatesHasEmbeddedUpdate";
      Config2["CODE_SIGNING_CERTIFICATE"] = "EXUpdatesCodeSigningCertificate";
      Config2["CODE_SIGNING_METADATA"] = "EXUpdatesCodeSigningMetadata";
      Config2["DISABLE_ANTI_BRICKING_MEASURES"] = "EXUpdatesDisableAntiBrickingMeasures";
      return Config2;
    }({});
    var withUpdates = (config) => {
      return (0, _withPlugins().withPlugins)(config, [withUpdatesPlist, withUpdatesNativeDebugPodfileProps]);
    };
    exports2.withUpdates = withUpdates;
    var withUpdatesNativeDebugPodfileProps = exports2.withUpdatesNativeDebugPodfileProps = (0, _BuildProperties().createBuildPodfilePropsConfigPlugin)([{
      propName: "updatesNativeDebug",
      propValueGetter: (config) => config?.updates?.useNativeDebug === true ? "true" : void 0
    }], "withUpdatesNativeDebugPodfileProps");
    var withUpdatesPlist = (config) => {
      return (0, _iosPlugins().withExpoPlist)(config, async (config2) => {
        const projectRoot = config2.modRequest.projectRoot;
        const expoUpdatesPackageVersion = (0, _Updates().getExpoUpdatesPackageVersion)(projectRoot);
        config2.modResults = await setUpdatesConfigAsync(projectRoot, config2, config2.modResults, expoUpdatesPackageVersion);
        return config2;
      });
    };
    async function setUpdatesConfigAsync(projectRoot, config, expoPlist, expoUpdatesPackageVersion) {
      const checkOnLaunch = (0, _Updates().getUpdatesCheckOnLaunch)(config, expoUpdatesPackageVersion);
      const timeout = (0, _Updates().getUpdatesTimeout)(config);
      const useEmbeddedUpdate = (0, _Updates().getUpdatesUseEmbeddedUpdate)(config);
      if (!useEmbeddedUpdate && timeout === 0 && checkOnLaunch !== "ALWAYS") {
        (0, _warnings().addWarningIOS)("updates.useEmbeddedUpdate", `updates.checkOnLaunch should be set to "ON_LOAD" and updates.fallbackToCacheTimeout should be set to a non-zero value when updates.useEmbeddedUpdate is set to false. This is because an update must be fetched on the initial launch, when no embedded update is available.`);
      }
      const newExpoPlist = {
        ...expoPlist,
        [Config.ENABLED]: (0, _Updates().getUpdatesEnabled)(config),
        [Config.CHECK_ON_LAUNCH]: checkOnLaunch,
        [Config.LAUNCH_WAIT_MS]: timeout
      };
      if (useEmbeddedUpdate) {
        delete newExpoPlist[Config.UPDATES_HAS_EMBEDDED_UPDATE];
      } else {
        newExpoPlist[Config.UPDATES_HAS_EMBEDDED_UPDATE] = false;
      }
      const updateUrl = (0, _Updates().getUpdateUrl)(config);
      if (updateUrl) {
        newExpoPlist[Config.UPDATE_URL] = updateUrl;
      } else {
        delete newExpoPlist[Config.UPDATE_URL];
      }
      const codeSigningCertificate = (0, _Updates().getUpdatesCodeSigningCertificate)(projectRoot, config);
      if (codeSigningCertificate) {
        newExpoPlist[Config.CODE_SIGNING_CERTIFICATE] = codeSigningCertificate;
      } else {
        delete newExpoPlist[Config.CODE_SIGNING_CERTIFICATE];
      }
      const codeSigningMetadata = (0, _Updates().getUpdatesCodeSigningMetadata)(config);
      if (codeSigningMetadata) {
        newExpoPlist[Config.CODE_SIGNING_METADATA] = codeSigningMetadata;
      } else {
        delete newExpoPlist[Config.CODE_SIGNING_METADATA];
      }
      const requestHeaders = (0, _Updates().getUpdatesRequestHeaders)(config);
      if (requestHeaders) {
        newExpoPlist[Config.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY] = requestHeaders;
      } else {
        delete newExpoPlist[Config.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY];
      }
      const disableAntiBrickingMeasures = (0, _Updates().getDisableAntiBrickingMeasures)(config);
      if (disableAntiBrickingMeasures) {
        newExpoPlist[Config.DISABLE_ANTI_BRICKING_MEASURES] = disableAntiBrickingMeasures;
      } else {
        delete newExpoPlist[Config.DISABLE_ANTI_BRICKING_MEASURES];
      }
      return await setVersionsConfigAsync(projectRoot, config, newExpoPlist);
    }
    async function setVersionsConfigAsync(projectRoot, config, expoPlist) {
      const newExpoPlist = {
        ...expoPlist
      };
      const runtimeVersion = await (0, _Updates().getRuntimeVersionNullableAsync)(projectRoot, config, "ios");
      if (!runtimeVersion && expoPlist[Config.RUNTIME_VERSION]) {
        throw new Error("A runtime version is set in your Expo.plist, but is missing from your Expo app config (app.json/app.config.js). Set runtimeVersion in your Expo app config or remove EXUpdatesRuntimeVersion from your Expo.plist.");
      }
      if (runtimeVersion) {
        delete newExpoPlist["EXUpdatesSDKVersion"];
        newExpoPlist[Config.RUNTIME_VERSION] = runtimeVersion;
      } else {
        delete newExpoPlist["EXUpdatesSDKVersion"];
        delete newExpoPlist[Config.RUNTIME_VERSION];
      }
      return newExpoPlist;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/UsesNonExemptEncryption.js
var require_UsesNonExemptEncryption = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/UsesNonExemptEncryption.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getUsesNonExemptEncryption = getUsesNonExemptEncryption;
    exports2.setUsesNonExemptEncryption = setUsesNonExemptEncryption;
    exports2.withUsesNonExemptEncryption = void 0;
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    var withUsesNonExemptEncryption = exports2.withUsesNonExemptEncryption = (0, _iosPlugins().createInfoPlistPluginWithPropertyGuard)(setUsesNonExemptEncryption, {
      infoPlistProperty: "ITSAppUsesNonExemptEncryption",
      expoConfigProperty: "ios.config.usesNonExemptEncryption"
    }, "withUsesNonExemptEncryption");
    function getUsesNonExemptEncryption(config) {
      return config?.ios?.config?.usesNonExemptEncryption ?? null;
    }
    function setUsesNonExemptEncryption(config, {
      ITSAppUsesNonExemptEncryption,
      ...infoPlist
    }) {
      const usesNonExemptEncryption = getUsesNonExemptEncryption(config);
      if (usesNonExemptEncryption === null) {
        return infoPlist;
      }
      return {
        ...infoPlist,
        ITSAppUsesNonExemptEncryption: usesNonExemptEncryption
      };
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/XcodeProjectFile.js
var require_XcodeProjectFile = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/XcodeProjectFile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createBuildSourceFile = createBuildSourceFile;
    exports2.withBuildSourceFile = void 0;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var withBuildSourceFile = (config, {
      filePath,
      contents,
      overwrite
    }) => {
      return (0, _iosPlugins().withXcodeProject)(config, (config2) => {
        const projectName = (0, _Xcodeproj().getProjectName)(config2.modRequest.projectRoot);
        config2.modResults = createBuildSourceFile({
          project: config2.modResults,
          nativeProjectRoot: config2.modRequest.platformProjectRoot,
          fileContents: contents,
          filePath: _path().default.join(projectName, filePath),
          overwrite
        });
        return config2;
      });
    };
    exports2.withBuildSourceFile = withBuildSourceFile;
    function createBuildSourceFile({
      project,
      nativeProjectRoot,
      filePath,
      fileContents,
      overwrite
    }) {
      const absoluteFilePath = _path().default.join(nativeProjectRoot, filePath);
      if (overwrite || !_fs().default.existsSync(absoluteFilePath)) {
        _fs().default.writeFileSync(absoluteFilePath, fileContents, "utf8");
      }
      const groupName = _path().default.dirname(filePath);
      if (!project.hasFile(filePath)) {
        project = (0, _Xcodeproj().addBuildSourceFileToGroup)({
          filepath: filePath,
          groupName,
          project
        });
      }
      return project;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/index.js
var require_ios = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Entitlements = exports2.DeviceFamily = exports2.DevelopmentTeam = exports2.BundleIdentifier = exports2.BuildScheme = exports2.BuildProperties = exports2.Bitcode = void 0;
    Object.defineProperty(exports2, "ExpoPlist", {
      enumerable: true,
      get: function() {
        return _IosConfig().ExpoPlist;
      }
    });
    exports2.Google = void 0;
    Object.defineProperty(exports2, "InfoPlist", {
      enumerable: true,
      get: function() {
        return _IosConfig().InfoPlist;
      }
    });
    exports2.XcodeUtils = exports2.XcodeProjectFile = exports2.Version = exports2.UsesNonExemptEncryption = exports2.Updates = exports2.Target = exports2.Scheme = exports2.RequiresFullScreen = exports2.ProvisioningProfile = exports2.PrivacyInfo = exports2.Permissions = exports2.Paths = exports2.Orientation = exports2.Name = exports2.Maps = exports2.Locales = void 0;
    function Bitcode() {
      const data = _interopRequireWildcard(require_Bitcode());
      Bitcode = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Bitcode", {
      enumerable: true,
      get: function() {
        return Bitcode();
      }
    });
    function BuildProperties() {
      const data = _interopRequireWildcard(require_BuildProperties2());
      BuildProperties = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "BuildProperties", {
      enumerable: true,
      get: function() {
        return BuildProperties();
      }
    });
    function BuildScheme() {
      const data = _interopRequireWildcard(require_BuildScheme());
      BuildScheme = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "BuildScheme", {
      enumerable: true,
      get: function() {
        return BuildScheme();
      }
    });
    function BundleIdentifier() {
      const data = _interopRequireWildcard(require_BundleIdentifier());
      BundleIdentifier = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "BundleIdentifier", {
      enumerable: true,
      get: function() {
        return BundleIdentifier();
      }
    });
    function DevelopmentTeam() {
      const data = _interopRequireWildcard(require_DevelopmentTeam());
      DevelopmentTeam = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "DevelopmentTeam", {
      enumerable: true,
      get: function() {
        return DevelopmentTeam();
      }
    });
    function DeviceFamily() {
      const data = _interopRequireWildcard(require_DeviceFamily());
      DeviceFamily = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "DeviceFamily", {
      enumerable: true,
      get: function() {
        return DeviceFamily();
      }
    });
    function Entitlements() {
      const data = _interopRequireWildcard(require_Entitlements());
      Entitlements = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Entitlements", {
      enumerable: true,
      get: function() {
        return Entitlements();
      }
    });
    function Google() {
      const data = _interopRequireWildcard(require_Google());
      Google = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Google", {
      enumerable: true,
      get: function() {
        return Google();
      }
    });
    function _IosConfig() {
      const data = require_IosConfig_types();
      _IosConfig = function() {
        return data;
      };
      return data;
    }
    function Locales() {
      const data = _interopRequireWildcard(require_Locales2());
      Locales = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Locales", {
      enumerable: true,
      get: function() {
        return Locales();
      }
    });
    function Maps() {
      const data = _interopRequireWildcard(require_Maps());
      Maps = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Maps", {
      enumerable: true,
      get: function() {
        return Maps();
      }
    });
    function Name() {
      const data = _interopRequireWildcard(require_Name2());
      Name = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function() {
        return Name();
      }
    });
    function Orientation() {
      const data = _interopRequireWildcard(require_Orientation2());
      Orientation = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Orientation", {
      enumerable: true,
      get: function() {
        return Orientation();
      }
    });
    function Paths() {
      const data = _interopRequireWildcard(require_Paths2());
      Paths = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Paths", {
      enumerable: true,
      get: function() {
        return Paths();
      }
    });
    function Permissions() {
      const data = _interopRequireWildcard(require_Permissions2());
      Permissions = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Permissions", {
      enumerable: true,
      get: function() {
        return Permissions();
      }
    });
    function PrivacyInfo() {
      const data = _interopRequireWildcard(require_PrivacyInfo());
      PrivacyInfo = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "PrivacyInfo", {
      enumerable: true,
      get: function() {
        return PrivacyInfo();
      }
    });
    function ProvisioningProfile() {
      const data = _interopRequireWildcard(require_ProvisioningProfile());
      ProvisioningProfile = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "ProvisioningProfile", {
      enumerable: true,
      get: function() {
        return ProvisioningProfile();
      }
    });
    function RequiresFullScreen() {
      const data = _interopRequireWildcard(require_RequiresFullScreen());
      RequiresFullScreen = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "RequiresFullScreen", {
      enumerable: true,
      get: function() {
        return RequiresFullScreen();
      }
    });
    function Scheme() {
      const data = _interopRequireWildcard(require_Scheme2());
      Scheme = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Scheme", {
      enumerable: true,
      get: function() {
        return Scheme();
      }
    });
    function Target() {
      const data = _interopRequireWildcard(require_Target());
      Target = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Target", {
      enumerable: true,
      get: function() {
        return Target();
      }
    });
    function Updates() {
      const data = _interopRequireWildcard(require_Updates3());
      Updates = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Updates", {
      enumerable: true,
      get: function() {
        return Updates();
      }
    });
    function UsesNonExemptEncryption() {
      const data = _interopRequireWildcard(require_UsesNonExemptEncryption());
      UsesNonExemptEncryption = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "UsesNonExemptEncryption", {
      enumerable: true,
      get: function() {
        return UsesNonExemptEncryption();
      }
    });
    function Version() {
      const data = _interopRequireWildcard(require_Version2());
      Version = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Version", {
      enumerable: true,
      get: function() {
        return Version();
      }
    });
    function XcodeProjectFile() {
      const data = _interopRequireWildcard(require_XcodeProjectFile());
      XcodeProjectFile = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "XcodeProjectFile", {
      enumerable: true,
      get: function() {
        return XcodeProjectFile();
      }
    });
    function XcodeUtils() {
      const data = _interopRequireWildcard(require_Xcodeproj());
      XcodeUtils = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "XcodeUtils", {
      enumerable: true,
      get: function() {
        return XcodeUtils();
      }
    });
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
  }
});

// node_modules/@expo/config-plugins/build/plugins/createBaseMod.js
var require_createBaseMod = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/createBaseMod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertModResults = assertModResults;
    exports2.createBaseMod = createBaseMod;
    exports2.createPlatformBaseMod = createPlatformBaseMod;
    exports2.provider = provider;
    exports2.withGeneratedBaseMods = withGeneratedBaseMods;
    function _debug() {
      const data = _interopRequireDefault(require_src());
      _debug = function() {
        return data;
      };
      return data;
    }
    function _withMod() {
      const data = require_withMod();
      _withMod = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var debug = (0, _debug().default)("expo:config-plugins:base-mods");
    function createBaseMod({
      methodName,
      platform,
      modName,
      getFilePath,
      read: read2,
      write,
      isIntrospective
    }) {
      const withUnknown = (config, _props) => {
        const props = _props || {};
        return (0, _withMod().withBaseMod)(config, {
          platform,
          mod: modName,
          skipEmptyMod: props.skipEmptyMod ?? true,
          saveToInternal: props.saveToInternal ?? false,
          isProvider: true,
          isIntrospective,
          async action({
            modRequest: {
              nextMod,
              ...modRequest
            },
            ...config2
          }) {
            try {
              let results = {
                ...config2,
                modRequest
              };
              const filePath = await getFilePath(results, props);
              debug(`mods.${platform}.${modName}: file path: ${filePath || "[skipped]"}`);
              const modResults = await read2(filePath, results, props);
              results = await nextMod({
                ...results,
                modResults,
                modRequest
              });
              assertModResults(results, modRequest.platform, modRequest.modName);
              await write(filePath, results, props);
              return results;
            } catch (error) {
              error.message = `[${platform}.${modName}]: ${methodName}: ${error.message}`;
              throw error;
            }
          }
        });
      };
      if (methodName) {
        Object.defineProperty(withUnknown, "name", {
          value: methodName
        });
      }
      return withUnknown;
    }
    function assertModResults(results, platformName, modName) {
      const ensuredResults = results;
      if (!ensuredResults || typeof ensuredResults !== "object" || !ensuredResults?.mods) {
        throw new Error(`Mod \`mods.${platformName}.${modName}\` evaluated to an object that is not a valid project config. Instead got: ${JSON.stringify(ensuredResults)}`);
      }
      return ensuredResults;
    }
    function upperFirst(name) {
      return name.charAt(0).toUpperCase() + name.slice(1);
    }
    function createPlatformBaseMod({
      modName,
      ...props
    }) {
      const methodName = `with${upperFirst(props.platform)}${upperFirst(modName)}BaseMod`;
      return createBaseMod({
        methodName,
        modName,
        ...props
      });
    }
    function provider(props) {
      return props;
    }
    function withGeneratedBaseMods(config, {
      platform,
      providers,
      ...props
    }) {
      return Object.entries(providers).reduce((config2, [modName, value]) => {
        const baseMod = createPlatformBaseMod({
          platform,
          modName,
          ...value
        });
        return baseMod(config2, props);
      }, config);
    }
  }
});

// node_modules/@expo/config-plugins/build/utils/sortObject.js
var require_sortObject = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/sortObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.reverseSortString = void 0;
    exports2.sortObjWithOrder = sortObjWithOrder;
    exports2.sortObject = sortObject;
    exports2.sortWithOrder = sortWithOrder;
    function sortObject(obj, compareFn) {
      return Object.keys(obj).sort(compareFn).reduce((acc, key3) => ({
        ...acc,
        [key3]: obj[key3]
      }), {});
    }
    function sortObjWithOrder(obj, order) {
      const sorted = sortWithOrder(Object.keys(obj), order);
      return sorted.reduce((acc, key3) => ({
        ...acc,
        [key3]: obj[key3]
      }), {});
    }
    function sortWithOrder(obj, order) {
      const groupOrder = [...new Set(order.concat(obj))];
      const sorted = [];
      while (groupOrder.length) {
        const key3 = groupOrder.shift();
        const index = obj.indexOf(key3);
        if (index > -1) {
          const [item] = obj.splice(index, 1);
          sorted.push(item);
        }
      }
      return sorted;
    }
    var reverseSortString = (a, b) => {
      if (a < b) return 1;
      if (a > b) return -1;
      return 0;
    };
    exports2.reverseSortString = reverseSortString;
  }
});

// node_modules/@expo/config-plugins/build/plugins/withAndroidBaseMods.js
var require_withAndroidBaseMods = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/withAndroidBaseMods.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAndroidModFileProviders = getAndroidModFileProviders;
    exports2.sortAndroidManifest = sortAndroidManifest;
    exports2.withAndroidBaseMods = withAndroidBaseMods;
    function _fs() {
      const data = require("fs");
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _createBaseMod() {
      const data = require_createBaseMod();
      _createBaseMod = function() {
        return data;
      };
      return data;
    }
    function _android() {
      const data = require_android();
      _android = function() {
        return data;
      };
      return data;
    }
    function _XML() {
      const data = require_XML();
      _XML = function() {
        return data;
      };
      return data;
    }
    function _sortObject() {
      const data = require_sortObject();
      _sortObject = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var {
      readFile,
      writeFile
    } = _fs().promises;
    function getAndroidManifestTemplate(config) {
      return (0, _XML().parseXMLAsync)(`
  <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="${config.android?.package ?? "com.placeholder.appid"}">

    <uses-permission android:name="android.permission.INTERNET"/>
    <!-- OPTIONAL PERMISSIONS, REMOVE WHATEVER YOU DO NOT NEED -->
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
    <uses-permission android:name="android.permission.VIBRATE"/>
    <!-- These require runtime permissions on M -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <!-- END OPTIONAL PERMISSIONS -->

    <queries>
      <!-- Support checking for http(s) links via the Linking API -->
      <intent>
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.BROWSABLE" />
        <data android:scheme="https" />
      </intent>
    </queries>

    <application android:name=".MainApplication" android:label="@string/app_name" android:icon="@mipmap/ic_launcher" android:roundIcon="@mipmap/ic_launcher_round" android:allowBackup="false" android:theme="@style/AppTheme" android:supportsRtl="true">
      <activity android:name=".MainActivity" android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|uiMode" android:launchMode="singleTask" android:windowSoftInputMode="adjustResize" android:theme="@style/Theme.App.SplashScreen" android:exported="true">
        <intent-filter>
          <action android:name="android.intent.action.MAIN"/>
          <category android:name="android.intent.category.LAUNCHER"/>
        </intent-filter>
      </activity>
    </application>
  </manifest>
  `);
    }
    function sortAndroidManifest(obj) {
      if (obj.manifest) {
        obj.manifest = (0, _sortObject().sortObject)(obj.manifest, _sortObject().reverseSortString);
        if (Array.isArray(obj.manifest["uses-permission"])) {
          obj.manifest["uses-permission"].sort((a, b) => {
            if (a.$["android:name"] < b.$["android:name"]) return -1;
            if (a.$["android:name"] > b.$["android:name"]) return 1;
            return 0;
          });
        }
        if (Array.isArray(obj.manifest.application)) {
          obj.manifest.application = obj.manifest.application.map((application) => {
            application = (0, _sortObject().sortObjWithOrder)(application, ["meta-data", "service", "activity"]);
            if (Array.isArray(application["meta-data"])) {
              application["meta-data"].sort((a, b) => {
                if (a.$["android:name"] < b.$["android:name"]) return -1;
                if (a.$["android:name"] > b.$["android:name"]) return 1;
                return 0;
              });
            }
            return application;
          });
        }
      }
      return obj;
    }
    var defaultProviders = {
      dangerous: (0, _createBaseMod().provider)({
        getFilePath() {
          return "";
        },
        async read() {
          return {
            filePath: "",
            modResults: {}
          };
        },
        async write() {
        }
      }),
      finalized: (0, _createBaseMod().provider)({
        getFilePath() {
          return "";
        },
        async read() {
          return {
            filePath: "",
            modResults: {}
          };
        },
        async write() {
        }
      }),
      // Append a rule to supply gradle.properties data to mods on `mods.android.gradleProperties`
      manifest: (0, _createBaseMod().provider)({
        isIntrospective: true,
        getFilePath({
          modRequest: {
            platformProjectRoot
          }
        }) {
          return _path().default.join(platformProjectRoot, "app/src/main/AndroidManifest.xml");
        },
        async read(filePath, config) {
          try {
            return await _android().Manifest.readAndroidManifestAsync(filePath);
          } catch (error) {
            if (!config.modRequest.introspect) {
              throw error;
            }
          }
          return await getAndroidManifestTemplate(config);
        },
        async write(filePath, {
          modResults,
          modRequest: {
            introspect
          }
        }) {
          if (introspect) return;
          await _android().Manifest.writeAndroidManifestAsync(filePath, sortAndroidManifest(modResults));
        }
      }),
      // Append a rule to supply gradle.properties data to mods on `mods.android.gradleProperties`
      gradleProperties: (0, _createBaseMod().provider)({
        isIntrospective: true,
        getFilePath({
          modRequest: {
            platformProjectRoot
          }
        }) {
          return _path().default.join(platformProjectRoot, "gradle.properties");
        },
        async read(filePath, config) {
          try {
            return await _android().Properties.parsePropertiesFile(await readFile(filePath, "utf8"));
          } catch (error) {
            if (!config.modRequest.introspect) {
              throw error;
            }
          }
          return [];
        },
        async write(filePath, {
          modResults,
          modRequest: {
            introspect
          }
        }) {
          if (introspect) return;
          await writeFile(filePath, _android().Properties.propertiesListToString(modResults));
        }
      }),
      // Append a rule to supply strings.xml data to mods on `mods.android.strings`
      strings: (0, _createBaseMod().provider)({
        isIntrospective: true,
        async getFilePath({
          modRequest: {
            projectRoot,
            introspect
          }
        }) {
          try {
            return await _android().Strings.getProjectStringsXMLPathAsync(projectRoot);
          } catch (error) {
            if (!introspect) {
              throw error;
            }
          }
          return "";
        },
        async read(filePath, config) {
          try {
            return await _android().Resources.readResourcesXMLAsync({
              path: filePath
            });
          } catch (error) {
            if (!config.modRequest.introspect) {
              throw error;
            }
          }
          return {
            resources: {}
          };
        },
        async write(filePath, {
          modResults,
          modRequest: {
            introspect
          }
        }) {
          if (introspect) return;
          await (0, _XML().writeXMLAsync)({
            path: filePath,
            xml: modResults
          });
        }
      }),
      colors: (0, _createBaseMod().provider)({
        isIntrospective: true,
        async getFilePath({
          modRequest: {
            projectRoot,
            introspect
          }
        }) {
          try {
            return await _android().Colors.getProjectColorsXMLPathAsync(projectRoot);
          } catch (error) {
            if (!introspect) {
              throw error;
            }
          }
          return "";
        },
        async read(filePath, {
          modRequest: {
            introspect
          }
        }) {
          try {
            return await _android().Resources.readResourcesXMLAsync({
              path: filePath
            });
          } catch (error) {
            if (!introspect) {
              throw error;
            }
          }
          return {
            resources: {}
          };
        },
        async write(filePath, {
          modResults,
          modRequest: {
            introspect
          }
        }) {
          if (introspect) return;
          await (0, _XML().writeXMLAsync)({
            path: filePath,
            xml: modResults
          });
        }
      }),
      colorsNight: (0, _createBaseMod().provider)({
        isIntrospective: true,
        async getFilePath({
          modRequest: {
            projectRoot,
            introspect
          }
        }) {
          try {
            return await _android().Colors.getProjectColorsXMLPathAsync(projectRoot, {
              kind: "values-night"
            });
          } catch (error) {
            if (!introspect) {
              throw error;
            }
          }
          return "";
        },
        async read(filePath, config) {
          try {
            return await _android().Resources.readResourcesXMLAsync({
              path: filePath
            });
          } catch (error) {
            if (!config.modRequest.introspect) {
              throw error;
            }
          }
          return {
            resources: {}
          };
        },
        async write(filePath, {
          modResults,
          modRequest: {
            introspect
          }
        }) {
          if (introspect) return;
          await (0, _XML().writeXMLAsync)({
            path: filePath,
            xml: modResults
          });
        }
      }),
      styles: (0, _createBaseMod().provider)({
        isIntrospective: true,
        async getFilePath({
          modRequest: {
            projectRoot,
            introspect
          }
        }) {
          try {
            return await _android().Styles.getProjectStylesXMLPathAsync(projectRoot);
          } catch (error) {
            if (!introspect) {
              throw error;
            }
          }
          return "";
        },
        async read(filePath, config) {
          let styles = {
            resources: {}
          };
          try {
            styles = await _android().Resources.readResourcesXMLAsync({
              path: filePath,
              fallback: `<?xml version="1.0" encoding="utf-8"?><resources xmlns:tools="http://schemas.android.com/tools"></resources>`
            });
          } catch (error) {
            if (!config.modRequest.introspect) {
              throw error;
            }
          }
          if (!styles.resources.$) {
            styles.resources.$ = {};
          }
          if (!styles.resources.$?.["xmlns:tools"]) {
            styles.resources.$["xmlns:tools"] = "http://schemas.android.com/tools";
          }
          return styles;
        },
        async write(filePath, {
          modResults,
          modRequest: {
            introspect
          }
        }) {
          if (introspect) return;
          await (0, _XML().writeXMLAsync)({
            path: filePath,
            xml: modResults
          });
        }
      }),
      projectBuildGradle: (0, _createBaseMod().provider)({
        getFilePath({
          modRequest: {
            projectRoot
          }
        }) {
          return _android().Paths.getProjectBuildGradleFilePath(projectRoot);
        },
        async read(filePath) {
          return _android().Paths.getFileInfo(filePath);
        },
        async write(filePath, {
          modResults: {
            contents
          }
        }) {
          await writeFile(filePath, contents);
        }
      }),
      settingsGradle: (0, _createBaseMod().provider)({
        getFilePath({
          modRequest: {
            projectRoot
          }
        }) {
          return _android().Paths.getSettingsGradleFilePath(projectRoot);
        },
        async read(filePath) {
          return _android().Paths.getFileInfo(filePath);
        },
        async write(filePath, {
          modResults: {
            contents
          }
        }) {
          await writeFile(filePath, contents);
        }
      }),
      appBuildGradle: (0, _createBaseMod().provider)({
        getFilePath({
          modRequest: {
            projectRoot
          }
        }) {
          return _android().Paths.getAppBuildGradleFilePath(projectRoot);
        },
        async read(filePath) {
          return _android().Paths.getFileInfo(filePath);
        },
        async write(filePath, {
          modResults: {
            contents
          }
        }) {
          await writeFile(filePath, contents);
        }
      }),
      mainActivity: (0, _createBaseMod().provider)({
        getFilePath({
          modRequest: {
            projectRoot
          }
        }) {
          return _android().Paths.getProjectFilePath(projectRoot, "MainActivity");
        },
        async read(filePath) {
          return _android().Paths.getFileInfo(filePath);
        },
        async write(filePath, {
          modResults: {
            contents
          }
        }) {
          await writeFile(filePath, contents);
        }
      }),
      mainApplication: (0, _createBaseMod().provider)({
        getFilePath({
          modRequest: {
            projectRoot
          }
        }) {
          return _android().Paths.getProjectFilePath(projectRoot, "MainApplication");
        },
        async read(filePath) {
          return _android().Paths.getFileInfo(filePath);
        },
        async write(filePath, {
          modResults: {
            contents
          }
        }) {
          await writeFile(filePath, contents);
        }
      })
    };
    function withAndroidBaseMods(config, {
      providers,
      ...props
    } = {}) {
      return (0, _createBaseMod().withGeneratedBaseMods)(config, {
        ...props,
        platform: "android",
        providers: providers ?? getAndroidModFileProviders()
      });
    }
    function getAndroidModFileProviders() {
      return defaultProviders;
    }
  }
});

// node_modules/@expo/config-plugins/build/ios/utils/getInfoPlistPath.js
var require_getInfoPlistPath = __commonJS({
  "node_modules/@expo/config-plugins/build/ios/utils/getInfoPlistPath.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getInfoPlistPathFromPbxproj = getInfoPlistPathFromPbxproj;
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _Target() {
      const data = require_Target();
      _Target = function() {
        return data;
      };
      return data;
    }
    function getInfoPlistPathFromPbxproj(projectRootOrProject, {
      targetName,
      buildConfiguration = "Release"
    } = {}) {
      const project = (0, _Xcodeproj().resolvePathOrProject)(projectRootOrProject);
      if (!project) {
        return null;
      }
      const xcBuildConfiguration = (0, _Target().getXCBuildConfigurationFromPbxproj)(project, {
        targetName,
        buildConfiguration
      });
      if (!xcBuildConfiguration) {
        return null;
      }
      return sanitizeInfoPlistBuildProperty(xcBuildConfiguration.buildSettings.INFOPLIST_FILE);
    }
    function sanitizeInfoPlistBuildProperty(infoPlist) {
      return infoPlist?.replace(/"/g, "").replace("$(SRCROOT)", "") ?? null;
    }
  }
});

// node_modules/@expo/config-plugins/build/plugins/withIosBaseMods.js
var require_withIosBaseMods = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/withIosBaseMods.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getIosModFileProviders = getIosModFileProviders;
    exports2.withIosBaseMods = withIosBaseMods;
    function _jsonFile() {
      const data = _interopRequireDefault(require_JsonFile());
      _jsonFile = function() {
        return data;
      };
      return data;
    }
    function _plist() {
      const data = _interopRequireDefault(require_build3());
      _plist = function() {
        return data;
      };
      return data;
    }
    function _assert() {
      const data = _interopRequireDefault(require("assert"));
      _assert = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = _interopRequireWildcard(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _xcode() {
      const data = _interopRequireDefault(require_xcode());
      _xcode = function() {
        return data;
      };
      return data;
    }
    function _createBaseMod() {
      const data = require_createBaseMod();
      _createBaseMod = function() {
        return data;
      };
      return data;
    }
    function _ios() {
      const data = require_ios();
      _ios = function() {
        return data;
      };
      return data;
    }
    function _Entitlements() {
      const data = require_Entitlements();
      _Entitlements = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _getInfoPlistPath() {
      const data = require_getInfoPlistPath();
      _getInfoPlistPath = function() {
        return data;
      };
      return data;
    }
    function _modules() {
      const data = require_modules();
      _modules = function() {
        return data;
      };
      return data;
    }
    function _sortObject() {
      const data = require_sortObject();
      _sortObject = function() {
        return data;
      };
      return data;
    }
    function _warnings() {
      const data = require_warnings();
      _warnings = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var {
      readFile,
      writeFile
    } = _fs().promises;
    function getEntitlementsPlistTemplate() {
      return {};
    }
    function getInfoPlistTemplate() {
      return {
        CFBundleDevelopmentRegion: "$(DEVELOPMENT_LANGUAGE)",
        CFBundleExecutable: "$(EXECUTABLE_NAME)",
        CFBundleIdentifier: "$(PRODUCT_BUNDLE_IDENTIFIER)",
        CFBundleName: "$(PRODUCT_NAME)",
        CFBundlePackageType: "$(PRODUCT_BUNDLE_PACKAGE_TYPE)",
        CFBundleInfoDictionaryVersion: "6.0",
        CFBundleSignature: "????",
        LSMinimumSystemVersion: "12.0",
        LSRequiresIPhoneOS: true,
        NSAppTransportSecurity: {
          NSAllowsArbitraryLoads: true,
          NSExceptionDomains: {
            localhost: {
              NSExceptionAllowsInsecureHTTPLoads: true
            }
          }
        },
        UILaunchStoryboardName: "SplashScreen",
        UIRequiredDeviceCapabilities: ["armv7"],
        UIViewControllerBasedStatusBarAppearance: false,
        UIStatusBarStyle: "UIStatusBarStyleDefault",
        CADisableMinimumFrameDurationOnPhone: true
      };
    }
    var defaultProviders = {
      dangerous: (0, _createBaseMod().provider)({
        getFilePath() {
          return "";
        },
        async read() {
          return {};
        },
        async write() {
        }
      }),
      finalized: (0, _createBaseMod().provider)({
        getFilePath() {
          return "";
        },
        async read() {
          return {};
        },
        async write() {
        }
      }),
      // Append a rule to supply AppDelegate data to mods on `mods.ios.appDelegate`
      appDelegate: (0, _createBaseMod().provider)({
        getFilePath({
          modRequest: {
            projectRoot
          }
        }) {
          return _ios().Paths.getAppDelegateFilePath(projectRoot);
        },
        async read(filePath) {
          return _ios().Paths.getFileInfo(filePath);
        },
        async write(filePath, {
          modResults: {
            contents
          }
        }) {
          await writeFile(filePath, contents);
        }
      }),
      // Append a rule to supply Expo.plist data to mods on `mods.ios.expoPlist`
      expoPlist: (0, _createBaseMod().provider)({
        isIntrospective: true,
        getFilePath({
          modRequest: {
            platformProjectRoot,
            projectName
          }
        }) {
          const supportingDirectory = _path().default.join(platformProjectRoot, projectName, "Supporting");
          return _path().default.resolve(supportingDirectory, "Expo.plist");
        },
        async read(filePath, {
          modRequest: {
            introspect
          }
        }) {
          try {
            return _plist().default.parse(await readFile(filePath, "utf8"));
          } catch (error) {
            if (introspect) {
              return {};
            }
            throw error;
          }
        },
        async write(filePath, {
          modResults,
          modRequest: {
            introspect
          }
        }) {
          if (introspect) {
            return;
          }
          await writeFile(filePath, _plist().default.build((0, _sortObject().sortObject)(modResults)));
        }
      }),
      // Append a rule to supply .xcodeproj data to mods on `mods.ios.xcodeproj`
      xcodeproj: (0, _createBaseMod().provider)({
        getFilePath({
          modRequest: {
            projectRoot
          }
        }) {
          return _ios().Paths.getPBXProjectPath(projectRoot);
        },
        async read(filePath) {
          const project = _xcode().default.project(filePath);
          project.parseSync();
          return project;
        },
        async write(filePath, {
          modResults
        }) {
          await writeFile(filePath, modResults.writeSync());
        }
      }),
      // Append a rule to supply Info.plist data to mods on `mods.ios.infoPlist`
      infoPlist: (0, _createBaseMod().provider)({
        isIntrospective: true,
        async getFilePath(config) {
          let project = null;
          try {
            project = (0, _Xcodeproj().getPbxproj)(config.modRequest.projectRoot);
          } catch {
          }
          if (project) {
            const infoPlistBuildProperty = (0, _getInfoPlistPath().getInfoPlistPathFromPbxproj)(project);
            if (infoPlistBuildProperty) {
              const infoPlistPath = _path().default.join(
                //: myapp/ios
                config.modRequest.platformProjectRoot,
                //: MyApp/Info.plist
                infoPlistBuildProperty
              );
              if ((0, _modules().fileExists)(infoPlistPath)) {
                return infoPlistPath;
              }
              (0, _warnings().addWarningIOS)("mods.ios.infoPlist", `Info.plist file linked to Xcode project does not exist: ${infoPlistPath}`);
            } else {
              (0, _warnings().addWarningIOS)("mods.ios.infoPlist", "Failed to find Info.plist linked to Xcode project.");
            }
          }
          try {
            return await _ios().Paths.getInfoPlistPath(config.modRequest.projectRoot);
          } catch (error) {
            if (config.modRequest.introspect) {
              return "";
            }
            throw error;
          }
        },
        async read(filePath, config) {
          if (!config.ios) config.ios = {};
          if (!config.ios.infoPlist) config.ios.infoPlist = {};
          let modResults;
          try {
            const contents = await readFile(filePath, "utf8");
            (0, _assert().default)(contents, "Info.plist is empty");
            modResults = _plist().default.parse(contents);
          } catch (error) {
            if (!config.modRequest.introspect) {
              throw error;
            }
            modResults = getInfoPlistTemplate();
          }
          config.ios.infoPlist = {
            ...modResults || {},
            ...config.ios.infoPlist
          };
          return config.ios.infoPlist;
        },
        async write(filePath, config) {
          if (!config.ios) {
            config.ios = {};
          }
          config.ios.infoPlist = config.modResults;
          if (config.modRequest.introspect) {
            return;
          }
          await writeFile(filePath, _plist().default.build((0, _sortObject().sortObject)(config.modResults)));
        }
      }),
      // Append a rule to supply .entitlements data to mods on `mods.ios.entitlements`
      entitlements: (0, _createBaseMod().provider)({
        isIntrospective: true,
        async getFilePath(config) {
          try {
            (0, _Entitlements().ensureApplicationTargetEntitlementsFileConfigured)(config.modRequest.projectRoot);
            return _ios().Entitlements.getEntitlementsPath(config.modRequest.projectRoot) ?? "";
          } catch (error) {
            if (config.modRequest.introspect) {
              return "";
            }
            throw error;
          }
        },
        async read(filePath, config) {
          let modResults;
          try {
            if (!config.modRequest.ignoreExistingNativeFiles && _fs().default.existsSync(filePath)) {
              const contents = await readFile(filePath, "utf8");
              (0, _assert().default)(contents, "Entitlements plist is empty");
              modResults = _plist().default.parse(contents);
            } else {
              modResults = getEntitlementsPlistTemplate();
            }
          } catch (error) {
            if (!config.modRequest.introspect) {
              throw error;
            }
            modResults = getEntitlementsPlistTemplate();
          }
          if (!config.ios) config.ios = {};
          if (!config.ios.entitlements) config.ios.entitlements = {};
          config.ios.entitlements = {
            ...modResults || {},
            ...config.ios.entitlements
          };
          return config.ios.entitlements;
        },
        async write(filePath, config) {
          if (!config.ios) {
            config.ios = {};
          }
          config.ios.entitlements = config.modResults;
          if (config.modRequest.introspect) {
            return;
          }
          await writeFile(filePath, _plist().default.build((0, _sortObject().sortObject)(config.modResults)));
        }
      }),
      podfile: (0, _createBaseMod().provider)({
        getFilePath({
          modRequest: {
            projectRoot
          }
        }) {
          return _ios().Paths.getPodfilePath(projectRoot);
        },
        // @ts-expect-error
        async read(filePath) {
          return _ios().Paths.getFileInfo(filePath);
        },
        async write(filePath, {
          modResults: {
            contents
          }
        }) {
          await writeFile(filePath, contents);
        }
      }),
      // Append a rule to supply Podfile.properties.json data to mods on `mods.ios.podfileProperties`
      podfileProperties: (0, _createBaseMod().provider)({
        isIntrospective: true,
        getFilePath({
          modRequest: {
            platformProjectRoot
          }
        }) {
          return _path().default.resolve(platformProjectRoot, "Podfile.properties.json");
        },
        async read(filePath) {
          let results = {};
          try {
            results = await _jsonFile().default.readAsync(filePath);
          } catch {
          }
          return results;
        },
        async write(filePath, {
          modResults,
          modRequest: {
            introspect
          }
        }) {
          if (introspect) {
            return;
          }
          await _jsonFile().default.writeAsync(filePath, modResults);
        }
      })
    };
    function withIosBaseMods(config, {
      providers,
      ...props
    } = {}) {
      return (0, _createBaseMod().withGeneratedBaseMods)(config, {
        ...props,
        platform: "ios",
        providers: providers ?? getIosModFileProviders()
      });
    }
    function getIosModFileProviders() {
      return defaultProviders;
    }
  }
});

// node_modules/@expo/config-plugins/build/utils/history.js
var require_history = __commonJS({
  "node_modules/@expo/config-plugins/build/utils/history.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addHistoryItem = addHistoryItem;
    exports2.getHistoryItem = getHistoryItem;
    function getHistoryItem(config, name) {
      return config._internal?.pluginHistory?.[name] ?? null;
    }
    function addHistoryItem(config, item) {
      if (!config._internal) {
        config._internal = {};
      }
      if (!config._internal.pluginHistory) {
        config._internal.pluginHistory = {};
      }
      if (!item.version) {
        item.version = "UNVERSIONED";
      }
      config._internal.pluginHistory[item.name] = item;
      return config;
    }
  }
});

// node_modules/@expo/config-plugins/build/Plugin.types.js
var require_Plugin_types = __commonJS({
  "node_modules/@expo/config-plugins/build/Plugin.types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "AndroidManifest", {
      enumerable: true,
      get: function() {
        return _Manifest().AndroidManifest;
      }
    });
    Object.defineProperty(exports2, "ExpoPlist", {
      enumerable: true,
      get: function() {
        return _IosConfig().ExpoPlist;
      }
    });
    Object.defineProperty(exports2, "InfoPlist", {
      enumerable: true,
      get: function() {
        return _IosConfig().InfoPlist;
      }
    });
    Object.defineProperty(exports2, "XcodeProject", {
      enumerable: true,
      get: function() {
        return _xcode().XcodeProject;
      }
    });
    function _xcode() {
      const data = require_xcode();
      _xcode = function() {
        return data;
      };
      return data;
    }
    function _Manifest() {
      const data = require_Manifest();
      _Manifest = function() {
        return data;
      };
      return data;
    }
    function _IosConfig() {
      const data = require_IosConfig_types();
      _IosConfig = function() {
        return data;
      };
      return data;
    }
  }
});

// node_modules/@expo/config-plugins/build/plugins/withRunOnce.js
var require_withRunOnce = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/withRunOnce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createRunOncePlugin = createRunOncePlugin;
    exports2.withRunOnce = void 0;
    function _history() {
      const data = require_history();
      _history = function() {
        return data;
      };
      return data;
    }
    var withRunOnce = (config, {
      plugin,
      name,
      version
    }) => {
      if ((0, _history().getHistoryItem)(config, name)) {
        return config;
      }
      config = (0, _history().addHistoryItem)(config, {
        name,
        version
      });
      return plugin(config);
    };
    exports2.withRunOnce = withRunOnce;
    function createRunOncePlugin(plugin, name, version) {
      return (config, props) => {
        return withRunOnce(config, {
          plugin: (config2) => plugin(config2, props),
          name,
          version
        });
      };
    }
  }
});

// node_modules/@expo/config-plugins/build/plugins/withFinalizedMod.js
var require_withFinalizedMod = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/withFinalizedMod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.withFinalizedMod = void 0;
    function _withMod() {
      const data = require_withMod();
      _withMod = function() {
        return data;
      };
      return data;
    }
    var withFinalizedMod = (config, [platform, action]) => {
      return (0, _withMod().withMod)(config, {
        platform,
        mod: "finalized",
        action
      });
    };
    exports2.withFinalizedMod = withFinalizedMod;
  }
});

// node_modules/@expo/config-plugins/build/plugins/mod-compiler.js
var require_mod_compiler = __commonJS({
  "node_modules/@expo/config-plugins/build/plugins/mod-compiler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.compileModsAsync = compileModsAsync;
    exports2.evalModsAsync = evalModsAsync;
    exports2.sortMods = sortMods;
    exports2.withDefaultBaseMods = withDefaultBaseMods;
    exports2.withIntrospectionBaseMods = withIntrospectionBaseMods;
    function _debug() {
      const data = _interopRequireDefault(require_src());
      _debug = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _createBaseMod() {
      const data = require_createBaseMod();
      _createBaseMod = function() {
        return data;
      };
      return data;
    }
    function _withAndroidBaseMods() {
      const data = require_withAndroidBaseMods();
      _withAndroidBaseMods = function() {
        return data;
      };
      return data;
    }
    function _withIosBaseMods() {
      const data = require_withIosBaseMods();
      _withIosBaseMods = function() {
        return data;
      };
      return data;
    }
    function _Xcodeproj() {
      const data = require_Xcodeproj();
      _Xcodeproj = function() {
        return data;
      };
      return data;
    }
    function _errors() {
      const data = require_errors();
      _errors = function() {
        return data;
      };
      return data;
    }
    function Warnings() {
      const data = _interopRequireWildcard(require_warnings());
      Warnings = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var debug = (0, _debug().default)("expo:config-plugins:mod-compiler");
    function withDefaultBaseMods(config, props = {}) {
      config = (0, _withIosBaseMods().withIosBaseMods)(config, props);
      config = (0, _withAndroidBaseMods().withAndroidBaseMods)(config, props);
      return config;
    }
    function withIntrospectionBaseMods(config, props = {}) {
      config = (0, _withIosBaseMods().withIosBaseMods)(config, {
        saveToInternal: true,
        // This writing optimization can be skipped since we never write in introspection mode.
        // Including empty mods will ensure that all mods get introspected.
        skipEmptyMod: false,
        ...props
      });
      config = (0, _withAndroidBaseMods().withAndroidBaseMods)(config, {
        saveToInternal: true,
        skipEmptyMod: false,
        ...props
      });
      if (config.mods) {
        for (const platform of Object.keys(config.mods)) {
          for (const key3 of Object.keys(config.mods[platform] || {})) {
            if (!config.mods[platform]?.[key3]?.isIntrospective) {
              debug(`removing non-idempotent mod: ${platform}.${key3}`);
              delete config.mods[platform]?.[key3];
            }
          }
        }
      }
      return config;
    }
    async function compileModsAsync(config, props) {
      if (props.introspect === true) {
        config = withIntrospectionBaseMods(config);
      } else {
        config = withDefaultBaseMods(config);
      }
      return await evalModsAsync(config, props);
    }
    function sortMods(commands, precedences2) {
      const seen = /* @__PURE__ */ new Set();
      const dedupedCommands = commands.filter(([key3]) => {
        const duplicate = seen.has(key3);
        seen.add(key3);
        return !duplicate;
      });
      return dedupedCommands.sort(([keyA], [keyB]) => {
        const precedenceA = precedences2[keyA] || 0;
        const precedenceB = precedences2[keyB] || 0;
        return precedenceA - precedenceB;
      });
    }
    function getRawClone({
      mods,
      ...config
    }) {
      return Object.freeze(JSON.parse(JSON.stringify(config)));
    }
    var precedences = {
      ios: {
        // dangerous runs first
        dangerous: -2,
        // run the XcodeProject mod second because many plugins attempt to read from it.
        xcodeproj: -1,
        // put the finalized mod at the last
        finalized: 1
      }
    };
    async function evalModsAsync(config, {
      projectRoot,
      introspect,
      platforms,
      assertMissingModProviders,
      ignoreExistingNativeFiles = false
    }) {
      const modRawConfig = getRawClone(config);
      for (const [platformName, platform] of Object.entries(config.mods ?? {})) {
        if (platforms && !platforms.includes(platformName)) {
          debug(`skip platform: ${platformName}`);
          continue;
        }
        let entries = Object.entries(platform);
        if (entries.length) {
          entries = sortMods(entries, precedences[platformName] ?? {
            dangerous: -1,
            finalized: 1
          });
          debug(`run in order: ${entries.map(([name]) => name).join(", ")}`);
          const platformProjectRoot = _path().default.join(projectRoot, platformName);
          const projectName = platformName === "ios" ? (0, _Xcodeproj().getHackyProjectName)(projectRoot, config) : void 0;
          for (const [modName, mod] of entries) {
            const modRequest = {
              projectRoot,
              projectName,
              platformProjectRoot,
              platform: platformName,
              modName,
              introspect: !!introspect,
              ignoreExistingNativeFiles
            };
            if (!mod.isProvider) {
              const errorMessage = `Initial base modifier for "${platformName}.${modName}" is not a provider and therefore will not provide modResults to child mods`;
              if (assertMissingModProviders !== false) {
                throw new (_errors()).PluginError(errorMessage, "MISSING_PROVIDER");
              } else {
                Warnings().addWarningForPlatform(platformName, `${platformName}.${modName}`, `Skipping: Initial base modifier for "${platformName}.${modName}" is not a provider and therefore will not provide modResults to child mods. This may be due to an outdated version of Expo CLI.`);
                continue;
              }
            }
            const results = await mod({
              ...config,
              modResults: null,
              modRequest,
              modRawConfig
            });
            config = (0, _createBaseMod().assertModResults)(results, platformName, modName);
            delete config.modResults;
            delete config.modRequest;
            delete config.modRawConfig;
          }
        }
      }
      return config;
    }
  }
});

// node_modules/@expo/config-plugins/build/index.js
var require_build4 = __commonJS({
  "node_modules/@expo/config-plugins/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _exportNames = {
      BaseMods: true,
      AndroidConfig: true,
      IOSConfig: true,
      XML: true,
      History: true,
      WarningAggregator: true,
      Updates: true,
      withPlugins: true,
      withRunOnce: true,
      createRunOncePlugin: true,
      withDangerousMod: true,
      withFinalizedMod: true,
      withMod: true,
      withBaseMod: true,
      withAppDelegate: true,
      withInfoPlist: true,
      withEntitlementsPlist: true,
      withExpoPlist: true,
      withXcodeProject: true,
      withPodfile: true,
      withPodfileProperties: true,
      withAndroidManifest: true,
      withStringsXml: true,
      withAndroidColors: true,
      withAndroidColorsNight: true,
      withAndroidStyles: true,
      withMainActivity: true,
      withMainApplication: true,
      withProjectBuildGradle: true,
      withAppBuildGradle: true,
      withSettingsGradle: true,
      withGradleProperties: true,
      withStaticPlugin: true,
      compileModsAsync: true,
      withDefaultBaseMods: true,
      evalModsAsync: true,
      PluginError: true
    };
    exports2.IOSConfig = exports2.History = exports2.BaseMods = exports2.AndroidConfig = void 0;
    Object.defineProperty(exports2, "PluginError", {
      enumerable: true,
      get: function() {
        return _errors().PluginError;
      }
    });
    exports2.XML = exports2.WarningAggregator = exports2.Updates = void 0;
    Object.defineProperty(exports2, "compileModsAsync", {
      enumerable: true,
      get: function() {
        return _modCompiler().compileModsAsync;
      }
    });
    Object.defineProperty(exports2, "createRunOncePlugin", {
      enumerable: true,
      get: function() {
        return _withRunOnce().createRunOncePlugin;
      }
    });
    Object.defineProperty(exports2, "evalModsAsync", {
      enumerable: true,
      get: function() {
        return _modCompiler().evalModsAsync;
      }
    });
    Object.defineProperty(exports2, "withAndroidColors", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withAndroidColors;
      }
    });
    Object.defineProperty(exports2, "withAndroidColorsNight", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withAndroidColorsNight;
      }
    });
    Object.defineProperty(exports2, "withAndroidManifest", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withAndroidManifest;
      }
    });
    Object.defineProperty(exports2, "withAndroidStyles", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withAndroidStyles;
      }
    });
    Object.defineProperty(exports2, "withAppBuildGradle", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withAppBuildGradle;
      }
    });
    Object.defineProperty(exports2, "withAppDelegate", {
      enumerable: true,
      get: function() {
        return _iosPlugins().withAppDelegate;
      }
    });
    Object.defineProperty(exports2, "withBaseMod", {
      enumerable: true,
      get: function() {
        return _withMod().withBaseMod;
      }
    });
    Object.defineProperty(exports2, "withDangerousMod", {
      enumerable: true,
      get: function() {
        return _withDangerousMod().withDangerousMod;
      }
    });
    Object.defineProperty(exports2, "withDefaultBaseMods", {
      enumerable: true,
      get: function() {
        return _modCompiler().withDefaultBaseMods;
      }
    });
    Object.defineProperty(exports2, "withEntitlementsPlist", {
      enumerable: true,
      get: function() {
        return _iosPlugins().withEntitlementsPlist;
      }
    });
    Object.defineProperty(exports2, "withExpoPlist", {
      enumerable: true,
      get: function() {
        return _iosPlugins().withExpoPlist;
      }
    });
    Object.defineProperty(exports2, "withFinalizedMod", {
      enumerable: true,
      get: function() {
        return _withFinalizedMod().withFinalizedMod;
      }
    });
    Object.defineProperty(exports2, "withGradleProperties", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withGradleProperties;
      }
    });
    Object.defineProperty(exports2, "withInfoPlist", {
      enumerable: true,
      get: function() {
        return _iosPlugins().withInfoPlist;
      }
    });
    Object.defineProperty(exports2, "withMainActivity", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withMainActivity;
      }
    });
    Object.defineProperty(exports2, "withMainApplication", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withMainApplication;
      }
    });
    Object.defineProperty(exports2, "withMod", {
      enumerable: true,
      get: function() {
        return _withMod().withMod;
      }
    });
    Object.defineProperty(exports2, "withPlugins", {
      enumerable: true,
      get: function() {
        return _withPlugins().withPlugins;
      }
    });
    Object.defineProperty(exports2, "withPodfile", {
      enumerable: true,
      get: function() {
        return _iosPlugins().withPodfile;
      }
    });
    Object.defineProperty(exports2, "withPodfileProperties", {
      enumerable: true,
      get: function() {
        return _iosPlugins().withPodfileProperties;
      }
    });
    Object.defineProperty(exports2, "withProjectBuildGradle", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withProjectBuildGradle;
      }
    });
    Object.defineProperty(exports2, "withRunOnce", {
      enumerable: true,
      get: function() {
        return _withRunOnce().withRunOnce;
      }
    });
    Object.defineProperty(exports2, "withSettingsGradle", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withSettingsGradle;
      }
    });
    Object.defineProperty(exports2, "withStaticPlugin", {
      enumerable: true,
      get: function() {
        return _withStaticPlugin().withStaticPlugin;
      }
    });
    Object.defineProperty(exports2, "withStringsXml", {
      enumerable: true,
      get: function() {
        return _androidPlugins().withStringsXml;
      }
    });
    Object.defineProperty(exports2, "withXcodeProject", {
      enumerable: true,
      get: function() {
        return _iosPlugins().withXcodeProject;
      }
    });
    function AndroidConfig2() {
      const data = _interopRequireWildcard(require_android());
      AndroidConfig2 = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "AndroidConfig", {
      enumerable: true,
      get: function() {
        return AndroidConfig2();
      }
    });
    function IOSConfig() {
      const data = _interopRequireWildcard(require_ios());
      IOSConfig = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "IOSConfig", {
      enumerable: true,
      get: function() {
        return IOSConfig();
      }
    });
    function _createBaseMod() {
      const data = require_createBaseMod();
      _createBaseMod = function() {
        return data;
      };
      return data;
    }
    function _withAndroidBaseMods() {
      const data = require_withAndroidBaseMods();
      _withAndroidBaseMods = function() {
        return data;
      };
      return data;
    }
    function _withIosBaseMods() {
      const data = require_withIosBaseMods();
      _withIosBaseMods = function() {
        return data;
      };
      return data;
    }
    function XML() {
      const data = _interopRequireWildcard(require_XML());
      XML = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "XML", {
      enumerable: true,
      get: function() {
        return XML();
      }
    });
    function History() {
      const data = _interopRequireWildcard(require_history());
      History = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "History", {
      enumerable: true,
      get: function() {
        return History();
      }
    });
    function WarningAggregator() {
      const data = _interopRequireWildcard(require_warnings());
      WarningAggregator = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "WarningAggregator", {
      enumerable: true,
      get: function() {
        return WarningAggregator();
      }
    });
    function _Updates() {
      const data = _interopRequireWildcard(require_Updates());
      _Updates = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "Updates", {
      enumerable: true,
      get: function() {
        return _Updates();
      }
    });
    var _Plugin = require_Plugin_types();
    Object.keys(_Plugin).forEach(function(key3) {
      if (key3 === "default" || key3 === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key3)) return;
      if (key3 in exports2 && exports2[key3] === _Plugin[key3]) return;
      Object.defineProperty(exports2, key3, {
        enumerable: true,
        get: function() {
          return _Plugin[key3];
        }
      });
    });
    function _withPlugins() {
      const data = require_withPlugins();
      _withPlugins = function() {
        return data;
      };
      return data;
    }
    function _withRunOnce() {
      const data = require_withRunOnce();
      _withRunOnce = function() {
        return data;
      };
      return data;
    }
    function _withDangerousMod() {
      const data = require_withDangerousMod();
      _withDangerousMod = function() {
        return data;
      };
      return data;
    }
    function _withFinalizedMod() {
      const data = require_withFinalizedMod();
      _withFinalizedMod = function() {
        return data;
      };
      return data;
    }
    function _withMod() {
      const data = require_withMod();
      _withMod = function() {
        return data;
      };
      return data;
    }
    function _iosPlugins() {
      const data = require_ios_plugins();
      _iosPlugins = function() {
        return data;
      };
      return data;
    }
    function _androidPlugins() {
      const data = require_android_plugins();
      _androidPlugins = function() {
        return data;
      };
      return data;
    }
    function _withStaticPlugin() {
      const data = require_withStaticPlugin();
      _withStaticPlugin = function() {
        return data;
      };
      return data;
    }
    function _modCompiler() {
      const data = require_mod_compiler();
      _modCompiler = function() {
        return data;
      };
      return data;
    }
    function _errors() {
      const data = require_errors();
      _errors = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    var BaseMods = exports2.BaseMods = {
      withGeneratedBaseMods: _createBaseMod().withGeneratedBaseMods,
      provider: _createBaseMod().provider,
      withAndroidBaseMods: _withAndroidBaseMods().withAndroidBaseMods,
      getAndroidModFileProviders: _withAndroidBaseMods().getAndroidModFileProviders,
      withIosBaseMods: _withIosBaseMods().withIosBaseMods,
      getIosModFileProviders: _withIosBaseMods().getIosModFileProviders
    };
  }
});

// modules/expo-glance-widget/plugins/index.ts
var index_exports = {};
__export(index_exports, {
  DEFAULT_OPTIONS: () => DEFAULT_OPTIONS,
  DEFAULT_WIDGET_MERGE_CONFIG: () => DEFAULT_WIDGET_MERGE_CONFIG,
  FileUtils: () => FileUtils,
  Logger: () => Logger,
  SyncWidget: () => SyncWidget,
  withComposeProjectLevelDependancyPlugin: () => withComposeProjectLevelDependancyPlugin_default,
  withExpoGlanceWidgets: () => withPlugins_default,
  withGlanceAppLevelGradleConfig: () => withGlanceAppLevelGradleConfig,
  withGlanceWidgetFiles: () => withGlanceWidgetFiles,
  withMainApplicationWorkManager: () => withMainApplicationWorkManager,
  withWakatimeWorkManager: () => withWakatimeWorkManager,
  withWakatimeWorkerErrorHandling: () => withWakatimeWorkerErrorHandling
});
module.exports = __toCommonJS(index_exports);

// modules/expo-glance-widget/plugins/withPlugins.ts
var import_fs10 = __toESM(require("fs"));
var import_path7 = __toESM(require("path"));

// modules/expo-glance-widget/plugins/utils/fs.ts
var fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var FileUtils = class {
  /**
   * Copy file safely, creating destination directory if needed
   * @param src - Source file path
   * @param dest - Destination file path
   */
  static copyFileSync(src, dest) {
    const destDir = import_path.default.dirname(dest);
    if (!fs.existsSync(destDir)) {
      fs.mkdirSync(destDir, { recursive: true });
    }
    fs.copyFileSync(src, dest);
  }
  /**
   * Check if path exists and is a directory
   * @param filePath - Path to check
   * @returns True if path exists and is a directory
   */
  static isDirectory(filePath) {
    try {
      return fs.lstatSync(filePath).isDirectory();
    } catch {
      return false;
    }
  }
  /**
   * Ensure directory exists, creating it recursively if needed
   * @param dirPath - Directory path to ensure
   */
  static ensureDir(dirPath) {
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }
  /**
   * Check if file exists
   * @param filePath - File path to check
   * @returns True if file exists
   */
  static exists(filePath) {
    return fs.existsSync(filePath);
  }
  /**
   * Read file content as UTF-8 string
   * @param filePath - Path to file
   * @returns File content as string
   */
  static readFileSync(filePath) {
    return fs.readFileSync(filePath, "utf-8");
  }
  /**
   * Write string content to file
   * @param filePath - Path to file
   * @param content - Content to write
   */
  static writeFileSync(filePath, content) {
    fs.writeFileSync(filePath, content, "utf-8");
  }
  /**
   * Read directory contents
   * @param dirPath - Directory path
   * @returns Array of file/directory names
   */
  static readdirSync(dirPath) {
    return fs.readdirSync(dirPath);
  }
  /**
   * Recursively copy files and directories with callback support
   * @param sourceDir - Source directory
   * @param destDir - Destination directory
   * @param onSuccess - Callback called when a file is successfully copied
   * @param onSkip - Callback called when a file is skipped (already exists)
   * @param filter - Optional filter function to exclude certain paths
   */
  static copyRecursively(sourceDir, destDir, onSuccess, onSkip, filter) {
    this.ensureDir(destDir);
    const items = this.readdirSync(sourceDir);
    items.forEach((item) => {
      const sourcePath = import_path.default.join(sourceDir, item);
      const destPath = import_path.default.join(destDir, item);
      const isDir = this.isDirectory(sourcePath);
      if (filter && !filter(item, isDir)) {
        return;
      }
      if (isDir) {
        this.copyRecursively(sourcePath, destPath, onSuccess, onSkip, filter);
      } else {
        if (this.exists(destPath)) {
          onSkip?.(destPath, sourcePath);
          return;
        }
        this.copyFileSync(sourcePath, destPath);
        onSuccess?.(destPath);
      }
    });
  }
};
var Logger = class {
  tag;
  constructor(tag) {
    this.tag = tag;
  }
  formatMessage(message) {
    return this.tag ? `[${this.tag}] ${message}` : message;
  }
  // Instance methods with tag support
  info(message) {
    console.log(`\u2139\uFE0F  ${this.formatMessage(message)}`);
  }
  success(message) {
    console.log(`\u2705 ${this.formatMessage(message)}`);
  }
  warn(message) {
    console.warn(`\u26A0\uFE0F  ${this.formatMessage(message)}`);
  }
  error(message) {
    console.error(`\u274C ${this.formatMessage(message)}`);
  }
  debug(message) {
    console.log(`\u{1F50D} ${this.formatMessage(message)}`);
  }
  file(message) {
    console.log(`\u{1F4C1} ${this.formatMessage(message)}`);
  }
  mobile(message) {
    console.log(`\u{1F4F1} ${this.formatMessage(message)}`);
  }
  manifest(message) {
    console.log(`\u{1F4C4} ${this.formatMessage(message)}`);
  }
  // Static methods (backward compatibility)
  static info(message) {
    console.log(`\u2139\uFE0F  ${message}`);
  }
  static success(message) {
    console.log(`\u2705 ${message}`);
  }
  static warn(message) {
    console.warn(`\u26A0\uFE0F  ${message}`);
  }
  static error(message) {
    console.error(`\u274C ${message}`);
  }
  static debug(message) {
    console.log(`\u{1F50D} ${message}`);
  }
  static file(message) {
    console.log(`\u{1F4C1} ${message}`);
  }
  static mobile(message) {
    console.log(`\u{1F4F1} ${message}`);
  }
  static manifest(message) {
    console.log(`\u{1F4C4} ${message}`);
  }
};

// modules/expo-glance-widget/plugins/withComposeProjectLevelDependancyPlugin.ts
var import_config_plugins = require("expo/config-plugins");
var withComposeProjectLevelDependancyPlugin = (config, options) => {
  return (0, import_config_plugins.withProjectBuildGradle)(config, (config2) => {
    const buildGradleContent = config2.modResults.contents;
    if (!buildGradleContent.includes("compose-compiler-gradle-plugin")) {
      const dependenciesRegex = /(dependencies\s*\{[^}]*)/;
      const match = buildGradleContent.match(dependenciesRegex);
      if (match) {
        const newDependencies = match[1] + "\n    // Add the new Compose compiler plugin for Kotlin 2.0\n    classpath('org.jetbrains.kotlin:compose-compiler-gradle-plugin:2.0.0')";
        config2.modResults.contents = buildGradleContent.replace(
          dependenciesRegex,
          newDependencies
        );
      }
    }
    if (!buildGradleContent.includes("kotlin-serialization")) {
      const dependenciesRegex = /(dependencies\s*\{[^}]*)/;
      const match = config2.modResults.contents.match(dependenciesRegex);
      if (match) {
        const newDependencies = match[1] + "\n    // Add Kotlin serialization plugin\n    classpath('org.jetbrains.kotlin:kotlin-serialization:2.0.0')";
        config2.modResults.contents = config2.modResults.contents.replace(
          dependenciesRegex,
          newDependencies
        );
      }
    }
    if (!buildGradleContent.includes("kotlin-gradle-plugin:2.0.0")) {
      config2.modResults.contents = config2.modResults.contents.replace(
        /classpath\(['"]org\.jetbrains\.kotlin:kotlin-gradle-plugin[^'"]*['"]\)/,
        "classpath('org.jetbrains.kotlin:kotlin-gradle-plugin:2.0.0')"
      );
    }
    return config2;
  });
};
var withComposeProjectLevelDependancyPlugin_default = withComposeProjectLevelDependancyPlugin;

// modules/expo-glance-widget/plugins/withGlanceAppLevelGradleConfig.ts
var import_config_plugins2 = __toESM(require_build4());
var withGlanceAppLevelGradleConfig = (config) => {
  return (0, import_config_plugins2.withAppBuildGradle)(config, (config2) => {
    if (config2.modResults.language === "groovy") {
      config2.modResults.contents = addGlanceBuildConfiguration(config2.modResults.contents);
    }
    return config2;
  });
};
function addGlanceBuildConfiguration(buildGradle) {
  const hasKotlinPlugin = buildGradle.includes('apply plugin: "org.jetbrains.kotlin.android"');
  const hasComposePlugin = buildGradle.includes('apply plugin: "org.jetbrains.kotlin.plugin.compose"');
  const hasSerializationPlugin = buildGradle.includes('apply plugin: "org.jetbrains.kotlin.plugin.serialization"');
  const hasBuildFeatures = buildGradle.includes("buildFeatures") && buildGradle.includes("compose true");
  const hasGlanceDeps = buildGradle.includes("androidx.glance:glance-appwidget");
  let modifiedGradle = buildGradle;
  if (!hasKotlinPlugin || !hasComposePlugin || !hasSerializationPlugin) {
    const pluginInsertPoint = modifiedGradle.indexOf('apply plugin: "com.facebook.react"');
    if (pluginInsertPoint !== -1) {
      const insertAfter = modifiedGradle.indexOf("\n", pluginInsertPoint) + 1;
      let pluginsToAdd = "";
      if (!hasKotlinPlugin) {
        pluginsToAdd += 'apply plugin: "org.jetbrains.kotlin.android"\n';
      }
      if (!hasComposePlugin) {
        pluginsToAdd += 'apply plugin: "org.jetbrains.kotlin.plugin.compose"\n';
      }
      if (!hasSerializationPlugin) {
        pluginsToAdd += 'apply plugin: "org.jetbrains.kotlin.plugin.serialization"\n';
      }
      modifiedGradle = modifiedGradle.slice(0, insertAfter) + pluginsToAdd + modifiedGradle.slice(insertAfter);
    }
  }
  if (!hasBuildFeatures) {
    const androidBlockMatch = modifiedGradle.match(/android\s*\{/);
    if (androidBlockMatch) {
      const androidStart = androidBlockMatch.index + androidBlockMatch[0].length;
      const namespaceMatch = modifiedGradle.slice(androidStart).match(/namespace\s+['"][^'"]+['"]/);
      const defaultConfigMatch = modifiedGradle.slice(androidStart).match(/defaultConfig\s*\{[^}]*\}/);
      let insertPoint;
      if (namespaceMatch) {
        insertPoint = androidStart + namespaceMatch.index + namespaceMatch[0].length;
      } else if (defaultConfigMatch) {
        insertPoint = androidStart + defaultConfigMatch.index + defaultConfigMatch[0].length;
      } else {
        insertPoint = androidStart;
      }
      const buildFeaturesConfig = `
    
    buildFeatures {
        compose true
    }`;
      modifiedGradle = modifiedGradle.slice(0, insertPoint) + buildFeaturesConfig + modifiedGradle.slice(insertPoint);
    }
  }
  if (!hasGlanceDeps) {
    const depsMatch = modifiedGradle.match(/dependencies\s*\{/);
    if (depsMatch) {
      const depsStart = depsMatch.index + depsMatch[0].length;
      const glanceDependencies = `
    // Compose BOM for version management
    implementation platform('androidx.compose:compose-bom:2024.02.00')
    
    // Core Compose dependencies
    implementation 'androidx.compose.runtime:runtime'
    implementation 'androidx.compose.ui:ui'
    implementation 'androidx.compose.ui:ui-tooling-preview'
    implementation 'androidx.compose.material3:material3'
    implementation 'androidx.compose.ui:ui-unit'
    
    // Required for WorkManager
    implementation 'androidx.work:work-runtime-ktx:2.9.0'
    
    // Jetpack Glance dependencies
    // For AppWidgets support
    implementation 'androidx.glance:glance-appwidget:1.1.1'
    // For interop APIs with Material 3
    implementation 'androidx.glance:glance-material3:1.1.1'
    // For interop APIs with Material 2
    implementation 'androidx.glance:glance-material:1.1.1'
    
    // Ktor for networking
    implementation 'io.ktor:ktor-client-android:2.3.8'
    implementation 'io.ktor:ktor-client-content-negotiation:2.3.8'
    implementation 'io.ktor:ktor-serialization-kotlinx-json:2.3.8'
    implementation 'io.ktor:ktor-client-logging:2.3.8'
    
    // Kotlinx Serialization for JSON parsing
    implementation 'org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3'
    
    // Kotlin Coroutines
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3'
    
    // DataStore for preferences - ensure this is the latest stable version
    implementation 'androidx.datastore:datastore-preferences:1.1.1'
    
    // JSON parsing for widget configuration (fallback)
    implementation 'com.google.code.gson:gson:2.10.1'
`;
      modifiedGradle = modifiedGradle.slice(0, depsStart) + glanceDependencies + modifiedGradle.slice(depsStart);
    }
  }
  return modifiedGradle;
}

// modules/expo-glance-widget/plugins/withGlanceWidgetFiles.ts
var import_config_plugins3 = __toESM(require_build4());

// modules/expo-glance-widget/plugins/utils/widgetSync.ts
var import_path6 = __toESM(require("path"));

// modules/expo-glance-widget/plugins/utils/resourceSync.ts
var import_path2 = __toESM(require("path"));

// modules/expo-glance-widget/plugins/utils/xml.ts
var XmlUtils = class {
  /**
   * Merges two XML files, combining their content intelligently
   * @param sourcePath - Path to the source XML file
   * @param targetPath - Path to the target XML file to merge into
   * @param strategy - Merge strategy: 'append', 'replace', or 'smart'
   * @returns True if merge was successful
   */
  static mergeXmlFiles(sourcePath, targetPath, strategy = "smart") {
    try {
      if (!FileUtils.exists(sourcePath)) {
        Logger.warn(`Source XML file not found: ${sourcePath}`);
        return false;
      }
      const sourceContent = FileUtils.readFileSync(sourcePath);
      if (!FileUtils.exists(targetPath)) {
        FileUtils.writeFileSync(targetPath, sourceContent);
        Logger.success(`Created XML file: ${targetPath}`);
        return true;
      }
      const targetContent = FileUtils.readFileSync(targetPath);
      if (this.isStringXml(sourceContent) && this.isStringXml(targetContent)) {
        return this.mergeStringXml(sourceContent, targetContent, targetPath);
      } else if (this.isColorXml(sourceContent) && this.isColorXml(targetContent)) {
        return this.mergeColorXml(sourceContent, targetContent, targetPath);
      } else if (this.isDimensXml(sourceContent) && this.isDimensXml(targetContent)) {
        return this.mergeDimensXml(sourceContent, targetContent, targetPath);
      } else if (this.isStyleXml(sourceContent) && this.isStyleXml(targetContent)) {
        return this.mergeStyleXml(sourceContent, targetContent, targetPath);
      } else {
        return this.mergeGenericXml(sourceContent, targetContent, targetPath, "append");
      }
    } catch (error) {
      Logger.error(`Error merging XML files: ${error}`);
      return false;
    }
  }
  /**
   * Merges string resources XML files
   * @param sourceContent - Content of source strings.xml
   * @param targetContent - Content of target strings.xml
   * @param targetPath - Path to write merged content
   * @returns True if successful
   */
  static mergeStringXml(sourceContent, targetContent, targetPath) {
    try {
      const sourceStrings = this.extractStringResources(sourceContent);
      const targetStrings = this.extractStringResources(targetContent);
      const mergedStrings = { ...targetStrings, ...sourceStrings };
      const xmlHeader = '<?xml version="1.0" encoding="utf-8"?>';
      const resourcesOpen = "<resources>";
      const resourcesClose = "</resources>";
      const stringEntries = Object.entries(mergedStrings).map(([name, value]) => {
        const translatable = value.translatable !== void 0 ? ` translatable="${value.translatable}"` : "";
        return `  <string name="${name}"${translatable}>${value.content}</string>`;
      });
      const mergedContent = [
        xmlHeader,
        resourcesOpen,
        ...stringEntries,
        resourcesClose
      ].join("\n");
      FileUtils.writeFileSync(targetPath, mergedContent);
      Logger.success(`Merged ${Object.keys(sourceStrings).length} string resources into ${targetPath}`);
      return true;
    } catch (error) {
      Logger.error(`Error merging string XML: ${error}`);
      return false;
    }
  }
  /**
   * Merges color resources XML files
   * @param sourceContent - Content of source colors.xml
   * @param targetContent - Content of target colors.xml
   * @param targetPath - Path to write merged content
   * @returns True if successful
   */
  static mergeColorXml(sourceContent, targetContent, targetPath) {
    try {
      const sourceColors = this.extractColorResources(sourceContent);
      const targetColors = this.extractColorResources(targetContent);
      const mergedColors = { ...targetColors, ...sourceColors };
      const xmlHeader = '<?xml version="1.0" encoding="utf-8"?>';
      const resourcesOpen = "<resources>";
      const resourcesClose = "</resources>";
      const colorEntries = Object.entries(mergedColors).map(([name, value]) => {
        return `  <color name="${name}">${value}</color>`;
      });
      const mergedContent = [
        xmlHeader,
        resourcesOpen,
        ...colorEntries,
        resourcesClose
      ].join("\n");
      FileUtils.writeFileSync(targetPath, mergedContent);
      Logger.success(`Merged ${Object.keys(sourceColors).length} color resources into ${targetPath}`);
      return true;
    } catch (error) {
      Logger.error(`Error merging color XML: ${error}`);
      return false;
    }
  }
  /**
   * Merges dimension resources XML files
   * @param sourceContent - Content of source dimens.xml
   * @param targetContent - Content of target dimens.xml
   * @param targetPath - Path to write merged content
   * @returns True if successful
   */
  static mergeDimensXml(sourceContent, targetContent, targetPath) {
    try {
      const sourceDimens = this.extractDimensResources(sourceContent);
      const targetDimens = this.extractDimensResources(targetContent);
      const mergedDimens = { ...targetDimens, ...sourceDimens };
      const xmlHeader = '<?xml version="1.0" encoding="utf-8"?>';
      const resourcesOpen = "<resources>";
      const resourcesClose = "</resources>";
      const dimenEntries = Object.entries(mergedDimens).map(([name, value]) => {
        return `  <dimen name="${name}">${value}</dimen>`;
      });
      const mergedContent = [
        xmlHeader,
        resourcesOpen,
        ...dimenEntries,
        resourcesClose
      ].join("\n");
      FileUtils.writeFileSync(targetPath, mergedContent);
      Logger.success(`Merged ${Object.keys(sourceDimens).length} dimension resources into ${targetPath}`);
      return true;
    } catch (error) {
      Logger.error(`Error merging dimension XML: ${error}`);
      return false;
    }
  }
  /**
   * Merges style resources XML files
   * @param sourceContent - Content of source styles.xml
   * @param targetContent - Content of target styles.xml
   * @param targetPath - Path to write merged content
   * @returns True if successful
   */
  static mergeStyleXml(sourceContent, targetContent, targetPath) {
    try {
      const sourceStyles = this.extractStyleResources(sourceContent);
      const targetStyles = this.extractStyleResources(targetContent);
      const mergedStyles = { ...targetStyles, ...sourceStyles };
      const xmlHeader = '<?xml version="1.0" encoding="utf-8"?>';
      const resourcesOpen = "<resources>";
      const resourcesClose = "</resources>";
      const styleEntries = Object.entries(mergedStyles).map(([name, style]) => {
        const parentAttr = style.parent ? ` parent="${style.parent}"` : "";
        const items = style.items.map((item) => `    <item name="${item.name}">${item.value}</item>`).join("\n");
        return `  <style name="${name}"${parentAttr}>
${items}
  </style>`;
      });
      const mergedContent = [
        xmlHeader,
        resourcesOpen,
        ...styleEntries,
        resourcesClose
      ].join("\n");
      FileUtils.writeFileSync(targetPath, mergedContent);
      Logger.success(`Merged ${Object.keys(sourceStyles).length} style resources into ${targetPath}`);
      return true;
    } catch (error) {
      Logger.error(`Error merging style XML: ${error}`);
      return false;
    }
  }
  /**
   * Generic XML merge for unknown types
   * @param sourceContent - Source XML content
   * @param targetContent - Target XML content
   * @param targetPath - Path to write merged content
   * @param strategy - Merge strategy
   * @returns True if successful
   */
  static mergeGenericXml(sourceContent, targetContent, targetPath, strategy) {
    try {
      let mergedContent;
      if (strategy === "replace") {
        mergedContent = sourceContent;
        Logger.info(`Replaced XML content in ${targetPath}`);
      } else {
        const targetRoot = this.extractRootTag(targetContent);
        const sourceRoot = this.extractRootTag(sourceContent);
        if (targetRoot && sourceRoot && targetRoot.tagName === sourceRoot.tagName) {
          const mergedInnerContent = targetRoot.innerContent + "\n" + sourceRoot.innerContent;
          mergedContent = `<?xml version="1.0" encoding="utf-8"?>
<${targetRoot.tagName}${targetRoot.attributes}>
${mergedInnerContent}
</${targetRoot.tagName}>`;
          Logger.info(`Appended XML content to ${targetPath}`);
        } else {
          mergedContent = sourceContent;
          Logger.warn(`Could not parse XML structure, replacing content in ${targetPath}`);
        }
      }
      FileUtils.writeFileSync(targetPath, mergedContent);
      return true;
    } catch (error) {
      Logger.error(`Error in generic XML merge: ${error}`);
      return false;
    }
  }
  /**
   * Extracts string resources from strings.xml content
   */
  static extractStringResources(content) {
    const strings = {};
    const stringRegex = /<string\s+name=["']([^"']+)["'](?:\s+translatable=["']([^"']+)["'])?\s*>([^<]*)<\/string>/g;
    let match;
    while ((match = stringRegex.exec(content)) !== null) {
      const [, name, translatable, value] = match;
      strings[name] = {
        content: value,
        ...translatable && { translatable }
      };
    }
    return strings;
  }
  /**
   * Extracts color resources from colors.xml content
   */
  static extractColorResources(content) {
    const colors = {};
    const colorRegex = /<color\s+name=["']([^"']+)["']\s*>([^<]*)<\/color>/g;
    let match;
    while ((match = colorRegex.exec(content)) !== null) {
      const [, name, value] = match;
      colors[name] = value;
    }
    return colors;
  }
  /**
   * Extracts dimension resources from dimens.xml content
   */
  static extractDimensResources(content) {
    const dimens = {};
    const dimenRegex = /<dimen\s+name=["']([^"']+)["']\s*>([^<]*)<\/dimen>/g;
    let match;
    while ((match = dimenRegex.exec(content)) !== null) {
      const [, name, value] = match;
      dimens[name] = value;
    }
    return dimens;
  }
  /**
   * Extracts style resources from styles.xml content
   */
  static extractStyleResources(content) {
    const styles = {};
    const styleRegex = /<style\s+name=["']([^"']+)["'](?:\s+parent=["']([^"']+)["'])?\s*>([\s\S]*?)<\/style>/g;
    let match;
    while ((match = styleRegex.exec(content)) !== null) {
      const [, name, parent, innerContent] = match;
      const items = [];
      const itemRegex = /<item\s+name=["']([^"']+)["']\s*>([^<]*)<\/item>/g;
      let itemMatch;
      while ((itemMatch = itemRegex.exec(innerContent)) !== null) {
        const [, itemName, itemValue] = itemMatch;
        items.push({ name: itemName, value: itemValue });
      }
      styles[name] = {
        ...parent && { parent },
        items
      };
    }
    return styles;
  }
  /**
   * Extracts root tag information from XML content
   */
  static extractRootTag(content) {
    const rootRegex = /<([^>\s]+)([^>]*)>([\s\S]*)<\/\1>/;
    const match = content.match(rootRegex);
    if (match) {
      return {
        tagName: match[1],
        attributes: match[2],
        innerContent: match[3].trim()
      };
    }
    return null;
  }
  /**
   * Checks if XML content is a strings resource file
   */
  static isStringXml(content) {
    return content.includes("<string") && content.includes("<resources");
  }
  /**
   * Checks if XML content is a colors resource file
   */
  static isColorXml(content) {
    return content.includes("<color") && content.includes("<resources");
  }
  /**
   * Checks if XML content is a dimensions resource file
   */
  static isDimensXml(content) {
    return content.includes("<dimen") && content.includes("<resources");
  }
  /**
   * Checks if XML content is a styles resource file
   */
  static isStyleXml(content) {
    return content.includes("<style") && content.includes("<resources");
  }
};

// modules/expo-glance-widget/plugins/utils/resourceSync.ts
var ResourceSync = class {
  /**
  * Syncs resource files to default location
  * @param projectRoot - Root directory of the Expo project
  * @param customResPath - Custom path to resources (can be relative or absolute)
  * @param defaultResPath - Default path for resources
  */
  static syncToDefaults(projectRoot, customResPath, defaultResPath) {
    Logger.info(`

==================== Syncing resources ====================

`);
    const resolvedSource = this.resolveResourcePath(projectRoot, customResPath);
    if (!resolvedSource) {
      Logger.warn(`Custom resources directory not found: ${customResPath}`);
      return;
    }
    const defaultDir = import_path2.default.join(projectRoot, defaultResPath);
    Logger.file(`Syncing resources to ${defaultResPath} directory...`);
    const filter = (itemName, isDirectory) => {
      if (isDirectory && itemName.startsWith("mipmap")) {
        Logger.warn(`Skipping mipmap directory during sync (conflicts with Expo icons): ${itemName}`);
        return false;
      }
      return true;
    };
    FileUtils.copyRecursively(resolvedSource, defaultDir, (targetPath) => {
      Logger.success(`Synced resource: ${import_path2.default.relative(projectRoot, targetPath)}`);
    }, (targetPath, sourcePath) => {
      if (import_path2.default.extname(targetPath) === ".xml") {
        const merged = XmlUtils.mergeXmlFiles(sourcePath, targetPath, "smart");
        if (merged) {
          Logger.success(`Merged XML resource during sync: ${import_path2.default.relative(projectRoot, targetPath)}`);
        } else {
          Logger.warn(`Could not merge XML file during sync, skipping: ${import_path2.default.relative(projectRoot, targetPath)}`);
        }
      } else {
        Logger.warn(`Resource file already exists during sync, skipping: ${import_path2.default.relative(projectRoot, targetPath)}`);
      }
    }, filter);
  }
  /**
   * Copies resource files to Android build directory
   * @param projectRoot - Root directory of the Expo project
   * @param platformRoot - Root directory of the Android platform
   * @param resPath - Path to the resources directory (can be relative or absolute)
   */
  static copyToBuild(projectRoot, platformRoot, resPath) {
    Logger.info(`

==================== Copying resources to build directory ====================

`);
    const resolvedSource = this.resolveResourcePath(projectRoot, resPath);
    if (!resolvedSource) {
      Logger.warn(`Resources directory not found: ${resPath}`);
      return;
    }
    const destinationResDir = import_path2.default.join(platformRoot, "app/src/main/res");
    Logger.file(`Copying resources from ${resPath}...`);
    const filter = (itemName, isDirectory) => {
      if (isDirectory && itemName.startsWith("mipmap")) {
        Logger.warn(`Skipping mipmap directory during build copy (conflicts with Expo icons): ${itemName}`);
        return false;
      }
      return true;
    };
    FileUtils.copyRecursively(resolvedSource, destinationResDir, (targetPath) => {
      Logger.success(`Copying resource: ${import_path2.default.relative(destinationResDir, targetPath)}`);
    }, (targetPath, sourcePath) => {
      if (import_path2.default.extname(targetPath) === ".xml") {
        const merged = XmlUtils.mergeXmlFiles(sourcePath, targetPath, "smart");
        if (merged) {
          Logger.success(`Merged XML resource: ${import_path2.default.relative(destinationResDir, targetPath)}`);
        } else {
          Logger.warn(`Could not merge XML file, skipping: ${import_path2.default.relative(destinationResDir, targetPath)}`);
        }
      } else {
        Logger.warn(`Resource file already exists, skipping: ${import_path2.default.relative(destinationResDir, targetPath)}`);
      }
    }, filter);
  }
  /**
   * Resolves resource path - handles both directory paths with robust validation
   * @param projectRoot - Root directory of the Expo project
   * @param resPath - Path to resource directory (can be relative or absolute)
   * @returns Resolved path to a valid resource directory, or null if not found
   */
  static resolveResourcePath(projectRoot, resPath) {
    const isAbsolutePath = import_path2.default.isAbsolute(resPath);
    const fullPath = isAbsolutePath ? resPath : import_path2.default.join(projectRoot, resPath);
    Logger.debug(`Resolving resource path: ${fullPath} (${isAbsolutePath ? "absolute" : "relative"})`);
    if (FileUtils.exists(fullPath) && FileUtils.isDirectory(fullPath)) {
      if (this.isValidResourceDirectory(fullPath)) {
        Logger.debug(`Found valid resource directory: ${fullPath}`);
        return fullPath;
      } else {
        Logger.warn(`Directory exists but is not a valid resource directory: ${fullPath}`);
        return null;
      }
    }
    Logger.warn(`Resource directory not found: ${fullPath}`);
    return null;
  }
  /**
   * Validates if a directory is a legitimate Android resources directory
   * @param dirPath - Path to the directory to validate
   * @returns True if the directory is a valid resource directory
   */
  static isValidResourceDirectory(dirPath) {
    try {
      const items = FileUtils.readdirSync(dirPath);
      const resourceDirPatterns = [
        /^drawable/,
        /^layout/,
        /^values/,
        /^mipmap/,
        /^raw/,
        /^xml/,
        /^color/,
        /^string/
      ];
      const hasResourceDirs = items.some(
        (item) => resourceDirPatterns.some((pattern) => pattern.test(item))
      );
      const hasXmlFiles = items.some((item) => item.endsWith(".xml"));
      return hasResourceDirs || hasXmlFiles;
    } catch {
      return false;
    }
  }
};

// modules/expo-glance-widget/plugins/utils/syncWidget.ts
var import_path3 = __toESM(require("path"));
var import_xml2js = require("xml2js");
var DEFAULT_WIDGET_MERGE_CONFIG = {
  elementsToMerge: ["receiver", "uses-permission", "service", "activity"],
  mergeApplicationElements: true,
  mergeManifestElements: true,
  customMergeRules: {
    "uses-permission": (existing, incoming) => {
      const existingNames = new Set(
        existing.map((p) => p.$?.["android:name"]).filter(Boolean)
      );
      const uniqueIncoming = incoming.filter(
        (p) => !existingNames.has(p.$?.["android:name"])
      );
      return [...existing, ...uniqueIncoming];
    },
    "receiver": (existing, incoming) => {
      const existingNames = new Set(
        existing.map((r) => r.$?.["android:name"]).filter(Boolean)
      );
      const uniqueIncoming = incoming.filter(
        (r) => !existingNames.has(r.$?.["android:name"])
      );
      return [...existing, ...uniqueIncoming];
    },
    "activity": (existing, incoming) => {
      const existingNames = new Set(
        existing.map((a) => a.$?.["android:name"]).filter(Boolean)
      );
      const uniqueIncoming = incoming.filter(
        (a) => !existingNames.has(a.$?.["android:name"])
      );
      return [...existing, ...uniqueIncoming];
    },
    "service": (existing, incoming) => {
      const existingNames = new Set(
        existing.map((s) => s.$?.["android:name"]).filter(Boolean)
      );
      const uniqueIncoming = incoming.filter(
        (s) => !existingNames.has(s.$?.["android:name"])
      );
      return [...existing, ...uniqueIncoming];
    }
  }
};
var SyncWidget = class {
  /**
   * Syncs widget files to default location
   * @param projectRoot - Root directory of the Expo project
   * @param customPath - Custom path to widget file/directory
   * @param defaultPath - Default path for widget files
   */
  static syncToDefaults(projectRoot, customPath, defaultPath) {
    Logger.info(`

==================== Syncing widget files ====================

`);
    const resolvedSource = this.resolveWidgetPath(projectRoot, customPath);
    if (!resolvedSource) {
      Logger.warn(`Custom widget path not found: ${customPath}`);
      return;
    }
    const defaultLocation = import_path3.default.join(projectRoot, defaultPath);
    FileUtils.ensureDir(import_path3.default.dirname(defaultLocation));
    if (FileUtils.isDirectory(resolvedSource)) {
      FileUtils.copyRecursively(
        resolvedSource,
        defaultLocation,
        (targetPath) => Logger.success(`Synced: ${import_path3.default.relative(projectRoot, targetPath)}`),
        (targetPath) => Logger.warn(`Skipped existing: ${import_path3.default.relative(projectRoot, targetPath)}`)
      );
    } else {
      FileUtils.copyFileSync(resolvedSource, defaultLocation);
      Logger.success(`Synced widget file: ${import_path3.default.relative(projectRoot, defaultLocation)}`);
    }
  }
  /**
   * Merges XML elements from widget manifest to main Android manifest
   * @param config - Expo config object
   * @param projectRoot - Root directory of the Expo project
   * @param widgetManifestPath - Path to the widget manifest file
   * @param mergeConfig - Configuration for what elements to merge
   */
  static async mergeXmlManifest(config, projectRoot, widgetManifestPath, mergeConfig = DEFAULT_WIDGET_MERGE_CONFIG) {
    Logger.info(`

==================== Merging XML manifest elements ====================

`);
    const resolvedManifestPath = this.resolveWidgetPath(projectRoot, widgetManifestPath);
    if (!resolvedManifestPath || !this.isValidManifestFile(resolvedManifestPath)) {
      Logger.warn(`Valid widget manifest not found: ${widgetManifestPath}`);
      return;
    }
    Logger.manifest(`Processing widget manifest: ${widgetManifestPath}`);
    try {
      const widgetManifestContent = FileUtils.readFileSync(resolvedManifestPath);
      const parser = new import_xml2js.Parser();
      const widgetManifest = await parser.parseStringPromise(widgetManifestContent);
      let mergedCount = 0;
      if (mergeConfig.mergeManifestElements) {
        mergedCount += this.mergeManifestLevelElements(
          config,
          widgetManifest,
          mergeConfig
        );
      }
      if (mergeConfig.mergeApplicationElements) {
        mergedCount += this.mergeApplicationLevelElements(
          config,
          widgetManifest,
          mergeConfig
        );
      }
      if (mergedCount > 0) {
        Logger.mobile(`Successfully merged ${mergedCount} XML elements from widget manifest`);
      } else {
        Logger.info(`No elements found to merge from widget manifest`);
      }
    } catch (error) {
      Logger.error(`Error merging widget manifest: ${error}`);
    }
  }
  /**
   * Merges manifest-level elements (permissions, etc.)
   */
  static mergeManifestLevelElements(config, widgetManifest, mergeConfig) {
    let mergedCount = 0;
    const manifestRoot = config?.modResults?.manifest;
    if (!manifestRoot) {
      Logger.warn("Main manifest not found in config");
      return 0;
    }
    mergeConfig.elementsToMerge.forEach((elementName) => {
      const widgetElements = widgetManifest?.manifest?.[elementName] || [];
      if (widgetElements.length > 0) {
        if (!manifestRoot[elementName]) {
          manifestRoot[elementName] = [];
        }
        const mergeRule = mergeConfig.customMergeRules?.[elementName];
        if (mergeRule) {
          manifestRoot[elementName] = mergeRule(manifestRoot[elementName], widgetElements);
        } else {
          manifestRoot[elementName] = [...manifestRoot[elementName], ...widgetElements];
        }
        Logger.success(`Merged ${widgetElements.length} <${elementName}> element(s)`);
        mergedCount += widgetElements.length;
      }
    });
    return mergedCount;
  }
  /**
   * Merges application-level elements (receivers, services, activities, etc.)
   */
  static mergeApplicationLevelElements(config, widgetManifest, mergeConfig) {
    let mergedCount = 0;
    const mainApplication = config?.modResults?.manifest?.application?.[0];
    const widgetApplication = widgetManifest?.manifest?.application?.[0];
    if (!mainApplication || !widgetApplication) {
      Logger.warn("Application section not found in one of the manifests");
      return 0;
    }
    mergeConfig.elementsToMerge.forEach((elementName) => {
      const widgetElements = widgetApplication[elementName] || [];
      if (widgetElements.length > 0) {
        if (!mainApplication[elementName]) {
          mainApplication[elementName] = [];
        }
        const mergeRule = mergeConfig.customMergeRules?.[elementName];
        if (mergeRule) {
          mainApplication[elementName] = mergeRule(mainApplication[elementName], widgetElements);
        } else {
          mainApplication[elementName] = [...mainApplication[elementName], ...widgetElements];
        }
        Logger.success(`Merged ${widgetElements.length} application <${elementName}> element(s)`);
        mergedCount += widgetElements.length;
      }
    });
    return mergedCount;
  }
  /**
   * Resolves widget path - handles both files and directories
   * @param projectRoot - Root directory of the Expo project
   * @param widgetPath - Path to widget file/directory
   * @returns Resolved path or null if not found
   */
  static resolveWidgetPath(projectRoot, widgetPath) {
    const isAbsolutePath = import_path3.default.isAbsolute(widgetPath);
    const fullPath = isAbsolutePath ? widgetPath : import_path3.default.join(projectRoot, widgetPath);
    Logger.debug(`Resolving widget path: ${fullPath} (${isAbsolutePath ? "absolute" : "relative"})`);
    if (FileUtils.exists(fullPath)) {
      Logger.debug(`Found widget path: ${fullPath}`);
      return fullPath;
    }
    Logger.warn(`Widget path not found: ${fullPath}`);
    return null;
  }
  /**
   * Validates if a file is a legitimate Android manifest file
   * @param filePath - Path to the file to validate
   * @returns True if the file is a valid manifest file
   */
  static isValidManifestFile(filePath) {
    if (!filePath.toLowerCase().includes("manifest") && !filePath.endsWith(".xml")) {
      return false;
    }
    try {
      const content = FileUtils.readFileSync(filePath);
      const manifestKeywords = ["<manifest", "<application", "android:"];
      return manifestKeywords.some((keyword) => content.includes(keyword));
    } catch {
      return false;
    }
  }
  /**
   * Creates a configuration to merge only specific elements
   * @param elements - Array of element names to merge
   * @returns Merge configuration
   */
  static createCustomMergeConfig(elements) {
    return {
      elementsToMerge: elements,
      mergeApplicationElements: elements.some(
        (e) => ["receiver", "service", "activity", "provider"].includes(e)
      ),
      mergeManifestElements: elements.some(
        (e) => ["uses-permission", "permission", "uses-feature"].includes(e)
      ),
      customMergeRules: DEFAULT_WIDGET_MERGE_CONFIG.customMergeRules
    };
  }
  /**
   * Helper method to add WorkManager fix to manifest
   * @param config - Expo config object
   */
  // static addWorkManagerFix(config: any): void {
  //   Logger.info('Adding WorkManager initialization fix...');
  //   const mainApplication = config?.modResults?.manifest?.application?.[0];
  //   if (!mainApplication) {
  //     Logger.warn('Application section not found in manifest');
  //     return;
  //   }
  //   if (!mainApplication.provider) {
  //     mainApplication.provider = [];
  //   }
  //   // Add provider to disable WorkManager auto-initialization
  //   const workManagerFix = {
  //     $: {
  //       'android:name': 'androidx.startup.InitializationProvider',
  //       'android:authorities': '${applicationId}.androidx-startup',
  //       'tools:node': 'remove'
  //     }
  //   };
  //   // TODO FIXING THIS
  //   // mainApplication.provider.push(workManagerFix);
  //   // Ensure tools namespace is added to manifest
  //   if (!config.modResults.manifest.$['xmlns:tools']) {
  //     config.modResults.manifest.$['xmlns:tools'] = 'http://schemas.android.com/tools';
  //   }
  //   Logger.success('Added WorkManager initialization fix');
  // }
};

// modules/expo-glance-widget/plugins/utils/widgetFilesSync.ts
var import_path5 = __toESM(require("path"));

// modules/expo-glance-widget/plugins/utils/importWidgetFiles.ts
var import_fs4 = __toESM(require("fs"));
var import_path4 = __toESM(require("path"));
function importWidgetFiles({
  widgetsSourceBasePath,
  includeDirectories = [],
  destinationBasePath,
  filesMatchPattern,
  destinationPackageName,
  sourcePackageName
}) {
  console.log(" == inludeDirectories == ", includeDirectories);
  Logger.file(`
Finding widget files in source path: ${widgetsSourceBasePath}
`);
  if (!import_fs4.default.existsSync(widgetsSourceBasePath)) {
    Logger.warn(`Widgets source path does not exist: ${widgetsSourceBasePath}`);
    return;
  }
  const rootDirectoryFiles = import_fs4.default.readdirSync(widgetsSourceBasePath, {
    withFileTypes: true
  });
  if (rootDirectoryFiles.length === 0) {
    Logger.warn(`No files found in widgets source path: ${widgetsSourceBasePath}`);
    return;
  }
  const patternRegex = filesMatchPattern ? new RegExp(filesMatchPattern) : null;
  rootDirectoryFiles.forEach((file) => {
    const sourcePath = import_path4.default.join(widgetsSourceBasePath, file.name);
    const destinationPath = import_path4.default.join(destinationBasePath, file.name);
    if (patternRegex && file.isFile() && !patternRegex.test(file.name)) {
      Logger.warn(`Skipping ${file.name} - doesn't match pattern`);
      return;
    }
    if (file.isDirectory()) {
      if (includeDirectories.length === 0 || includeDirectories.includes(file.name)) {
        Logger.file(`\u{1F6A7}\u{1F6A7} Processing directory: ${file.name}`);
        recreateWidgetDirectories({
          directoryToInclude: file.name,
          widgetsSourceBasePath,
          destinationBasePath
        });
      } else {
        Logger.warn(`Skipping directory: ${file.name} - not in include list`);
      }
    } else if (file.isFile()) {
      Logger.debug(`Copying file: ${file.name} to destination`);
      ensureDirectoryExists(import_path4.default.dirname(destinationPath));
      import_fs4.default.copyFileSync(sourcePath, destinationPath);
    }
  });
  Logger.success(`Widget files copied to: ${destinationBasePath}`);
  Logger.file(`\u{1F6A7}\u{1F6A7} Updating package names in widget files...`);
  updateWidgetFilesPackageNames({
    destinationBasePath,
    sourcePackageName,
    destinationPackageName
  });
  Logger.success(` Package names updated in widget files.`);
}
function recreateWidgetDirectories({
  directoryToInclude,
  widgetsSourceBasePath,
  destinationBasePath
}) {
  const sourceDirectory = import_path4.default.join(widgetsSourceBasePath, directoryToInclude);
  const filesInDirectory = import_fs4.default.readdirSync(sourceDirectory, {
    withFileTypes: true
  });
  if (filesInDirectory.length === 0) {
    Logger.debug(`No files found in directory: ${sourceDirectory}`);
    return;
  }
  const destinationDirectory = import_path4.default.join(destinationBasePath, directoryToInclude);
  ensureDirectoryExists(destinationDirectory);
  filesInDirectory.forEach((file) => {
    const sourcePath = import_path4.default.join(sourceDirectory, file.name);
    const destinationPath = import_path4.default.join(destinationDirectory, file.name);
    if (file.isDirectory()) {
      Logger.debug(`Processing subdirectory: ${file.name}`);
      recreateWidgetDirectories({
        directoryToInclude: import_path4.default.join(directoryToInclude, file.name),
        widgetsSourceBasePath,
        destinationBasePath
      });
    } else {
      Logger.debug(`Copying file: ${file.name}`);
      import_fs4.default.copyFileSync(sourcePath, destinationPath);
    }
  });
}
function updateWidgetFilesPackageNames({
  destinationBasePath,
  sourcePackageName,
  destinationPackageName
}) {
  if (!import_fs4.default.existsSync(destinationBasePath)) {
    Logger.warn(`Widget files directory does not exist: ${destinationBasePath}`);
    return;
  }
  const files = import_fs4.default.readdirSync(destinationBasePath, { withFileTypes: true });
  if (files.length === 0) {
    Logger.warn(`No files found in widget files directory: ${destinationBasePath}`);
    return;
  }
  let firstValidFile = files.find((f) => f.isFile() && f.name.endsWith(".kt"));
  if (!firstValidFile && !sourcePackageName) {
    Logger.warn(`Could not find any .kt files in: ${destinationBasePath} to infer package name`);
    return;
  }
  const sourcePackageNameOrInferred = sourcePackageName || (firstValidFile ? inferPackageNameFromFile(import_path4.default.join(destinationBasePath, firstValidFile.name)) : null);
  if (!sourcePackageNameOrInferred) {
    Logger.warn(
      `Could not infer source package name from files in: ${destinationBasePath}. Consider passing sourcePackageName`
    );
    return;
  }
  processFilesForPackageUpdate(
    destinationBasePath,
    files,
    sourcePackageNameOrInferred,
    destinationPackageName
  );
}
function processFilesForPackageUpdate(basePath, files, sourcePackageName, destinationPackageName) {
  files.forEach((file) => {
    const filePath = import_path4.default.join(basePath, file.name);
    if (file.isDirectory()) {
      updateWidgetFilesPackageNames({
        destinationBasePath: filePath,
        sourcePackageName,
        destinationPackageName
      });
    } else if (file.isFile() && file.name.endsWith(".kt")) {
      Logger.info(`Renaming package in file: ${filePath}`);
      updatePackageNameInFile(filePath, sourcePackageName, destinationPackageName);
    }
  });
}
function updatePackageNameInFile(filePath, sourcePackageName, destinationPackageName) {
  try {
    let content = import_fs4.default.readFileSync(filePath, "utf8");
    const escapedSourcePackage = sourcePackageName.replace(/\./g, "\\.");
    content = content.replace(new RegExp(escapedSourcePackage, "g"), destinationPackageName);
    import_fs4.default.writeFileSync(filePath, content, "utf8");
  } catch (error) {
    Logger.warn(`Failed to update package name in file: ${filePath} - ${error.message}`);
  }
}
function inferPackageNameFromFile(filePath) {
  try {
    if (import_fs4.default.statSync(filePath).isDirectory()) {
      return null;
    }
    const content = import_fs4.default.readFileSync(filePath, "utf8");
    const match = content.match(/package\s+([a-zA-Z0-9_.]+)/);
    return match ? match[1] : null;
  } catch (error) {
    Logger.warn(`Failed to infer package name from file: ${filePath} - ${error.message}`);
    return null;
  }
}
function ensureDirectoryExists(dirPath) {
  if (!import_fs4.default.existsSync(dirPath)) {
    Logger.debug(`Creating directory: ${dirPath}`);
    import_fs4.default.mkdirSync(dirPath, { recursive: true });
  }
}

// modules/expo-glance-widget/plugins/utils/widgetFilesSync.ts
var WidgetFilesSync = class {
  /**
   * Syncs widget Kotlin class files to default location with package name updates
   */
  static syncToDefaults({
    projectRoot,
    widgetFilesPath,
    includeDirectories,
    defaultSourcePath = "widgets/android",
    packageName,
    fileMatchPattern = "Widget"
  }) {
    Logger.info(
      `

==================== Syncing widget files to default location ====================

`
    );
    if (!FileUtils.exists(widgetFilesPath)) {
      Logger.warn(`widgetFilesPath does not exist: ${widgetFilesPath}`);
      return;
    }
    const resolvedSource = this.resolveWidgetPath(projectRoot, widgetFilesPath);
    if (!resolvedSource) {
      Logger.warn(`No valid widget files found at: ${widgetFilesPath}`);
      return;
    }
    if (!resolvedSource) {
      Logger.warn(`No valid widget files found at: ${widgetFilesPath}`);
      return;
    }
    const sourceDir = import_path5.default.dirname(resolvedSource);
    if (!FileUtils.exists(sourceDir)) {
      Logger.warn(`Source directory does not exist: ${sourceDir}`);
      return;
    }
    const destinationBaseDir = import_path5.default.join(projectRoot, defaultSourcePath);
    importWidgetFiles({
      includeDirectories: includeDirectories || [],
      widgetsSourceBasePath: sourceDir,
      destinationBasePath: destinationBaseDir,
      filesMatchPattern: fileMatchPattern,
      destinationPackageName: packageName
    });
  }
  /**
     * Copies widget files to Android build directory from specified directories only
  
     */
  static copyToBuild({
    packageName,
    widgetFilesPath,
    includeDirectories,
    projectAndroidRoot,
    projectRoot,
    fileMatchPattern
  }) {
    Logger.info(
      `

==================== Copying widget files to build location ====================

`
    );
    const resolvedSource = this.resolveWidgetPath(projectRoot, widgetFilesPath);
    if (!resolvedSource || !FileUtils.exists(resolvedSource)) {
      Logger.warn(`No valid widget files found at: ${widgetFilesPath}`);
      return;
    }
    const sourceDir = import_path5.default.dirname(resolvedSource);
    const packageNameAsPath = packageName.replace(/\./g, "/");
    const destinationBaseDir = import_path5.default.join(projectRoot, projectAndroidRoot, "app/src/main/java", packageNameAsPath);
    importWidgetFiles({
      includeDirectories: includeDirectories || [],
      widgetsSourceBasePath: sourceDir,
      destinationBasePath: destinationBaseDir,
      filesMatchPattern: fileMatchPattern,
      destinationPackageName: packageName
    });
  }
  /**
   * Resolves widget path - handles both file and directory paths with robust validation
   * @param projectRoot - Root directory of the Expo project
   * @param widgetPath - Path to widget file or directory (can be relative or absolute)
   * @returns Resolved path to a valid widget file, or null if not found
   */
  static resolveWidgetPath(projectRoot, widgetPath) {
    const isAbsolutePath = import_path5.default.isAbsolute(widgetPath);
    const fullPath = isAbsolutePath ? widgetPath : import_path5.default.join(projectRoot, widgetPath);
    Logger.debug(
      `Resolving widget path: ${fullPath} (${isAbsolutePath ? "absolute" : "relative"})`
    );
    if (FileUtils.exists(fullPath) && !FileUtils.isDirectory(fullPath)) {
      if (this.isValidWidgetFile(fullPath)) {
        Logger.debug(`Found valid widget file: ${fullPath}`);
        return fullPath;
      } else {
        Logger.warn(`File exists but is not a valid widget file: ${fullPath}`);
        return null;
      }
    }
    if (FileUtils.exists(fullPath) && FileUtils.isDirectory(fullPath)) {
      const widgetFiles = this.findWidgetFiles(fullPath, "Widget");
      if (widgetFiles.length > 0) {
        const firstWidgetFile = import_path5.default.join(fullPath, widgetFiles[0]);
        Logger.debug(`Found widget files in directory: ${widgetFiles.join(", ")}`);
        return firstWidgetFile;
      } else {
        Logger.debug(`Directory exists but contains no widget files: ${fullPath}`);
      }
    }
    if (!FileUtils.exists(fullPath)) {
      Logger.debug(
        `Path does not exist, checking if we can find widget files in nearby directories...`
      );
      let currentPath = fullPath;
      let attempts = 0;
      const maxAttempts = 5;
      while (!FileUtils.exists(currentPath) && attempts < maxAttempts) {
        currentPath = import_path5.default.dirname(currentPath);
        attempts++;
        if (FileUtils.exists(currentPath) && FileUtils.isDirectory(currentPath)) {
          Logger.debug(`Found existing parent directory: ${currentPath}`);
          const foundWidgetFile = this.recursiveWidgetSearch(currentPath, 3);
          if (foundWidgetFile) {
            Logger.success(`Found widget file through recursive search: ${foundWidgetFile}`);
            return foundWidgetFile;
          }
        }
      }
    }
    Logger.warn(`No valid widget files found for path: ${widgetPath}`);
    return null;
  }
  /**
   * Finds Kotlin files that contain widget-related content in a directory
   * @param directory - Directory to search in
   * @param fileMatchPattern - Pattern to match widget files (default: "Widget")
   * @returns Array of widget file names, sorted by relevance
   */
  static findWidgetFiles(directory, fileMatchPattern = "Widget") {
    if (!FileUtils.exists(directory) || !FileUtils.isDirectory(directory)) {
      return [];
    }
    try {
      const allFiles = FileUtils.readdirSync(directory);
      const ktFiles = allFiles.filter((file) => file.endsWith(".kt"));
      if (ktFiles.length === 0) {
        return [];
      }
      const definitiveWidgetFiles = [];
      const possibleWidgetFiles = [];
      ktFiles.forEach((file) => {
        const fileName = file.toLowerCase();
        const matchPattern = fileMatchPattern.toLowerCase();
        if (fileName.includes(matchPattern)) {
          definitiveWidgetFiles.push(file);
          return;
        }
        try {
          const filePath = import_path5.default.join(directory, file);
          const content = FileUtils.readFileSync(filePath);
          const strongKeywords = ["GlanceAppWidget", "@GlanceAppWidget", "AppWidgetProvider"];
          const hasStrongKeyword = strongKeywords.some((keyword) => content.includes(keyword));
          if (hasStrongKeyword) {
            definitiveWidgetFiles.push(file);
            return;
          }
          const weakKeywords = ["Widget", "AppWidget"];
          const hasWeakKeyword = weakKeywords.some((keyword) => content.includes(keyword));
          if (hasWeakKeyword) {
            possibleWidgetFiles.push(file);
          }
        } catch {
        }
      });
      const result = [...definitiveWidgetFiles, ...possibleWidgetFiles];
      Logger.debug(
        `Found ${definitiveWidgetFiles.length} definitive and ${possibleWidgetFiles.length} possible widget files in ${directory}`
      );
      return result;
    } catch (error) {
      Logger.error(`Error reading directory ${directory}: ${error}`);
      return [];
    }
  }
  /**
   * Finds widget files in a directory and its subdirectories
   * @param directory - Directory to search in (includes subdirectories)
   * @param fileMatchPattern - Pattern to match widget files
   * @returns Array of full paths to widget files
   */
  static findWidgetFilesInDirectory(directory, fileMatchPattern) {
    if (!FileUtils.exists(directory) || !FileUtils.isDirectory(directory)) {
      return [];
    }
    const widgetFiles = [];
    try {
      const traverse = (dir) => {
        const items = FileUtils.readdirSync(dir);
        items.forEach((item) => {
          const itemPath = import_path5.default.join(dir, item);
          if (FileUtils.isDirectory(itemPath)) {
            const skipDirs = [
              "build",
              "gradle",
              ".gradle",
              "generated",
              "intermediates",
              "outputs",
              "tmp"
            ];
            if (!skipDirs.includes(item)) {
              traverse(itemPath);
            }
          } else if (item.endsWith(".kt")) {
            const fileName = item.toLowerCase();
            const matchPattern = fileMatchPattern.toLowerCase();
            if (fileName.includes(matchPattern)) {
              widgetFiles.push(itemPath);
            } else {
              try {
                const content = FileUtils.readFileSync(itemPath);
                const strongKeywords = ["GlanceAppWidget", "@GlanceAppWidget", "AppWidgetProvider"];
                const hasStrongKeyword = strongKeywords.some(
                  (keyword) => content.includes(keyword)
                );
                if (hasStrongKeyword) {
                  widgetFiles.push(itemPath);
                }
              } catch {
              }
            }
          }
        });
      };
      traverse(directory);
    } catch (error) {
      Logger.error(`Error traversing directory ${directory}: ${error}`);
    }
    return widgetFiles;
  }
  /**
   * Updates the package declaration in a Kotlin file
   * @param filePath - Path to the Kotlin file
   * @param packageName - New package name
   */
  static updatePackageDeclaration(filePath, packageName) {
    try {
      let content = FileUtils.readFileSync(filePath);
      const packageMatch = content.match(/^package\s+([^\s\n]+)/m);
      const currentPackage = packageMatch ? packageMatch[1] : null;
      if (currentPackage && currentPackage !== packageName) {
        Logger.debug(`Updating package: ${currentPackage} \u2192 ${packageName}`);
        content = content.replace(/^package\s+[^\s\n]+/m, `package ${packageName}`);
        const importRegex = new RegExp(
          `import\\s+${currentPackage.replace(/\./g, "\\.")}(..*)`,
          "g"
        );
        content = content.replace(importRegex, `import ${packageName}$1`);
        FileUtils.writeFileSync(filePath, content);
        Logger.success(
          `Updated package declaration in: ${import_path5.default.basename(
            filePath
          )} (${currentPackage} \u2192 ${packageName})`
        );
      } else if (!currentPackage) {
        content = `package ${packageName}

${content}`;
        FileUtils.writeFileSync(filePath, content);
        Logger.success(`Added package declaration to: ${import_path5.default.basename(filePath)} (${packageName})`);
      } else {
        Logger.debug(`Package already correct in: ${import_path5.default.basename(filePath)}`);
      }
    } catch (error) {
      Logger.error(`Error updating package in ${filePath}: ${error}`);
    }
  }
  /**
   * Validates if a file is a legitimate widget file
   * @param filePath - Path to the file to validate
   * @returns True if the file is a valid widget file
   */
  static isValidWidgetFile(filePath) {
    if (!filePath.endsWith(".kt")) {
      return false;
    }
    try {
      const content = FileUtils.readFileSync(filePath);
      const fileName = import_path5.default.basename(filePath);
      if (fileName.toLowerCase().includes("widget")) {
        return true;
      }
      const widgetKeywords = ["Widget", "AppWidget", "GlanceAppWidget", "@GlanceAppWidget"];
      return widgetKeywords.some((keyword) => content.includes(keyword));
    } catch {
      return false;
    }
  }
  /**
   * Recursively searches for widget files in a directory tree
   * @param rootDir - Root directory to start search
   * @param maxDepth - Maximum depth to search (prevents infinite recursion)
   * @returns Path to first widget file found, or null
   */
  static recursiveWidgetSearch(rootDir, maxDepth) {
    if (maxDepth <= 0 || !FileUtils.exists(rootDir) || !FileUtils.isDirectory(rootDir)) {
      return null;
    }
    try {
      const widgetFiles = this.findWidgetFiles(rootDir, "Widget");
      if (widgetFiles.length > 0) {
        return import_path5.default.join(rootDir, widgetFiles[0]);
      }
      const items = FileUtils.readdirSync(rootDir);
      for (const item of items) {
        const itemPath = import_path5.default.join(rootDir, item);
        if (FileUtils.isDirectory(itemPath)) {
          const skipDirs = [
            "build",
            "gradle",
            ".gradle",
            "generated",
            "intermediates",
            "outputs",
            "tmp"
          ];
          if (skipDirs.includes(item)) {
            continue;
          }
          const result = this.recursiveWidgetSearch(itemPath, maxDepth - 1);
          if (result) {
            return result;
          }
        }
      }
    } catch (error) {
      Logger.debug(`Error during recursive search in ${rootDir}: ${error}`);
    }
    return null;
  }
};

// modules/expo-glance-widget/plugins/utils/widgetSync.ts
var WidgetSync = class {
  /**
   * Syncs external widget files to local default directories for version control
   * @param projectRoot - Root directory of the Expo project
   * @param options - Plugin configuration options
   * @param packageName - Target package name for the Expo project
   */
  static syncToDefaults(projectRoot, options, packageName) {
    Logger.debug("Checking if widget files need to be synced to defaults...");
    const usingCustomPaths = options.widgetFilesPath !== DEFAULT_OPTIONS.widgetFilesPath || options.manifestPath !== DEFAULT_OPTIONS.manifestPath || options.resPath !== DEFAULT_OPTIONS.resPath;
    if (!usingCustomPaths) {
      Logger.debug("Using default paths, no sync needed");
      return;
    }
    if (options.widgetFilesPath === DEFAULT_OPTIONS.widgetFilesPath) {
      Logger.warn(`
\u{1F6A9}\u{1F6A9}\u{1F6A9}\u{1F6A9} Skipping sync to defaults: widgetFilesPath is the same as the default: "${DEFAULT_OPTIONS.widgetFilesPath}

".`);
      return;
    }
    Logger.info("Custom widget paths detected, syncing to default locations for version control...");
    const targetSyncDir = options.syncDirectory || DEFAULT_OPTIONS.syncDirectory;
    const targetManifestPath = `${targetSyncDir}/AndroidManifest.xml`;
    const targetResPath = `${targetSyncDir}/res`;
    WidgetFilesSync.syncToDefaults({
      projectRoot,
      platformRoot: projectRoot,
      fileMatchPattern: options.fileMatchPattern || "Widget",
      packageName,
      widgetFilesPath: options.widgetFilesPath,
      includeDirectories: options.includeDirectories,
      defaultSourcePath: options.syncDirectory
      // Use the provided path as the default source
    });
    SyncWidget.syncToDefaults(
      projectRoot,
      options.manifestPath,
      targetManifestPath
    );
    ResourceSync.syncToDefaults(
      projectRoot,
      options.resPath,
      targetResPath
    );
  }
  /**
   * Copies widget files to Android build directories
   * @param projectRoot - Root directory of the Expo project
   * @param platformRoot - Root directory of the Android platform
   * @param options - Plugin configuration options
   * @param packageName - Android package name
   * @param fileMatchPattern - Pattern to match widget files
   * @param includeDirectories - Array of directories to include
   */
  static copyToBuild(projectRoot, platformRoot, options, packageName, fileMatchPattern, includeDirectories) {
    const projectAndroidRoot = import_path6.default.relative(projectRoot, "android");
    FileUtils.ensureDir(projectAndroidRoot);
    WidgetFilesSync.copyToBuild({
      projectRoot,
      projectAndroidRoot,
      platformRoot: projectRoot,
      fileMatchPattern: fileMatchPattern || options.fileMatchPattern || "Widget",
      packageName,
      widgetFilesPath: options.widgetFilesPath,
      includeDirectories: includeDirectories || options.includeDirectories,
      defaultSourcePath: options.widgetFilesPath
      // Use the provided path as the default source
    });
    ResourceSync.copyToBuild(
      projectRoot,
      platformRoot,
      options.resPath
    );
  }
  /**
   * Adds widget receivers to Android manifest using the new SyncWidget utility
   * @param config - Expo config object
   * @param projectRoot - Root directory of the Expo project
   * @param manifestPath - Path to the widget manifest file
   */
  static async addReceiversToManifest(config, projectRoot, manifestPath) {
    await SyncWidget.mergeXmlManifest(config, projectRoot, manifestPath);
  }
};

// modules/expo-glance-widget/plugins/withGlanceWidgetFiles.ts
var withGlanceWidgetFiles = (config, options = {}) => {
  const finalOptions = { ...DEFAULT_OPTIONS, ...options };
  config = (0, import_config_plugins3.withDangerousMod)(config, [
    "android",
    async (newConfig) => {
      const { modRequest } = newConfig;
      const projectRoot = modRequest.projectRoot;
      const platformRoot = modRequest.platformProjectRoot;
      const packageName = import_config_plugins3.AndroidConfig.Package.getPackage(config);
      console.log("=====   \u2705\u2705\u2705\u2705\u2705\u2705\u2705\u2705\u2705\u2705 ========", modRequest);
      console.log("=====   \u2705\u2705\u2705\u2705\u2705\u2705\u2705\u2705\u2705\u2705 ========", packageName);
      if (!packageName) {
        throw new Error(`ExpoGlanceWidgets: app.config must provide a value for android.package.`);
      }
      WidgetSync.syncToDefaults(projectRoot, finalOptions, packageName);
      WidgetSync.copyToBuild(projectRoot, platformRoot, finalOptions, packageName);
      return newConfig;
    }
  ]);
  config = (0, import_config_plugins3.withAndroidManifest)(config, async (config2) => {
    const projectRoot = config2.modRequest?.projectRoot;
    if (projectRoot) {
      await WidgetSync.addReceiversToManifest(config2, projectRoot, finalOptions.manifestPath);
    }
    return config2;
  });
  return config;
};

// modules/expo-glance-widget/plugins/withWakatimeWorkerErrorHandling.ts
var import_config_plugins4 = __toESM(require_build4());
var fs3 = __toESM(require("fs"));
var path7 = __toESM(require("path"));
var logger = new Logger("WithWakatimeWorkerErrorHandling");
var withWakatimeWorkerErrorHandling = (config, options = {}) => {
  return (0, import_config_plugins4.withDangerousMod)(config, [
    "android",
    async (config2) => {
      const { platformProjectRoot } = config2.modRequest;
      const wakatimeWorkerPath = findWakatimeWorkerFile(platformProjectRoot);
      if (!wakatimeWorkerPath) {
        logger.warn("WakatimeWidgetWorker.kt not found, skipping error handling injection");
        return config2;
      }
      let workerContent = fs3.readFileSync(wakatimeWorkerPath, "utf8");
      const packageName = options.packageName || extractPackageName(workerContent);
      if (!packageName) {
        logger.warn("Could not determine package name, skipping error handling injection");
        return config2;
      }
      workerContent = addErrorHandlingToSetupPeriodicWork(workerContent);
      fs3.writeFileSync(wakatimeWorkerPath, workerContent);
      logger.info("Successfully added error handling to WakatimeWidgetWorker.setupPeriodicWork");
      return config2;
    }
  ]);
};
function findWakatimeWorkerFile(platformProjectRoot) {
  const widgetsPath = path7.join(platformProjectRoot, "..", "widgets", "android", "wakatime", "WakatimeWidgetWorker.kt");
  if (fs3.existsSync(widgetsPath)) {
    return widgetsPath;
  }
  function searchDirectory(dir) {
    if (!fs3.existsSync(dir)) return null;
    const files = fs3.readdirSync(dir);
    for (const file of files) {
      const filePath = path7.join(dir, file);
      const stat = fs3.statSync(filePath);
      if (stat.isDirectory()) {
        const result = searchDirectory(filePath);
        if (result) return result;
      } else if (file === "WakatimeWidgetWorker.kt") {
        return filePath;
      }
    }
    return null;
  }
  const mainSrcPath = path7.join(platformProjectRoot, "app", "src", "main");
  if (fs3.existsSync(mainSrcPath)) {
    return searchDirectory(mainSrcPath);
  }
  return null;
}
function extractPackageName(content) {
  const packageMatch = content.match(/^package\s+([a-zA-Z0-9_.]+)/m);
  return packageMatch ? packageMatch[1] : null;
}
function addErrorHandlingToSetupPeriodicWork(content) {
  if (content.includes("try {") && content.includes("catch (e: Exception)")) {
    logger.info("Error handling already present in setupPeriodicWork");
    return content;
  }
  const setupMethodRegex = /fun\s+setupPeriodicWork\(context:\s*Context\)\s*\{/;
  const setupMethodMatch = content.match(setupMethodRegex);
  if (!setupMethodMatch) {
    logger.warn("Could not find setupPeriodicWork method");
    return content;
  }
  const methodStartIndex = content.indexOf(setupMethodMatch[0]);
  const methodBodyStart = methodStartIndex + setupMethodMatch[0].length;
  let braceCount = 1;
  let methodBodyEnd = methodBodyStart;
  for (let i2 = methodBodyStart; i2 < content.length; i2++) {
    if (content[i2] === "{") braceCount++;
    else if (content[i2] === "}") braceCount--;
    if (braceCount === 0) {
      methodBodyEnd = i2;
      break;
    }
  }
  const methodBody = content.substring(methodBodyStart, methodBodyEnd);
  const newMethodBody = `
            try {
                ${methodBody.trim()}
            } catch (e: Exception) {
                Log.e("WakatimeWorker", "Failed to schedule work", e)
            }
        `;
  const newContent = content.substring(0, methodBodyStart) + newMethodBody + content.substring(methodBodyEnd);
  logger.info("Added error handling to setupPeriodicWork method");
  return newContent;
}

// modules/expo-glance-widget/plugins/withWakatimeWorkManager.ts
var import_config_plugins5 = __toESM(require_build4());
var fs4 = __toESM(require("fs"));
var path8 = __toESM(require("path"));
var logger2 = new Logger("WithWakatimeWorkManager");
var withWakatimeWorkManager = (config, options = {}) => {
  return (0, import_config_plugins5.withDangerousMod)(config, [
    "android",
    async (config2) => {
      const { platformProjectRoot } = config2.modRequest;
      const mainActivityPath = findMainActivityFile(platformProjectRoot);
      if (!mainActivityPath) {
        logger2.warn("MainActivity.kt not found, skipping WorkManager injection");
        return config2;
      }
      let mainActivityContent = fs4.readFileSync(mainActivityPath, "utf8");
      logger2.debug(`MainActivity content length: ${mainActivityContent.length}`);
      logger2.debug(`MainActivity content preview: ${mainActivityContent.substring(0, 200)}...`);
      const packageName = options.packageName || extractPackageName2(mainActivityContent);
      if (!packageName) {
        logger2.warn("Could not determine package name, skipping WorkManager injection");
        return config2;
      }
      mainActivityContent = injectWakatimeWorkManager(mainActivityContent, packageName);
      fs4.writeFileSync(mainActivityPath, mainActivityContent);
      logger2.info("Successfully injected WakatimeWidgetWorker initialization into MainActivity");
      return config2;
    }
  ]);
};
function findMainActivityFile(platformProjectRoot) {
  const possiblePaths = [
    path8.join(platformProjectRoot, "app", "src", "main", "java", "**", "MainActivity.kt"),
    path8.join(platformProjectRoot, "app", "src", "main", "kotlin", "**", "MainActivity.kt")
  ];
  function searchDirectory(dir) {
    if (!fs4.existsSync(dir)) return null;
    const files = fs4.readdirSync(dir);
    for (const file of files) {
      const filePath = path8.join(dir, file);
      const stat = fs4.statSync(filePath);
      if (stat.isDirectory()) {
        const result = searchDirectory(filePath);
        if (result) return result;
      } else if (file === "MainActivity.kt") {
        return filePath;
      }
    }
    return null;
  }
  const mainSrcPath = path8.join(platformProjectRoot, "app", "src", "main");
  if (fs4.existsSync(mainSrcPath)) {
    const javaPath = path8.join(mainSrcPath, "java");
    const kotlinPath = path8.join(mainSrcPath, "kotlin");
    let result = searchDirectory(javaPath);
    if (!result) {
      result = searchDirectory(kotlinPath);
    }
    return result;
  }
  return null;
}
function extractPackageName2(content) {
  const packageMatch = content.match(/^package\s+([a-zA-Z0-9_.]+)/m);
  return packageMatch ? packageMatch[1] : null;
}
function injectWakatimeWorkManager(content, packageName) {
  const importStatement = `import ${packageName}.wakatime.WakatimeWidgetWorker`;
  const initializationCode = `
        
        // Initialize wakatime work manager (using application context for thread safety)
        WakatimeWidgetWorker.setupPeriodicWork(this.applicationContext)`;
  if (content.includes(importStatement)) {
    logger2.info("WakatimeWidgetWorker import already exists");
  } else {
    const lastImportMatch = content.match(/^import\s+.+$/gm);
    if (lastImportMatch) {
      const lastImport = lastImportMatch[lastImportMatch.length - 1];
      const lastImportIndex = content.lastIndexOf(lastImport);
      const insertIndex = lastImportIndex + lastImport.length;
      content = content.slice(0, insertIndex) + "\n" + importStatement + content.slice(insertIndex);
      logger2.info("Added WakatimeWidgetWorker import");
    }
  }
  if (content.includes("WakatimeWidgetWorker.setupPeriodicWork(this)") || content.includes("WakatimeWidgetWorker.setupPeriodicWork(this.applicationContext)")) {
    logger2.info("WakatimeWidgetWorker initialization already exists");
    return content;
  } else {
    logger2.debug("WakatimeWidgetWorker initialization not found, proceeding with injection");
  }
  logger2.debug("Looking for onCreate method...");
  const superOnCreateRegex = /super\.onCreate\([^)]*\)/;
  const superOnCreateMatch = content.match(superOnCreateRegex);
  if (superOnCreateMatch) {
    logger2.debug("Found super.onCreate call, injecting WorkManager initialization");
    const superOnCreateCall = superOnCreateMatch[0];
    const superOnCreateIndex = content.indexOf(superOnCreateCall);
    const insertIndex = superOnCreateIndex + superOnCreateCall.length;
    content = content.slice(0, insertIndex) + initializationCode + content.slice(insertIndex);
    logger2.info("Added WakatimeWidgetWorker initialization after super.onCreate");
  } else {
    logger2.error("Could not find super.onCreate call to inject WorkManager initialization");
    logger2.debug(`Available content preview: ${content.substring(0, 500)}`);
  }
  return content;
}

// modules/expo-glance-widget/plugins/withPlugins.ts
var DEFAULT_OPTIONS = {
  widgetFilesPath: "widgets/android",
  manifestPath: "widgets/android/AndroidManifest.xml",
  resPath: "widgets/android/res",
  fileMatchPattern: "Widget",
  // Default: match files containing "Widget" in the name
  syncDirectory: "widgets/android",
  // Default sync directory for external sources
  enableWorkManager: true
  // Enable WorkManager by default
};
function getDefaultedOptions(options) {
  const mergedOptions = {
    ...DEFAULT_OPTIONS,
    ...options
  };
  FileUtils.ensureDir(mergedOptions.widgetFilesPath);
  mergedOptions.widgetFilesPath = import_path7.default.resolve(mergedOptions.widgetFilesPath);
  mergedOptions.manifestPath = import_path7.default.resolve(mergedOptions.manifestPath);
  mergedOptions.resPath = import_path7.default.resolve(mergedOptions.resPath);
  if (mergedOptions.syncDirectory) {
    mergedOptions.syncDirectory = import_path7.default.resolve(mergedOptions.syncDirectory);
  }
  if (!FileUtils.exists(mergedOptions.widgetFilesPath)) {
    Logger.warn(
      `ExpoGlanceWidgets: widgetFilesPath does not exist: ${mergedOptions.widgetFilesPath}`
    );
    const defaultWidgetPath = import_path7.default.resolve(DEFAULT_OPTIONS.widgetFilesPath);
    if (!FileUtils.exists(defaultWidgetPath)) {
      import_fs10.default.writeFileSync(defaultWidgetPath, `
        <manifest></manifest>
        `);
    }
    Logger.warn(`Using default widgetFilesPath: ${defaultWidgetPath}
`);
    mergedOptions.widgetFilesPath = defaultWidgetPath;
  }
  if (!FileUtils.exists(mergedOptions.manifestPath)) {
    Logger.warn(`ExpoGlanceWidgets: manifestPath does not exist: ${mergedOptions.manifestPath}`);
    const defaultManifestPath = import_path7.default.resolve(DEFAULT_OPTIONS.manifestPath);
    if (!FileUtils.exists(defaultManifestPath)) {
      FileUtils.ensureDir(import_path7.default.dirname(defaultManifestPath));
    }
    Logger.warn(`Using default manifestPath: ${defaultManifestPath}
`);
    mergedOptions.manifestPath = defaultManifestPath;
  }
  if (!FileUtils.exists(mergedOptions.resPath)) {
    Logger.warn(`ExpoGlanceWidgets: resPath does not exist: ${mergedOptions.resPath}`);
    const defaultResPath = import_path7.default.resolve(DEFAULT_OPTIONS.resPath);
    if (!FileUtils.exists(defaultResPath)) {
      FileUtils.ensureDir(import_path7.default.dirname(defaultResPath));
    }
    Logger.warn(`Using default resPath: ${defaultResPath}
`);
    mergedOptions.resPath = defaultResPath;
  }
  const isExternalWidgetPath = import_path7.default.isAbsolute(mergedOptions.widgetFilesPath) || mergedOptions.widgetFilesPath.startsWith("../");
  const isExternalManifestPath = import_path7.default.isAbsolute(mergedOptions.manifestPath) || mergedOptions.manifestPath.startsWith("../");
  const isExternalResPath = import_path7.default.isAbsolute(mergedOptions.resPath) || mergedOptions.resPath.startsWith("../");
  if ((isExternalWidgetPath || isExternalManifestPath || isExternalResPath) && !options.syncDirectory) {
    mergedOptions.syncDirectory = DEFAULT_OPTIONS.syncDirectory;
    console.log(
      `\u{1F50D} External widget sources detected, will sync to: ${mergedOptions.syncDirectory}`
    );
  }
  return mergedOptions;
}
var withExpoGlanceWidgets = (config, userOptions = {}) => {
  const options = getDefaultedOptions(userOptions);
  const sdkVersion = parseInt(config.sdkVersion?.split(".")[0] || "0", 10);
  if (sdkVersion < 53) {
    throw new Error("\u{1F6AB} Expo Glance Widgets requires SDK version 53 or higher.");
  }
  config = withComposeProjectLevelDependancyPlugin_default(config, options);
  config = withGlanceAppLevelGradleConfig(config);
  config = withGlanceWidgetFiles(config, options);
  if (options.enableWorkManager) {
    config = withWakatimeWorkManager(config, {
      packageName: options.destinationPackageName
    });
  }
  config = withWakatimeWorkerErrorHandling(config, {
    packageName: options.destinationPackageName
  });
  return config;
};
var withPlugins_default = withExpoGlanceWidgets;

// modules/expo-glance-widget/plugins/withMainApplicationWorkManager.ts
var import_config_plugins6 = __toESM(require_build4());
var fs6 = __toESM(require("fs"));
var path10 = __toESM(require("path"));
var logger3 = new Logger("WithMainApplicationWorkManager");
var withMainApplicationWorkManager = (config, options = {}) => {
  return (0, import_config_plugins6.withDangerousMod)(config, [
    "android",
    async (config2) => {
      const { platformProjectRoot } = config2.modRequest;
      const mainApplicationPath = findMainApplicationFile(platformProjectRoot);
      if (!mainApplicationPath) {
        logger3.warn("MainApplication.kt not found, skipping WorkManager injection");
        return config2;
      }
      let mainApplicationContent = fs6.readFileSync(mainApplicationPath, "utf8");
      const packageName = options.packageName || extractPackageName3(mainApplicationContent);
      if (!packageName) {
        logger3.warn("Could not determine package name, skipping WorkManager injection");
        return config2;
      }
      mainApplicationContent = injectWorkManagerIntoMainApplication(mainApplicationContent, packageName);
      fs6.writeFileSync(mainApplicationPath, mainApplicationContent);
      logger3.info("Successfully injected WorkManager initialization into MainApplication");
      return config2;
    }
  ]);
};
function findMainApplicationFile(platformProjectRoot) {
  function searchDirectory(dir) {
    if (!fs6.existsSync(dir)) return null;
    const files = fs6.readdirSync(dir);
    for (const file of files) {
      const filePath = path10.join(dir, file);
      const stat = fs6.statSync(filePath);
      if (stat.isDirectory()) {
        const result = searchDirectory(filePath);
        if (result) return result;
      } else if (file === "MainApplication.kt") {
        return filePath;
      }
    }
    return null;
  }
  const mainSrcPath = path10.join(platformProjectRoot, "app", "src", "main");
  if (fs6.existsSync(mainSrcPath)) {
    const javaPath = path10.join(mainSrcPath, "java");
    const kotlinPath = path10.join(mainSrcPath, "kotlin");
    let result = searchDirectory(javaPath);
    if (!result) {
      result = searchDirectory(kotlinPath);
    }
    return result;
  }
  return null;
}
function extractPackageName3(content) {
  const packageMatch = content.match(/^package\s+([a-zA-Z0-9_.]+)/m);
  return packageMatch ? packageMatch[1] : null;
}
function injectWorkManagerIntoMainApplication(content, packageName) {
  const requiredImports = [
    "import android.content.res.Configuration",
    "import androidx.work.Configuration",
    "import androidx.work.WorkManager"
  ];
  requiredImports.forEach((importStatement) => {
    if (!content.includes(importStatement)) {
      const lastImportMatch = content.match(/^import\s+.+$/gm);
      if (lastImportMatch) {
        const lastImport = lastImportMatch[lastImportMatch.length - 1];
        const lastImportIndex = content.lastIndexOf(lastImport);
        const insertIndex = lastImportIndex + lastImport.length;
        content = content.slice(0, insertIndex) + "\n" + importStatement + content.slice(insertIndex);
        logger3.info(`Added import: ${importStatement}`);
      }
    }
  });
  if (!content.includes("Configuration.Provider")) {
    const classDeclarationRegex = /class\s+MainApplication\s*:\s*Application\(\)\s*,\s*ReactApplication/;
    const classMatch = content.match(classDeclarationRegex);
    if (classMatch) {
      const classDeclaration = classMatch[0];
      const newClassDeclaration = classDeclaration + ", Configuration.Provider";
      content = content.replace(classDeclaration, newClassDeclaration);
      logger3.info("Added Configuration.Provider interface to MainApplication");
    }
  }
  if (!content.includes("getWorkManagerConfiguration")) {
    const workManagerConfigMethod = `
  // WorkManager configuration
  override fun getWorkManagerConfiguration(): Configuration =
      Configuration.Builder()
          .setMinimumLoggingLevel(android.util.Log.DEBUG)
          .build()`;
    const onCreateRegex = /override\s+fun\s+onCreate\(\)/;
    const onCreateMatch = content.match(onCreateRegex);
    if (onCreateMatch) {
      const onCreateIndex = content.indexOf(onCreateMatch[0]);
      content = content.slice(0, onCreateIndex) + workManagerConfigMethod + "\n\n  " + content.slice(onCreateIndex);
      logger3.info("Added getWorkManagerConfiguration method");
    }
  }
  if (!content.includes("WorkManager.initialize")) {
    const superOnCreateRegex = /super\.onCreate\(\)/;
    const superOnCreateMatch = content.match(superOnCreateRegex);
    if (superOnCreateMatch) {
      const superOnCreateCall = superOnCreateMatch[0];
      const superOnCreateIndex = content.indexOf(superOnCreateCall);
      const insertIndex = superOnCreateIndex + superOnCreateCall.length;
      const workManagerInit = `
        
        // Initialize WorkManager first
        WorkManager.initialize(this, workManagerConfiguration)`;
      content = content.slice(0, insertIndex) + workManagerInit + content.slice(insertIndex);
      logger3.info("Added WorkManager.initialize call to onCreate");
    }
  }
  return content;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_OPTIONS,
  DEFAULT_WIDGET_MERGE_CONFIG,
  FileUtils,
  Logger,
  SyncWidget,
  withComposeProjectLevelDependancyPlugin,
  withExpoGlanceWidgets,
  withGlanceAppLevelGradleConfig,
  withGlanceWidgetFiles,
  withMainApplicationWorkManager,
  withWakatimeWorkManager,
  withWakatimeWorkerErrorHandling
});
